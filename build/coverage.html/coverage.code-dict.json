{"/home/travis/build/npmtest/node-npmtest-auto-install/test.js":"/* istanbul instrument in package npmtest_auto_install */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireExampleJsFromReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-auto-install/lib.npmtest_auto_install.js":"/* istanbul instrument in package npmtest_auto_install */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_auto_install = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_auto_install = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-auto-install/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-auto-install && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_auto_install */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_auto_install\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught.stack);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_auto_install.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        local.assetsDict['/assets.npmtest_auto_install.rollup.js'] =\n            local.assetsDict['/assets.npmtest_auto_install.rollup.js'] ||\n            local.fs.readFileSync(\n                // buildCustomOrg-hack\n                local.npmtest_auto_install.__dirname +\n                    '/lib.npmtest_auto_install.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-auto-install/auto-install/src/index.js":"#!/usr/bin/env node\n\nconst helpers = require('./helpers');\nconst chokidar = require('chokidar');\nconst colors = require('colors');\nconst argv = require('yargs').argv;\n\nlet watchersInitialized = false;\nlet main;\n\n/* Secure mode */\n\nlet secureMode = false;\nif (argv.secure) secureMode = true;\n\nlet uninstallMode = true;\nif (argv['dont-uninstall']) uninstallMode = false;\n\n/* Watch files and repeat drill\n * Add a watcher, call main wrapper to repeat cycle\n */\n\nlet initializeWatchers = () => {\n    let watcher = chokidar.watch('**/*.js', {\n        ignored: 'node_modules'\n    });\n    watcher.on('change', main)\n    .on('unlink', main);\n\n    watchersInitialized = true;\n    console.log('Watchers initialized');\n};\n\n/* Main wrapper\n * Get installed modules from package.json\n * Get used modules from all files\n * Install used modules that are not installed\n * Remove installed modules that are not used\n * After setup, initialize watchers\n */\n\nmain = () => {\n    if (!helpers.packageJSONExists()) {\n        console.log(colors.red('package.json does not exist'));\n        console.log(colors.red('You can create one by using `npm init`'));\n        return;\n    }\n\n    let installedModules = [];\n    installedModules = helpers.getInstalledModules();\n\n    let usedModules = helpers.getUsedModules();\n    usedModules = helpers.filterRegistryModules(usedModules);\n\n    // removeUnusedModules\n\n    if (uninstallMode) {\n        let unusedModules = helpers.diff(installedModules, usedModules);\n        for (let module of unusedModules) helpers.uninstallModule(module);\n    }\n\n    // installModules\n\n    let modulesNotInstalled = helpers.diff(usedModules, installedModules);\n    for (let module of modulesNotInstalled) {\n        if (secureMode) helpers.installModuleIfTrusted(module);\n        else helpers.installModule(module);\n    }\n\n    helpers.cleanup();\n    if (!watchersInitialized) initializeWatchers();\n};\n\n/* Turn the key */\nmain();\n\n","/home/travis/build/npmtest/node-npmtest-auto-install/auto-install/src/helpers.js":"const fs = require('fs');\nconst glob = require('glob');\nconst isBuiltInModule = require('is-builtin-module');\nconst syncExec = require('sync-exec');\nconst ora = require('ora');\nconst logSymbols = require('log-symbols');\nconst request = require('request');\nconst detective = require('detective');\nconst es6detective = require('detective-es6');\nconst colors = require('colors');\nconst argv = require('yargs').argv;\nconst packageJson = require('package-json');\nrequire('./includes-polyfill');\n\n/* File reader\n * Return contents of given file\n */\nlet readFile = (path) => {\n    let content = fs.readFileSync(path, 'utf8');\n    return content;\n};\n\n/* Get installed modules\n * Read dependencies array from package.json\n */\n\nlet getInstalledModules = () => {\n    let content = JSON.parse(readFile('package.json'));\n    let installedModules = [];\n\n    let dependencies = content.dependencies || {};\n    let devDependencies = content.devDependencies || {};\n\n    for (let key of Object.keys(dependencies)) {\n        installedModules.push({\n            name: key,\n            dev: false\n        });\n    }\n    for (let key of Object.keys(devDependencies)) {\n        installedModules.push({\n            name: key,\n            dev: true\n        });\n    }\n\n    return installedModules;\n};\n\n/* Get all js files\n * Return path of all js files\n */\nlet getFiles = () => glob.sync('**/*.js', {ignore: ['node_modules/**/*']});\n\n/* Check for valid string - to stop malicious intentions */\n\nlet isValidModule = ({name}) => {\n    let regex = new RegExp('^([a-z0-9-_]{1,})$');\n    return regex.test(name);\n};\n\n/* Find modules from file\n * Returns array of modules from a file\n */\n\nlet getModulesFromFile = (path) => {\n    let content = fs.readFileSync(path, 'utf8');\n    let modules = [];\n    try {\n        modules = detective(content, {parse: {sourceType: 'module'}});\n\n        let es6modules = es6detective(content, {parse: {sourceType: 'module'}});\n        modules = modules.concat(es6modules);\n\n        modules = modules.filter((module) => isValidModule(module));\n    } catch (err) {\n        console.log(colors.red(`Could not parse ${path}. There is a syntax error in file`));\n    }\n    return modules;\n};\n\n/* Is test file?\n * [.spec.js, .test.js] are supported test file formats\n */\n\nlet isTestFile = (name) => (name.endsWith('.spec.js') || name.endsWith('.test.js'));\n\n/* Dedup similar modules\n * Deduplicates list\n * Ignores/assumes type of the modules in list\n*/\n\nlet deduplicateSimilarModules = (modules) => {\n    let dedupedModules = [];\n    let dedupedModuleNames = [];\n\n    for (let module of modules) {\n        if (!dedupedModuleNames.includes(module.name)) {\n            dedupedModules.push(module);\n            dedupedModuleNames.push(module.name);\n        }\n    }\n\n    return dedupedModules;\n};\n\n/* Dedup modules\n * Divide modules into prod and dev\n * Deduplicates each list\n */\n\nlet deduplicate = (modules) => {\n    let dedupedModules = [];\n\n    let testModules = modules.filter(module => module.dev);\n    dedupedModules = dedupedModules.concat(deduplicateSimilarModules(testModules));\n\n    let prodModules = modules.filter(module => !module.dev);\n    dedupedModules = dedupedModules.concat(deduplicateSimilarModules(prodModules));\n\n    return dedupedModules;\n};\n\n/* Get used modules\n * Read all .js files and grep for modules\n */\n\nlet getUsedModules = () => {\n    let files = getFiles();\n    let usedModules = [];\n    for (let fileName of files) {\n        let modulesFromFile = getModulesFromFile(fileName);\n        let dev = isTestFile(fileName);\n        for (let name of modulesFromFile) usedModules.push({name, dev});\n    }\n    usedModules = deduplicate(usedModules);\n    return usedModules;\n};\n\n/* Handle error\n * Pretty error message for common errors\n */\n\nlet handleError = (err) => {\n    if (err.includes('E404')) {\n        console.log(colors.red('Module is not in the npm registry.'));\n    } else if (err.includes('ENOTFOUND')) {\n        console.log(colors.red('Could not connect to npm, check your internet connection!'));\n    } else console.log(colors.red(err));\n};\n\n/* Command runner\n * Run a given command\n */\n\nlet runCommand = (command) => {\n    let response = syncExec(command);\n    if (response.stderr) {\n        console.log();\n        handleError(response.stderr);\n    }\n    return !response.status; // status = 0 for success\n};\n\n/* Show pretty outputs\n * Use ora spinners to show what's going on\n */\n\nlet startSpinner = (message, type) => {\n    let spinner = ora();\n    spinner.text = message;\n    spinner.color = type;\n    spinner.start();\n    return spinner;\n};\n\nlet stopSpinner = (spinner, message, type) => {\n    spinner.stop();\n    if (!message) return;\n    let symbol;\n    if (type === 'red') symbol = logSymbols.error;\n    else if (type === 'yellow') symbol = logSymbols.warning;\n    else symbol = logSymbols.success;\n    console.log(symbol, message);\n};\n\n/* Is module popular? - for secure mode */\n\nconst POPULARITY_THRESHOLD = 10000;\nlet isModulePopular = (name, callback) => {\n    let spinner = startSpinner(`Checking ${name}`, 'yellow');\n    let url = `https://api.npmjs.org/downloads/point/last-month/${name}`;\n    request(url, (error, response, body) => {\n        stopSpinner(spinner);\n        if (error && error.code === 'ENOTFOUND') {\n            console.log(colors.red('Could not connect to npm, check your internet connection!'));\n        } else {\n            let downloads = JSON.parse(body).downloads;\n            callback(downloads > POPULARITY_THRESHOLD);\n        }\n    });\n};\n\n/* Get install command\n *\n * Depends on package manager, dev and exact\n */\n\nlet getInstallCommand = (name, dev) => {\n    let packageManager = 'npm';\n    if (argv.yarn) packageManager = 'yarn';\n\n    let command;\n\n    if (packageManager === 'npm') {\n        command = `npm install ${name} --save`;\n        if (dev) command += '-dev';\n        if (argv.exact) command += ' --save-exact';\n    } else if (packageManager === 'yarn') {\n        command = `yarn add ${name}`;\n        if (dev) command += ' --dev';\n        // yarn always adds exact\n    }\n    return command;\n};\n\n/* Install module\n * Install given module\n */\n\nlet installModule = ({name, dev}) => {\n    let spinner = startSpinner(`Installing ${name}`, 'green');\n\n    let command = getInstallCommand(name, dev);\n\n    let message = `${name} installed`;\n    if (dev) message += ' in devDependencies';\n\n    let success = runCommand(command);\n    if (success) stopSpinner(spinner, message, 'green');\n    else stopSpinner(spinner, `${name} installation failed`, 'yellow');\n};\n\n/* is scoped module? */\n\nlet isScopedModule = (name) => name[0] === '@';\n\n/* Install module if author is trusted */\n\nlet installModuleIfTrustedAuthor = ({name, dev}) => {\n    let trustedAuthor = argv['trust-author'];\n    packageJson(name).then(json => {\n        if (json.author && json.author.name === trustedAuthor) installModule({name, dev});\n        else console.log(colors.red(`${name} not trusted`));\n    });\n};\n\n/* Install module if trusted\n * Call isModulePopular before installing\n */\n\nlet installModuleIfTrusted = ({name, dev}) => {\n    // Trust scoped modules\n    if (isScopedModule(name)) installModule({name, dev});\n    else {\n        isModulePopular(name, (popular) => {\n            // Popular as proxy for trusted\n            if (popular) installModule({name, dev});\n            // Trusted Author\n            else if (argv['trust-author']) installModuleIfTrustedAuthor({name, dev});\n            // Not trusted\n            else console.log(colors.red(`${name} not trusted`));\n        });\n    }\n};\n\n/* Get uninstall command\n *\n * Depends on package manager\n */\n\nlet getUninstallCommand = (name) => {\n    let packageManager = 'npm';\n    if (argv.yarn) packageManager = 'yarn';\n\n    let command;\n\n    if (packageManager === 'npm') command = `npm uninstall ${name} --save`;\n    else if (packageManager === 'yarn') command = `yarn remove ${name}`;\n\n    return command;\n};\n\n/* Uninstall module */\n\nlet uninstallModule = ({name, dev}) => {\n    if (dev) return;\n\n    let command = getUninstallCommand(name);\n    let message = `${name} removed`;\n\n    let spinner = startSpinner(`Uninstalling ${name}`, 'red');\n    runCommand(command);\n    stopSpinner(spinner, message, 'red');\n};\n\n/* Remove built in/native modules */\n\nlet removeBuiltInModules = (modules) => modules.filter((module) => !isBuiltInModule(module.name));\n\n/* Remove local files that are required */\n\nlet removeLocalFiles = (modules) => modules.filter((module) => !module.name.includes('./'));\n\n/* Remove file paths from module names\n * Example: convert `colors/safe` to `colors`\n */\n\nlet removeFilePaths = (modules) => {\n    for (let module of modules) {\n        let slicedName = module.name.split('/')[0];\n        if (slicedName.substr(0, 1) !== '@') module.name = slicedName;\n    }\n    return modules;\n};\n\n/* Filter registry modules */\n\nlet filterRegistryModules = (modules) => removeBuiltInModules(\n    removeFilePaths(\n    removeLocalFiles(\n        modules\n    )));\n\n/* Get module names from array of module objects */\n\nlet getNamesFromModules = (modules) => modules.map(module => module.name);\n\n/* Modules diff */\n\nlet diff = (first, second) => {\n    let namesFromSecond = getNamesFromModules(second);\n    return first.filter(module => !namesFromSecond.includes(module.name));\n};\n\n/* Reinstall modules */\n\nlet cleanup = () => {\n    let spinner = startSpinner('Cleaning up', 'green');\n    if (argv.yarn) runCommand('yarn');\n    else runCommand('npm install');\n    stopSpinner(spinner);\n};\n\n/* Does package.json exist?\n * Without package.json, most of the functionality fails\n *     installing + adding to package.json\n *     removing unused modules\n */\n\nlet packageJSONExists = () => fs.existsSync('package.json');\n\n/* Public helper functions */\n\nmodule.exports = {\n    getInstalledModules,\n    getUsedModules,\n    filterRegistryModules,\n    installModule,\n    installModuleIfTrusted,\n    uninstallModule,\n    diff,\n    cleanup,\n    packageJSONExists\n};\n\n","/home/travis/build/npmtest/node-npmtest-auto-install/auto-install/node_modules/glob/glob.js":"// Approach:\n//\n// 1. Get the minimatch set\n// 2. For each pattern in the set, PROCESS(pattern, false)\n// 3. Store matches per-set, then uniq them\n//\n// PROCESS(pattern, inGlobStar)\n// Get the first [n] items from pattern that are all strings\n// Join these together.  This is PREFIX.\n//   If there is no more remaining, then stat(PREFIX) and\n//   add to matches if it succeeds.  END.\n//\n// If inGlobStar and PREFIX is symlink and points to dir\n//   set ENTRIES = []\n// else readdir(PREFIX) as ENTRIES\n//   If fail, END\n//\n// with ENTRIES\n//   If pattern[n] is GLOBSTAR\n//     // handle the case where the globstar match is empty\n//     // by pruning it out, and testing the resulting pattern\n//     PROCESS(pattern[0..n] + pattern[n+1 .. $], false)\n//     // handle other cases.\n//     for ENTRY in ENTRIES (not dotfiles)\n//       // attach globstar + tail onto the entry\n//       // Mark that this entry is a globstar match\n//       PROCESS(pattern[0..n] + ENTRY + pattern[n .. $], true)\n//\n//   else // not globstar\n//     for ENTRY in ENTRIES (not dotfiles, unless pattern[n] is dot)\n//       Test ENTRY against pattern[n]\n//       If fails, continue\n//       If passes, PROCESS(pattern[0..n] + item + pattern[n+1 .. $])\n//\n// Caveat:\n//   Cache all stats and readdirs results to minimize syscall.  Since all\n//   we ever care about is existence and directory-ness, we can just keep\n//   `true` for files, and [children,...] for directories, or `false` for\n//   things that don't exist.\n\nmodule.exports = glob\n\nvar fs = require('fs')\nvar rp = require('fs.realpath')\nvar minimatch = require('minimatch')\nvar Minimatch = minimatch.Minimatch\nvar inherits = require('inherits')\nvar EE = require('events').EventEmitter\nvar path = require('path')\nvar assert = require('assert')\nvar isAbsolute = require('path-is-absolute')\nvar globSync = require('./sync.js')\nvar common = require('./common.js')\nvar alphasort = common.alphasort\nvar alphasorti = common.alphasorti\nvar setopts = common.setopts\nvar ownProp = common.ownProp\nvar inflight = require('inflight')\nvar util = require('util')\nvar childrenIgnored = common.childrenIgnored\nvar isIgnored = common.isIgnored\n\nvar once = require('once')\n\nfunction glob (pattern, options, cb) {\n  if (typeof options === 'function') cb = options, options = {}\n  if (!options) options = {}\n\n  if (options.sync) {\n    if (cb)\n      throw new TypeError('callback provided to sync glob')\n    return globSync(pattern, options)\n  }\n\n  return new Glob(pattern, options, cb)\n}\n\nglob.sync = globSync\nvar GlobSync = glob.GlobSync = globSync.GlobSync\n\n// old api surface\nglob.glob = glob\n\nfunction extend (origin, add) {\n  if (add === null || typeof add !== 'object') {\n    return origin\n  }\n\n  var keys = Object.keys(add)\n  var i = keys.length\n  while (i--) {\n    origin[keys[i]] = add[keys[i]]\n  }\n  return origin\n}\n\nglob.hasMagic = function (pattern, options_) {\n  var options = extend({}, options_)\n  options.noprocess = true\n\n  var g = new Glob(pattern, options)\n  var set = g.minimatch.set\n\n  if (!pattern)\n    return false\n\n  if (set.length > 1)\n    return true\n\n  for (var j = 0; j < set[0].length; j++) {\n    if (typeof set[0][j] !== 'string')\n      return true\n  }\n\n  return false\n}\n\nglob.Glob = Glob\ninherits(Glob, EE)\nfunction Glob (pattern, options, cb) {\n  if (typeof options === 'function') {\n    cb = options\n    options = null\n  }\n\n  if (options && options.sync) {\n    if (cb)\n      throw new TypeError('callback provided to sync glob')\n    return new GlobSync(pattern, options)\n  }\n\n  if (!(this instanceof Glob))\n    return new Glob(pattern, options, cb)\n\n  setopts(this, pattern, options)\n  this._didRealPath = false\n\n  // process each pattern in the minimatch set\n  var n = this.minimatch.set.length\n\n  // The matches are stored as {<filename>: true,...} so that\n  // duplicates are automagically pruned.\n  // Later, we do an Object.keys() on these.\n  // Keep them as a list so we can fill in when nonull is set.\n  this.matches = new Array(n)\n\n  if (typeof cb === 'function') {\n    cb = once(cb)\n    this.on('error', cb)\n    this.on('end', function (matches) {\n      cb(null, matches)\n    })\n  }\n\n  var self = this\n  var n = this.minimatch.set.length\n  this._processing = 0\n  this.matches = new Array(n)\n\n  this._emitQueue = []\n  this._processQueue = []\n  this.paused = false\n\n  if (this.noprocess)\n    return this\n\n  if (n === 0)\n    return done()\n\n  var sync = true\n  for (var i = 0; i < n; i ++) {\n    this._process(this.minimatch.set[i], i, false, done)\n  }\n  sync = false\n\n  function done () {\n    --self._processing\n    if (self._processing <= 0) {\n      if (sync) {\n        process.nextTick(function () {\n          self._finish()\n        })\n      } else {\n        self._finish()\n      }\n    }\n  }\n}\n\nGlob.prototype._finish = function () {\n  assert(this instanceof Glob)\n  if (this.aborted)\n    return\n\n  if (this.realpath && !this._didRealpath)\n    return this._realpath()\n\n  common.finish(this)\n  this.emit('end', this.found)\n}\n\nGlob.prototype._realpath = function () {\n  if (this._didRealpath)\n    return\n\n  this._didRealpath = true\n\n  var n = this.matches.length\n  if (n === 0)\n    return this._finish()\n\n  var self = this\n  for (var i = 0; i < this.matches.length; i++)\n    this._realpathSet(i, next)\n\n  function next () {\n    if (--n === 0)\n      self._finish()\n  }\n}\n\nGlob.prototype._realpathSet = function (index, cb) {\n  var matchset = this.matches[index]\n  if (!matchset)\n    return cb()\n\n  var found = Object.keys(matchset)\n  var self = this\n  var n = found.length\n\n  if (n === 0)\n    return cb()\n\n  var set = this.matches[index] = Object.create(null)\n  found.forEach(function (p, i) {\n    // If there's a problem with the stat, then it means that\n    // one or more of the links in the realpath couldn't be\n    // resolved.  just return the abs value in that case.\n    p = self._makeAbs(p)\n    rp.realpath(p, self.realpathCache, function (er, real) {\n      if (!er)\n        set[real] = true\n      else if (er.syscall === 'stat')\n        set[p] = true\n      else\n        self.emit('error', er) // srsly wtf right here\n\n      if (--n === 0) {\n        self.matches[index] = set\n        cb()\n      }\n    })\n  })\n}\n\nGlob.prototype._mark = function (p) {\n  return common.mark(this, p)\n}\n\nGlob.prototype._makeAbs = function (f) {\n  return common.makeAbs(this, f)\n}\n\nGlob.prototype.abort = function () {\n  this.aborted = true\n  this.emit('abort')\n}\n\nGlob.prototype.pause = function () {\n  if (!this.paused) {\n    this.paused = true\n    this.emit('pause')\n  }\n}\n\nGlob.prototype.resume = function () {\n  if (this.paused) {\n    this.emit('resume')\n    this.paused = false\n    if (this._emitQueue.length) {\n      var eq = this._emitQueue.slice(0)\n      this._emitQueue.length = 0\n      for (var i = 0; i < eq.length; i ++) {\n        var e = eq[i]\n        this._emitMatch(e[0], e[1])\n      }\n    }\n    if (this._processQueue.length) {\n      var pq = this._processQueue.slice(0)\n      this._processQueue.length = 0\n      for (var i = 0; i < pq.length; i ++) {\n        var p = pq[i]\n        this._processing--\n        this._process(p[0], p[1], p[2], p[3])\n      }\n    }\n  }\n}\n\nGlob.prototype._process = function (pattern, index, inGlobStar, cb) {\n  assert(this instanceof Glob)\n  assert(typeof cb === 'function')\n\n  if (this.aborted)\n    return\n\n  this._processing++\n  if (this.paused) {\n    this._processQueue.push([pattern, index, inGlobStar, cb])\n    return\n  }\n\n  //console.error('PROCESS %d', this._processing, pattern)\n\n  // Get the first [n] parts of pattern that are all strings.\n  var n = 0\n  while (typeof pattern[n] === 'string') {\n    n ++\n  }\n  // now n is the index of the first one that is *not* a string.\n\n  // see if there's anything else\n  var prefix\n  switch (n) {\n    // if not, then this is rather simple\n    case pattern.length:\n      this._processSimple(pattern.join('/'), index, cb)\n      return\n\n    case 0:\n      // pattern *starts* with some non-trivial item.\n      // going to readdir(cwd), but not include the prefix in matches.\n      prefix = null\n      break\n\n    default:\n      // pattern has some string bits in the front.\n      // whatever it starts with, whether that's 'absolute' like /foo/bar,\n      // or 'relative' like '../baz'\n      prefix = pattern.slice(0, n).join('/')\n      break\n  }\n\n  var remain = pattern.slice(n)\n\n  // get the list of entries.\n  var read\n  if (prefix === null)\n    read = '.'\n  else if (isAbsolute(prefix) || isAbsolute(pattern.join('/'))) {\n    if (!prefix || !isAbsolute(prefix))\n      prefix = '/' + prefix\n    read = prefix\n  } else\n    read = prefix\n\n  var abs = this._makeAbs(read)\n\n  //if ignored, skip _processing\n  if (childrenIgnored(this, read))\n    return cb()\n\n  var isGlobStar = remain[0] === minimatch.GLOBSTAR\n  if (isGlobStar)\n    this._processGlobStar(prefix, read, abs, remain, index, inGlobStar, cb)\n  else\n    this._processReaddir(prefix, read, abs, remain, index, inGlobStar, cb)\n}\n\nGlob.prototype._processReaddir = function (prefix, read, abs, remain, index, inGlobStar, cb) {\n  var self = this\n  this._readdir(abs, inGlobStar, function (er, entries) {\n    return self._processReaddir2(prefix, read, abs, remain, index, inGlobStar, entries, cb)\n  })\n}\n\nGlob.prototype._processReaddir2 = function (prefix, read, abs, remain, index, inGlobStar, entries, cb) {\n\n  // if the abs isn't a dir, then nothing can match!\n  if (!entries)\n    return cb()\n\n  // It will only match dot entries if it starts with a dot, or if\n  // dot is set.  Stuff like @(.foo|.bar) isn't allowed.\n  var pn = remain[0]\n  var negate = !!this.minimatch.negate\n  var rawGlob = pn._glob\n  var dotOk = this.dot || rawGlob.charAt(0) === '.'\n\n  var matchedEntries = []\n  for (var i = 0; i < entries.length; i++) {\n    var e = entries[i]\n    if (e.charAt(0) !== '.' || dotOk) {\n      var m\n      if (negate && !prefix) {\n        m = !e.match(pn)\n      } else {\n        m = e.match(pn)\n      }\n      if (m)\n        matchedEntries.push(e)\n    }\n  }\n\n  //console.error('prd2', prefix, entries, remain[0]._glob, matchedEntries)\n\n  var len = matchedEntries.length\n  // If there are no matched entries, then nothing matches.\n  if (len === 0)\n    return cb()\n\n  // if this is the last remaining pattern bit, then no need for\n  // an additional stat *unless* the user has specified mark or\n  // stat explicitly.  We know they exist, since readdir returned\n  // them.\n\n  if (remain.length === 1 && !this.mark && !this.stat) {\n    if (!this.matches[index])\n      this.matches[index] = Object.create(null)\n\n    for (var i = 0; i < len; i ++) {\n      var e = matchedEntries[i]\n      if (prefix) {\n        if (prefix !== '/')\n          e = prefix + '/' + e\n        else\n          e = prefix + e\n      }\n\n      if (e.charAt(0) === '/' && !this.nomount) {\n        e = path.join(this.root, e)\n      }\n      this._emitMatch(index, e)\n    }\n    // This was the last one, and no stats were needed\n    return cb()\n  }\n\n  // now test all matched entries as stand-ins for that part\n  // of the pattern.\n  remain.shift()\n  for (var i = 0; i < len; i ++) {\n    var e = matchedEntries[i]\n    var newPattern\n    if (prefix) {\n      if (prefix !== '/')\n        e = prefix + '/' + e\n      else\n        e = prefix + e\n    }\n    this._process([e].concat(remain), index, inGlobStar, cb)\n  }\n  cb()\n}\n\nGlob.prototype._emitMatch = function (index, e) {\n  if (this.aborted)\n    return\n\n  if (isIgnored(this, e))\n    return\n\n  if (this.paused) {\n    this._emitQueue.push([index, e])\n    return\n  }\n\n  var abs = this._makeAbs(e)\n\n  if (this.mark)\n    e = this._mark(e)\n\n  if (this.absolute)\n    e = abs\n\n  if (this.matches[index][e])\n    return\n\n  if (this.nodir) {\n    var c = this.cache[abs]\n    if (c === 'DIR' || Array.isArray(c))\n      return\n  }\n\n  this.matches[index][e] = true\n\n  var st = this.statCache[abs]\n  if (st)\n    this.emit('stat', e, st)\n\n  this.emit('match', e)\n}\n\nGlob.prototype._readdirInGlobStar = function (abs, cb) {\n  if (this.aborted)\n    return\n\n  // follow all symlinked directories forever\n  // just proceed as if this is a non-globstar situation\n  if (this.follow)\n    return this._readdir(abs, false, cb)\n\n  var lstatkey = 'lstat\\0' + abs\n  var self = this\n  var lstatcb = inflight(lstatkey, lstatcb_)\n\n  if (lstatcb)\n    fs.lstat(abs, lstatcb)\n\n  function lstatcb_ (er, lstat) {\n    if (er)\n      return cb()\n\n    var isSym = lstat.isSymbolicLink()\n    self.symlinks[abs] = isSym\n\n    // If it's not a symlink or a dir, then it's definitely a regular file.\n    // don't bother doing a readdir in that case.\n    if (!isSym && !lstat.isDirectory()) {\n      self.cache[abs] = 'FILE'\n      cb()\n    } else\n      self._readdir(abs, false, cb)\n  }\n}\n\nGlob.prototype._readdir = function (abs, inGlobStar, cb) {\n  if (this.aborted)\n    return\n\n  cb = inflight('readdir\\0'+abs+'\\0'+inGlobStar, cb)\n  if (!cb)\n    return\n\n  //console.error('RD %j %j', +inGlobStar, abs)\n  if (inGlobStar && !ownProp(this.symlinks, abs))\n    return this._readdirInGlobStar(abs, cb)\n\n  if (ownProp(this.cache, abs)) {\n    var c = this.cache[abs]\n    if (!c || c === 'FILE')\n      return cb()\n\n    if (Array.isArray(c))\n      return cb(null, c)\n  }\n\n  var self = this\n  fs.readdir(abs, readdirCb(this, abs, cb))\n}\n\nfunction readdirCb (self, abs, cb) {\n  return function (er, entries) {\n    if (er)\n      self._readdirError(abs, er, cb)\n    else\n      self._readdirEntries(abs, entries, cb)\n  }\n}\n\nGlob.prototype._readdirEntries = function (abs, entries, cb) {\n  if (this.aborted)\n    return\n\n  // if we haven't asked to stat everything, then just\n  // assume that everything in there exists, so we can avoid\n  // having to stat it a second time.\n  if (!this.mark && !this.stat) {\n    for (var i = 0; i < entries.length; i ++) {\n      var e = entries[i]\n      if (abs === '/')\n        e = abs + e\n      else\n        e = abs + '/' + e\n      this.cache[e] = true\n    }\n  }\n\n  this.cache[abs] = entries\n  return cb(null, entries)\n}\n\nGlob.prototype._readdirError = function (f, er, cb) {\n  if (this.aborted)\n    return\n\n  // handle errors, and cache the information\n  switch (er.code) {\n    case 'ENOTSUP': // https://github.com/isaacs/node-glob/issues/205\n    case 'ENOTDIR': // totally normal. means it *does* exist.\n      var abs = this._makeAbs(f)\n      this.cache[abs] = 'FILE'\n      if (abs === this.cwdAbs) {\n        var error = new Error(er.code + ' invalid cwd ' + this.cwd)\n        error.path = this.cwd\n        error.code = er.code\n        this.emit('error', error)\n        this.abort()\n      }\n      break\n\n    case 'ENOENT': // not terribly unusual\n    case 'ELOOP':\n    case 'ENAMETOOLONG':\n    case 'UNKNOWN':\n      this.cache[this._makeAbs(f)] = false\n      break\n\n    default: // some unusual error.  Treat as failure.\n      this.cache[this._makeAbs(f)] = false\n      if (this.strict) {\n        this.emit('error', er)\n        // If the error is handled, then we abort\n        // if not, we threw out of here\n        this.abort()\n      }\n      if (!this.silent)\n        console.error('glob error', er)\n      break\n  }\n\n  return cb()\n}\n\nGlob.prototype._processGlobStar = function (prefix, read, abs, remain, index, inGlobStar, cb) {\n  var self = this\n  this._readdir(abs, inGlobStar, function (er, entries) {\n    self._processGlobStar2(prefix, read, abs, remain, index, inGlobStar, entries, cb)\n  })\n}\n\n\nGlob.prototype._processGlobStar2 = function (prefix, read, abs, remain, index, inGlobStar, entries, cb) {\n  //console.error('pgs2', prefix, remain[0], entries)\n\n  // no entries means not a dir, so it can never have matches\n  // foo.txt/** doesn't match foo.txt\n  if (!entries)\n    return cb()\n\n  // test without the globstar, and with every child both below\n  // and replacing the globstar.\n  var remainWithoutGlobStar = remain.slice(1)\n  var gspref = prefix ? [ prefix ] : []\n  var noGlobStar = gspref.concat(remainWithoutGlobStar)\n\n  // the noGlobStar pattern exits the inGlobStar state\n  this._process(noGlobStar, index, false, cb)\n\n  var isSym = this.symlinks[abs]\n  var len = entries.length\n\n  // If it's a symlink, and we're in a globstar, then stop\n  if (isSym && inGlobStar)\n    return cb()\n\n  for (var i = 0; i < len; i++) {\n    var e = entries[i]\n    if (e.charAt(0) === '.' && !this.dot)\n      continue\n\n    // these two cases enter the inGlobStar state\n    var instead = gspref.concat(entries[i], remainWithoutGlobStar)\n    this._process(instead, index, true, cb)\n\n    var below = gspref.concat(entries[i], remain)\n    this._process(below, index, true, cb)\n  }\n\n  cb()\n}\n\nGlob.prototype._processSimple = function (prefix, index, cb) {\n  // XXX review this.  Shouldn't it be doing the mounting etc\n  // before doing stat?  kinda weird?\n  var self = this\n  this._stat(prefix, function (er, exists) {\n    self._processSimple2(prefix, index, er, exists, cb)\n  })\n}\nGlob.prototype._processSimple2 = function (prefix, index, er, exists, cb) {\n\n  //console.error('ps2', prefix, exists)\n\n  if (!this.matches[index])\n    this.matches[index] = Object.create(null)\n\n  // If it doesn't exist, then just mark the lack of results\n  if (!exists)\n    return cb()\n\n  if (prefix && isAbsolute(prefix) && !this.nomount) {\n    var trail = /[\\/\\\\]$/.test(prefix)\n    if (prefix.charAt(0) === '/') {\n      prefix = path.join(this.root, prefix)\n    } else {\n      prefix = path.resolve(this.root, prefix)\n      if (trail)\n        prefix += '/'\n    }\n  }\n\n  if (process.platform === 'win32')\n    prefix = prefix.replace(/\\\\/g, '/')\n\n  // Mark this as a match\n  this._emitMatch(index, prefix)\n  cb()\n}\n\n// Returns either 'DIR', 'FILE', or false\nGlob.prototype._stat = function (f, cb) {\n  var abs = this._makeAbs(f)\n  var needDir = f.slice(-1) === '/'\n\n  if (f.length > this.maxLength)\n    return cb()\n\n  if (!this.stat && ownProp(this.cache, abs)) {\n    var c = this.cache[abs]\n\n    if (Array.isArray(c))\n      c = 'DIR'\n\n    // It exists, but maybe not how we need it\n    if (!needDir || c === 'DIR')\n      return cb(null, c)\n\n    if (needDir && c === 'FILE')\n      return cb()\n\n    // otherwise we have to stat, because maybe c=true\n    // if we know it exists, but not what it is.\n  }\n\n  var exists\n  var stat = this.statCache[abs]\n  if (stat !== undefined) {\n    if (stat === false)\n      return cb(null, stat)\n    else {\n      var type = stat.isDirectory() ? 'DIR' : 'FILE'\n      if (needDir && type === 'FILE')\n        return cb()\n      else\n        return cb(null, type, stat)\n    }\n  }\n\n  var self = this\n  var statcb = inflight('stat\\0' + abs, lstatcb_)\n  if (statcb)\n    fs.lstat(abs, statcb)\n\n  function lstatcb_ (er, lstat) {\n    if (lstat && lstat.isSymbolicLink()) {\n      // If it's a symlink, then treat it as the target, unless\n      // the target does not exist, then treat it as a file.\n      return fs.stat(abs, function (er, stat) {\n        if (er)\n          self._stat2(f, abs, null, lstat, cb)\n        else\n          self._stat2(f, abs, er, stat, cb)\n      })\n    } else {\n      self._stat2(f, abs, er, lstat, cb)\n    }\n  }\n}\n\nGlob.prototype._stat2 = function (f, abs, er, stat, cb) {\n  if (er) {\n    this.statCache[abs] = false\n    return cb()\n  }\n\n  var needDir = f.slice(-1) === '/'\n  this.statCache[abs] = stat\n\n  if (abs.slice(-1) === '/' && !stat.isDirectory())\n    return cb(null, false, stat)\n\n  var c = stat.isDirectory() ? 'DIR' : 'FILE'\n  this.cache[abs] = this.cache[abs] || c\n\n  if (needDir && c !== 'DIR')\n    return cb()\n\n  return cb(null, c, stat)\n}\n","/home/travis/build/npmtest/node-npmtest-auto-install/auto-install/node_modules/glob/sync.js":"module.exports = globSync\nglobSync.GlobSync = GlobSync\n\nvar fs = require('fs')\nvar rp = require('fs.realpath')\nvar minimatch = require('minimatch')\nvar Minimatch = minimatch.Minimatch\nvar Glob = require('./glob.js').Glob\nvar util = require('util')\nvar path = require('path')\nvar assert = require('assert')\nvar isAbsolute = require('path-is-absolute')\nvar common = require('./common.js')\nvar alphasort = common.alphasort\nvar alphasorti = common.alphasorti\nvar setopts = common.setopts\nvar ownProp = common.ownProp\nvar childrenIgnored = common.childrenIgnored\nvar isIgnored = common.isIgnored\n\nfunction globSync (pattern, options) {\n  if (typeof options === 'function' || arguments.length === 3)\n    throw new TypeError('callback provided to sync glob\\n'+\n                        'See: https://github.com/isaacs/node-glob/issues/167')\n\n  return new GlobSync(pattern, options).found\n}\n\nfunction GlobSync (pattern, options) {\n  if (!pattern)\n    throw new Error('must provide pattern')\n\n  if (typeof options === 'function' || arguments.length === 3)\n    throw new TypeError('callback provided to sync glob\\n'+\n                        'See: https://github.com/isaacs/node-glob/issues/167')\n\n  if (!(this instanceof GlobSync))\n    return new GlobSync(pattern, options)\n\n  setopts(this, pattern, options)\n\n  if (this.noprocess)\n    return this\n\n  var n = this.minimatch.set.length\n  this.matches = new Array(n)\n  for (var i = 0; i < n; i ++) {\n    this._process(this.minimatch.set[i], i, false)\n  }\n  this._finish()\n}\n\nGlobSync.prototype._finish = function () {\n  assert(this instanceof GlobSync)\n  if (this.realpath) {\n    var self = this\n    this.matches.forEach(function (matchset, index) {\n      var set = self.matches[index] = Object.create(null)\n      for (var p in matchset) {\n        try {\n          p = self._makeAbs(p)\n          var real = rp.realpathSync(p, self.realpathCache)\n          set[real] = true\n        } catch (er) {\n          if (er.syscall === 'stat')\n            set[self._makeAbs(p)] = true\n          else\n            throw er\n        }\n      }\n    })\n  }\n  common.finish(this)\n}\n\n\nGlobSync.prototype._process = function (pattern, index, inGlobStar) {\n  assert(this instanceof GlobSync)\n\n  // Get the first [n] parts of pattern that are all strings.\n  var n = 0\n  while (typeof pattern[n] === 'string') {\n    n ++\n  }\n  // now n is the index of the first one that is *not* a string.\n\n  // See if there's anything else\n  var prefix\n  switch (n) {\n    // if not, then this is rather simple\n    case pattern.length:\n      this._processSimple(pattern.join('/'), index)\n      return\n\n    case 0:\n      // pattern *starts* with some non-trivial item.\n      // going to readdir(cwd), but not include the prefix in matches.\n      prefix = null\n      break\n\n    default:\n      // pattern has some string bits in the front.\n      // whatever it starts with, whether that's 'absolute' like /foo/bar,\n      // or 'relative' like '../baz'\n      prefix = pattern.slice(0, n).join('/')\n      break\n  }\n\n  var remain = pattern.slice(n)\n\n  // get the list of entries.\n  var read\n  if (prefix === null)\n    read = '.'\n  else if (isAbsolute(prefix) || isAbsolute(pattern.join('/'))) {\n    if (!prefix || !isAbsolute(prefix))\n      prefix = '/' + prefix\n    read = prefix\n  } else\n    read = prefix\n\n  var abs = this._makeAbs(read)\n\n  //if ignored, skip processing\n  if (childrenIgnored(this, read))\n    return\n\n  var isGlobStar = remain[0] === minimatch.GLOBSTAR\n  if (isGlobStar)\n    this._processGlobStar(prefix, read, abs, remain, index, inGlobStar)\n  else\n    this._processReaddir(prefix, read, abs, remain, index, inGlobStar)\n}\n\n\nGlobSync.prototype._processReaddir = function (prefix, read, abs, remain, index, inGlobStar) {\n  var entries = this._readdir(abs, inGlobStar)\n\n  // if the abs isn't a dir, then nothing can match!\n  if (!entries)\n    return\n\n  // It will only match dot entries if it starts with a dot, or if\n  // dot is set.  Stuff like @(.foo|.bar) isn't allowed.\n  var pn = remain[0]\n  var negate = !!this.minimatch.negate\n  var rawGlob = pn._glob\n  var dotOk = this.dot || rawGlob.charAt(0) === '.'\n\n  var matchedEntries = []\n  for (var i = 0; i < entries.length; i++) {\n    var e = entries[i]\n    if (e.charAt(0) !== '.' || dotOk) {\n      var m\n      if (negate && !prefix) {\n        m = !e.match(pn)\n      } else {\n        m = e.match(pn)\n      }\n      if (m)\n        matchedEntries.push(e)\n    }\n  }\n\n  var len = matchedEntries.length\n  // If there are no matched entries, then nothing matches.\n  if (len === 0)\n    return\n\n  // if this is the last remaining pattern bit, then no need for\n  // an additional stat *unless* the user has specified mark or\n  // stat explicitly.  We know they exist, since readdir returned\n  // them.\n\n  if (remain.length === 1 && !this.mark && !this.stat) {\n    if (!this.matches[index])\n      this.matches[index] = Object.create(null)\n\n    for (var i = 0; i < len; i ++) {\n      var e = matchedEntries[i]\n      if (prefix) {\n        if (prefix.slice(-1) !== '/')\n          e = prefix + '/' + e\n        else\n          e = prefix + e\n      }\n\n      if (e.charAt(0) === '/' && !this.nomount) {\n        e = path.join(this.root, e)\n      }\n      this._emitMatch(index, e)\n    }\n    // This was the last one, and no stats were needed\n    return\n  }\n\n  // now test all matched entries as stand-ins for that part\n  // of the pattern.\n  remain.shift()\n  for (var i = 0; i < len; i ++) {\n    var e = matchedEntries[i]\n    var newPattern\n    if (prefix)\n      newPattern = [prefix, e]\n    else\n      newPattern = [e]\n    this._process(newPattern.concat(remain), index, inGlobStar)\n  }\n}\n\n\nGlobSync.prototype._emitMatch = function (index, e) {\n  if (isIgnored(this, e))\n    return\n\n  var abs = this._makeAbs(e)\n\n  if (this.mark)\n    e = this._mark(e)\n\n  if (this.absolute) {\n    e = abs\n  }\n\n  if (this.matches[index][e])\n    return\n\n  if (this.nodir) {\n    var c = this.cache[abs]\n    if (c === 'DIR' || Array.isArray(c))\n      return\n  }\n\n  this.matches[index][e] = true\n\n  if (this.stat)\n    this._stat(e)\n}\n\n\nGlobSync.prototype._readdirInGlobStar = function (abs) {\n  // follow all symlinked directories forever\n  // just proceed as if this is a non-globstar situation\n  if (this.follow)\n    return this._readdir(abs, false)\n\n  var entries\n  var lstat\n  var stat\n  try {\n    lstat = fs.lstatSync(abs)\n  } catch (er) {\n    // lstat failed, doesn't exist\n    return null\n  }\n\n  var isSym = lstat.isSymbolicLink()\n  this.symlinks[abs] = isSym\n\n  // If it's not a symlink or a dir, then it's definitely a regular file.\n  // don't bother doing a readdir in that case.\n  if (!isSym && !lstat.isDirectory())\n    this.cache[abs] = 'FILE'\n  else\n    entries = this._readdir(abs, false)\n\n  return entries\n}\n\nGlobSync.prototype._readdir = function (abs, inGlobStar) {\n  var entries\n\n  if (inGlobStar && !ownProp(this.symlinks, abs))\n    return this._readdirInGlobStar(abs)\n\n  if (ownProp(this.cache, abs)) {\n    var c = this.cache[abs]\n    if (!c || c === 'FILE')\n      return null\n\n    if (Array.isArray(c))\n      return c\n  }\n\n  try {\n    return this._readdirEntries(abs, fs.readdirSync(abs))\n  } catch (er) {\n    this._readdirError(abs, er)\n    return null\n  }\n}\n\nGlobSync.prototype._readdirEntries = function (abs, entries) {\n  // if we haven't asked to stat everything, then just\n  // assume that everything in there exists, so we can avoid\n  // having to stat it a second time.\n  if (!this.mark && !this.stat) {\n    for (var i = 0; i < entries.length; i ++) {\n      var e = entries[i]\n      if (abs === '/')\n        e = abs + e\n      else\n        e = abs + '/' + e\n      this.cache[e] = true\n    }\n  }\n\n  this.cache[abs] = entries\n\n  // mark and cache dir-ness\n  return entries\n}\n\nGlobSync.prototype._readdirError = function (f, er) {\n  // handle errors, and cache the information\n  switch (er.code) {\n    case 'ENOTSUP': // https://github.com/isaacs/node-glob/issues/205\n    case 'ENOTDIR': // totally normal. means it *does* exist.\n      var abs = this._makeAbs(f)\n      this.cache[abs] = 'FILE'\n      if (abs === this.cwdAbs) {\n        var error = new Error(er.code + ' invalid cwd ' + this.cwd)\n        error.path = this.cwd\n        error.code = er.code\n        throw error\n      }\n      break\n\n    case 'ENOENT': // not terribly unusual\n    case 'ELOOP':\n    case 'ENAMETOOLONG':\n    case 'UNKNOWN':\n      this.cache[this._makeAbs(f)] = false\n      break\n\n    default: // some unusual error.  Treat as failure.\n      this.cache[this._makeAbs(f)] = false\n      if (this.strict)\n        throw er\n      if (!this.silent)\n        console.error('glob error', er)\n      break\n  }\n}\n\nGlobSync.prototype._processGlobStar = function (prefix, read, abs, remain, index, inGlobStar) {\n\n  var entries = this._readdir(abs, inGlobStar)\n\n  // no entries means not a dir, so it can never have matches\n  // foo.txt/** doesn't match foo.txt\n  if (!entries)\n    return\n\n  // test without the globstar, and with every child both below\n  // and replacing the globstar.\n  var remainWithoutGlobStar = remain.slice(1)\n  var gspref = prefix ? [ prefix ] : []\n  var noGlobStar = gspref.concat(remainWithoutGlobStar)\n\n  // the noGlobStar pattern exits the inGlobStar state\n  this._process(noGlobStar, index, false)\n\n  var len = entries.length\n  var isSym = this.symlinks[abs]\n\n  // If it's a symlink, and we're in a globstar, then stop\n  if (isSym && inGlobStar)\n    return\n\n  for (var i = 0; i < len; i++) {\n    var e = entries[i]\n    if (e.charAt(0) === '.' && !this.dot)\n      continue\n\n    // these two cases enter the inGlobStar state\n    var instead = gspref.concat(entries[i], remainWithoutGlobStar)\n    this._process(instead, index, true)\n\n    var below = gspref.concat(entries[i], remain)\n    this._process(below, index, true)\n  }\n}\n\nGlobSync.prototype._processSimple = function (prefix, index) {\n  // XXX review this.  Shouldn't it be doing the mounting etc\n  // before doing stat?  kinda weird?\n  var exists = this._stat(prefix)\n\n  if (!this.matches[index])\n    this.matches[index] = Object.create(null)\n\n  // If it doesn't exist, then just mark the lack of results\n  if (!exists)\n    return\n\n  if (prefix && isAbsolute(prefix) && !this.nomount) {\n    var trail = /[\\/\\\\]$/.test(prefix)\n    if (prefix.charAt(0) === '/') {\n      prefix = path.join(this.root, prefix)\n    } else {\n      prefix = path.resolve(this.root, prefix)\n      if (trail)\n        prefix += '/'\n    }\n  }\n\n  if (process.platform === 'win32')\n    prefix = prefix.replace(/\\\\/g, '/')\n\n  // Mark this as a match\n  this._emitMatch(index, prefix)\n}\n\n// Returns either 'DIR', 'FILE', or false\nGlobSync.prototype._stat = function (f) {\n  var abs = this._makeAbs(f)\n  var needDir = f.slice(-1) === '/'\n\n  if (f.length > this.maxLength)\n    return false\n\n  if (!this.stat && ownProp(this.cache, abs)) {\n    var c = this.cache[abs]\n\n    if (Array.isArray(c))\n      c = 'DIR'\n\n    // It exists, but maybe not how we need it\n    if (!needDir || c === 'DIR')\n      return c\n\n    if (needDir && c === 'FILE')\n      return false\n\n    // otherwise we have to stat, because maybe c=true\n    // if we know it exists, but not what it is.\n  }\n\n  var exists\n  var stat = this.statCache[abs]\n  if (!stat) {\n    var lstat\n    try {\n      lstat = fs.lstatSync(abs)\n    } catch (er) {\n      return false\n    }\n\n    if (lstat.isSymbolicLink()) {\n      try {\n        stat = fs.statSync(abs)\n      } catch (er) {\n        stat = lstat\n      }\n    } else {\n      stat = lstat\n    }\n  }\n\n  this.statCache[abs] = stat\n\n  var c = stat.isDirectory() ? 'DIR' : 'FILE'\n  this.cache[abs] = this.cache[abs] || c\n\n  if (needDir && c !== 'DIR')\n    return false\n\n  return c\n}\n\nGlobSync.prototype._mark = function (p) {\n  return common.mark(this, p)\n}\n\nGlobSync.prototype._makeAbs = function (f) {\n  return common.makeAbs(this, f)\n}\n","/home/travis/build/npmtest/node-npmtest-auto-install/auto-install/node_modules/glob/common.js":"exports.alphasort = alphasort\nexports.alphasorti = alphasorti\nexports.setopts = setopts\nexports.ownProp = ownProp\nexports.makeAbs = makeAbs\nexports.finish = finish\nexports.mark = mark\nexports.isIgnored = isIgnored\nexports.childrenIgnored = childrenIgnored\n\nfunction ownProp (obj, field) {\n  return Object.prototype.hasOwnProperty.call(obj, field)\n}\n\nvar path = require(\"path\")\nvar minimatch = require(\"minimatch\")\nvar isAbsolute = require(\"path-is-absolute\")\nvar Minimatch = minimatch.Minimatch\n\nfunction alphasorti (a, b) {\n  return a.toLowerCase().localeCompare(b.toLowerCase())\n}\n\nfunction alphasort (a, b) {\n  return a.localeCompare(b)\n}\n\nfunction setupIgnores (self, options) {\n  self.ignore = options.ignore || []\n\n  if (!Array.isArray(self.ignore))\n    self.ignore = [self.ignore]\n\n  if (self.ignore.length) {\n    self.ignore = self.ignore.map(ignoreMap)\n  }\n}\n\n// ignore patterns are always in dot:true mode.\nfunction ignoreMap (pattern) {\n  var gmatcher = null\n  if (pattern.slice(-3) === '/**') {\n    var gpattern = pattern.replace(/(\\/\\*\\*)+$/, '')\n    gmatcher = new Minimatch(gpattern, { dot: true })\n  }\n\n  return {\n    matcher: new Minimatch(pattern, { dot: true }),\n    gmatcher: gmatcher\n  }\n}\n\nfunction setopts (self, pattern, options) {\n  if (!options)\n    options = {}\n\n  // base-matching: just use globstar for that.\n  if (options.matchBase && -1 === pattern.indexOf(\"/\")) {\n    if (options.noglobstar) {\n      throw new Error(\"base matching requires globstar\")\n    }\n    pattern = \"**/\" + pattern\n  }\n\n  self.silent = !!options.silent\n  self.pattern = pattern\n  self.strict = options.strict !== false\n  self.realpath = !!options.realpath\n  self.realpathCache = options.realpathCache || Object.create(null)\n  self.follow = !!options.follow\n  self.dot = !!options.dot\n  self.mark = !!options.mark\n  self.nodir = !!options.nodir\n  if (self.nodir)\n    self.mark = true\n  self.sync = !!options.sync\n  self.nounique = !!options.nounique\n  self.nonull = !!options.nonull\n  self.nosort = !!options.nosort\n  self.nocase = !!options.nocase\n  self.stat = !!options.stat\n  self.noprocess = !!options.noprocess\n  self.absolute = !!options.absolute\n\n  self.maxLength = options.maxLength || Infinity\n  self.cache = options.cache || Object.create(null)\n  self.statCache = options.statCache || Object.create(null)\n  self.symlinks = options.symlinks || Object.create(null)\n\n  setupIgnores(self, options)\n\n  self.changedCwd = false\n  var cwd = process.cwd()\n  if (!ownProp(options, \"cwd\"))\n    self.cwd = cwd\n  else {\n    self.cwd = path.resolve(options.cwd)\n    self.changedCwd = self.cwd !== cwd\n  }\n\n  self.root = options.root || path.resolve(self.cwd, \"/\")\n  self.root = path.resolve(self.root)\n  if (process.platform === \"win32\")\n    self.root = self.root.replace(/\\\\/g, \"/\")\n\n  self.cwdAbs = makeAbs(self, self.cwd)\n  self.nomount = !!options.nomount\n\n  // disable comments and negation in Minimatch.\n  // Note that they are not supported in Glob itself anyway.\n  options.nonegate = true\n  options.nocomment = true\n\n  self.minimatch = new Minimatch(pattern, options)\n  self.options = self.minimatch.options\n}\n\nfunction finish (self) {\n  var nou = self.nounique\n  var all = nou ? [] : Object.create(null)\n\n  for (var i = 0, l = self.matches.length; i < l; i ++) {\n    var matches = self.matches[i]\n    if (!matches || Object.keys(matches).length === 0) {\n      if (self.nonull) {\n        // do like the shell, and spit out the literal glob\n        var literal = self.minimatch.globSet[i]\n        if (nou)\n          all.push(literal)\n        else\n          all[literal] = true\n      }\n    } else {\n      // had matches\n      var m = Object.keys(matches)\n      if (nou)\n        all.push.apply(all, m)\n      else\n        m.forEach(function (m) {\n          all[m] = true\n        })\n    }\n  }\n\n  if (!nou)\n    all = Object.keys(all)\n\n  if (!self.nosort)\n    all = all.sort(self.nocase ? alphasorti : alphasort)\n\n  // at *some* point we statted all of these\n  if (self.mark) {\n    for (var i = 0; i < all.length; i++) {\n      all[i] = self._mark(all[i])\n    }\n    if (self.nodir) {\n      all = all.filter(function (e) {\n        var notDir = !(/\\/$/.test(e))\n        var c = self.cache[e] || self.cache[makeAbs(self, e)]\n        if (notDir && c)\n          notDir = c !== 'DIR' && !Array.isArray(c)\n        return notDir\n      })\n    }\n  }\n\n  if (self.ignore.length)\n    all = all.filter(function(m) {\n      return !isIgnored(self, m)\n    })\n\n  self.found = all\n}\n\nfunction mark (self, p) {\n  var abs = makeAbs(self, p)\n  var c = self.cache[abs]\n  var m = p\n  if (c) {\n    var isDir = c === 'DIR' || Array.isArray(c)\n    var slash = p.slice(-1) === '/'\n\n    if (isDir && !slash)\n      m += '/'\n    else if (!isDir && slash)\n      m = m.slice(0, -1)\n\n    if (m !== p) {\n      var mabs = makeAbs(self, m)\n      self.statCache[mabs] = self.statCache[abs]\n      self.cache[mabs] = self.cache[abs]\n    }\n  }\n\n  return m\n}\n\n// lotta situps...\nfunction makeAbs (self, f) {\n  var abs = f\n  if (f.charAt(0) === '/') {\n    abs = path.join(self.root, f)\n  } else if (isAbsolute(f) || f === '') {\n    abs = f\n  } else if (self.changedCwd) {\n    abs = path.resolve(self.cwd, f)\n  } else {\n    abs = path.resolve(f)\n  }\n\n  if (process.platform === 'win32')\n    abs = abs.replace(/\\\\/g, '/')\n\n  return abs\n}\n\n\n// Return true, if pattern ends with globstar '**', for the accompanying parent directory.\n// Ex:- If node_modules/** is the pattern, add 'node_modules' to ignore list along with it's contents\nfunction isIgnored (self, path) {\n  if (!self.ignore.length)\n    return false\n\n  return self.ignore.some(function(item) {\n    return item.matcher.match(path) || !!(item.gmatcher && item.gmatcher.match(path))\n  })\n}\n\nfunction childrenIgnored (self, path) {\n  if (!self.ignore.length)\n    return false\n\n  return self.ignore.some(function(item) {\n    return !!(item.gmatcher && item.gmatcher.match(path))\n  })\n}\n","/home/travis/build/npmtest/node-npmtest-auto-install/auto-install/node_modules/ora/index.js":"'use strict';\nconst chalk = require('chalk');\nconst cliCursor = require('cli-cursor');\nconst cliSpinners = require('cli-spinners');\nconst logSymbols = require('log-symbols');\n\nclass Ora {\n\tconstructor(options) {\n\t\tif (typeof options === 'string') {\n\t\t\toptions = {\n\t\t\t\ttext: options\n\t\t\t};\n\t\t}\n\n\t\tthis.options = Object.assign({\n\t\t\ttext: '',\n\t\t\tcolor: 'cyan',\n\t\t\tstream: process.stderr\n\t\t}, options);\n\n\t\tconst sp = this.options.spinner;\n\t\tthis.spinner = typeof sp === 'object' ? sp : (process.platform === 'win32' ? cliSpinners.line : (cliSpinners[sp] || cliSpinners.dots)); // eslint-disable-line no-nested-ternary\n\n\t\tif (this.spinner.frames === undefined) {\n\t\t\tthrow new Error('Spinner must define `frames`');\n\t\t}\n\n\t\tthis.text = this.options.text;\n\t\tthis.color = this.options.color;\n\t\tthis.interval = this.options.interval || this.spinner.interval || 100;\n\t\tthis.stream = this.options.stream;\n\t\tthis.id = null;\n\t\tthis.frameIndex = 0;\n\t\tthis.enabled = this.options.enabled || ((this.stream && this.stream.isTTY) && !process.env.CI);\n\t}\n\tframe() {\n\t\tconst frames = this.spinner.frames;\n\t\tlet frame = frames[this.frameIndex];\n\n\t\tif (this.color) {\n\t\t\tframe = chalk[this.color](frame);\n\t\t}\n\n\t\tthis.frameIndex = ++this.frameIndex % frames.length;\n\n\t\treturn frame + ' ' + this.text;\n\t}\n\tclear() {\n\t\tif (!this.enabled) {\n\t\t\treturn this;\n\t\t}\n\n\t\tthis.stream.clearLine();\n\t\tthis.stream.cursorTo(0);\n\n\t\treturn this;\n\t}\n\trender() {\n\t\tthis.clear();\n\t\tthis.stream.write(this.frame());\n\n\t\treturn this;\n\t}\n\tstart() {\n\t\tif (!this.enabled || this.id) {\n\t\t\treturn this;\n\t\t}\n\n\t\tcliCursor.hide();\n\t\tthis.render();\n\t\tthis.id = setInterval(this.render.bind(this), this.interval);\n\n\t\treturn this;\n\t}\n\tstop() {\n\t\tif (!this.enabled) {\n\t\t\treturn this;\n\t\t}\n\n\t\tclearInterval(this.id);\n\t\tthis.id = null;\n\t\tthis.frameIndex = 0;\n\t\tthis.clear();\n\t\tcliCursor.show();\n\n\t\treturn this;\n\t}\n\tsucceed() {\n\t\treturn this.stopAndPersist(logSymbols.success);\n\t}\n\tfail() {\n\t\treturn this.stopAndPersist(logSymbols.error);\n\t}\n\tstopAndPersist(symbol) {\n\t\tthis.stop();\n\t\tthis.stream.write(`${symbol || ' '} ${this.text}\\n`);\n\n\t\treturn this;\n\t}\n}\n\nmodule.exports = function (opts) {\n\treturn new Ora(opts);\n};\n","/home/travis/build/npmtest/node-npmtest-auto-install/auto-install/node_modules/cli-cursor/index.js":"'use strict';\nvar restoreCursor = require('restore-cursor');\nvar hidden = false;\n\nexports.show = function () {\n\thidden = false;\n\tprocess.stdout.write('\\u001b[?25h');\n};\n\nexports.hide = function () {\n\trestoreCursor();\n\thidden = true;\n\tprocess.stdout.write('\\u001b[?25l');\n};\n\nexports.toggle = function (force) {\n\tif (force !== undefined) {\n\t\thidden = force;\n\t}\n\n\tif (hidden) {\n\t\texports.show();\n\t} else {\n\t\texports.hide();\n\t}\n};\n","/home/travis/build/npmtest/node-npmtest-auto-install/auto-install/node_modules/restore-cursor/index.js":"'use strict';\nvar onetime = require('onetime');\nvar exitHook = require('exit-hook');\n\nmodule.exports = onetime(function () {\n\texitHook(function () {\n\t\tprocess.stdout.write('\\u001b[?25h');\n\t});\n});\n","/home/travis/build/npmtest/node-npmtest-auto-install/auto-install/node_modules/onetime/index.js":"'use strict';\nmodule.exports = function (fn, errMsg) {\n\tif (typeof fn !== 'function') {\n\t\tthrow new TypeError('Expected a function');\n\t}\n\n\tvar ret;\n\tvar called = false;\n\tvar fnName = fn.displayName || fn.name || (/function ([^\\(]+)/.exec(fn.toString()) || [])[1];\n\n\tvar onetime = function () {\n\t\tif (called) {\n\t\t\tif (errMsg === true) {\n\t\t\t\tfnName = fnName ? fnName + '()' : 'Function';\n\t\t\t\tthrow new Error(fnName + ' can only be called once.');\n\t\t\t}\n\n\t\t\treturn ret;\n\t\t}\n\n\t\tcalled = true;\n\t\tret = fn.apply(this, arguments);\n\t\tfn = null;\n\n\t\treturn ret;\n\t};\n\n\tonetime.displayName = fnName;\n\n\treturn onetime;\n};\n","/home/travis/build/npmtest/node-npmtest-auto-install/auto-install/node_modules/cli-spinners/index.js":"'use strict';\nmodule.exports = require('./spinners.json');\n","/home/travis/build/npmtest/node-npmtest-auto-install/auto-install/node_modules/request/index.js":"// Copyright 2010-2012 Mikeal Rogers\n//\n//    Licensed under the Apache License, Version 2.0 (the \"License\");\n//    you may not use this file except in compliance with the License.\n//    You may obtain a copy of the License at\n//\n//        http://www.apache.org/licenses/LICENSE-2.0\n//\n//    Unless required by applicable law or agreed to in writing, software\n//    distributed under the License is distributed on an \"AS IS\" BASIS,\n//    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n//    See the License for the specific language governing permissions and\n//    limitations under the License.\n\n'use strict'\n\nvar extend                = require('extend')\n  , cookies               = require('./lib/cookies')\n  , helpers               = require('./lib/helpers')\n\nvar isFunction            = helpers.isFunction\n  , paramsHaveRequestBody = helpers.paramsHaveRequestBody\n\n\n// organize params for patch, post, put, head, del\nfunction initParams(uri, options, callback) {\n  if (typeof options === 'function') {\n    callback = options\n  }\n\n  var params = {}\n  if (typeof options === 'object') {\n    extend(params, options, {uri: uri})\n  } else if (typeof uri === 'string') {\n    extend(params, {uri: uri})\n  } else {\n    extend(params, uri)\n  }\n\n  params.callback = callback || params.callback\n  return params\n}\n\nfunction request (uri, options, callback) {\n  if (typeof uri === 'undefined') {\n    throw new Error('undefined is not a valid uri or options object.')\n  }\n\n  var params = initParams(uri, options, callback)\n\n  if (params.method === 'HEAD' && paramsHaveRequestBody(params)) {\n    throw new Error('HTTP HEAD requests MUST NOT include a request body.')\n  }\n\n  return new request.Request(params)\n}\n\nfunction verbFunc (verb) {\n  var method = verb.toUpperCase()\n  return function (uri, options, callback) {\n    var params = initParams(uri, options, callback)\n    params.method = method\n    return request(params, params.callback)\n  }\n}\n\n// define like this to please codeintel/intellisense IDEs\nrequest.get = verbFunc('get')\nrequest.head = verbFunc('head')\nrequest.post = verbFunc('post')\nrequest.put = verbFunc('put')\nrequest.patch = verbFunc('patch')\nrequest.del = verbFunc('delete')\nrequest['delete'] = verbFunc('delete')\n\nrequest.jar = function (store) {\n  return cookies.jar(store)\n}\n\nrequest.cookie = function (str) {\n  return cookies.parse(str)\n}\n\nfunction wrapRequestMethod (method, options, requester, verb) {\n\n  return function (uri, opts, callback) {\n    var params = initParams(uri, opts, callback)\n\n    var target = {}\n    extend(true, target, options, params)\n\n    target.pool = params.pool || options.pool\n\n    if (verb) {\n      target.method = verb.toUpperCase()\n    }\n\n    if (isFunction(requester)) {\n      method = requester\n    }\n\n    return method(target, target.callback)\n  }\n}\n\nrequest.defaults = function (options, requester) {\n  var self = this\n\n  options = options || {}\n\n  if (typeof options === 'function') {\n    requester = options\n    options = {}\n  }\n\n  var defaults      = wrapRequestMethod(self, options, requester)\n\n  var verbs = ['get', 'head', 'post', 'put', 'patch', 'del', 'delete']\n  verbs.forEach(function(verb) {\n    defaults[verb]  = wrapRequestMethod(self[verb], options, requester, verb)\n  })\n\n  defaults.cookie   = wrapRequestMethod(self.cookie, options, requester)\n  defaults.jar      = self.jar\n  defaults.defaults = self.defaults\n  return defaults\n}\n\nrequest.forever = function (agentOptions, optionsArg) {\n  var options = {}\n  if (optionsArg) {\n    extend(options, optionsArg)\n  }\n  if (agentOptions) {\n    options.agentOptions = agentOptions\n  }\n\n  options.forever = true\n  return request.defaults(options)\n}\n\n// Exports\n\nmodule.exports = request\nrequest.Request = require('./request')\nrequest.initParams = initParams\n\n// Backwards compatibility for request.debug\nObject.defineProperty(request, 'debug', {\n  enumerable : true,\n  get : function() {\n    return request.Request.debug\n  },\n  set : function(debug) {\n    request.Request.debug = debug\n  }\n})\n","/home/travis/build/npmtest/node-npmtest-auto-install/auto-install/node_modules/request/lib/cookies.js":"'use strict'\n\nvar tough = require('tough-cookie')\n\nvar Cookie = tough.Cookie\n  , CookieJar = tough.CookieJar\n\n\nexports.parse = function(str) {\n  if (str && str.uri) {\n    str = str.uri\n  }\n  if (typeof str !== 'string') {\n    throw new Error('The cookie function only accepts STRING as param')\n  }\n  return Cookie.parse(str, {loose: true})\n}\n\n// Adapt the sometimes-Async api of tough.CookieJar to our requirements\nfunction RequestJar(store) {\n  var self = this\n  self._jar = new CookieJar(store, {looseMode: true})\n}\nRequestJar.prototype.setCookie = function(cookieOrStr, uri, options) {\n  var self = this\n  return self._jar.setCookieSync(cookieOrStr, uri, options || {})\n}\nRequestJar.prototype.getCookieString = function(uri) {\n  var self = this\n  return self._jar.getCookieStringSync(uri)\n}\nRequestJar.prototype.getCookies = function(uri) {\n  var self = this\n  return self._jar.getCookiesSync(uri)\n}\n\nexports.jar = function(store) {\n  return new RequestJar(store)\n}\n","/home/travis/build/npmtest/node-npmtest-auto-install/auto-install/node_modules/request/lib/helpers.js":"'use strict'\n\nvar jsonSafeStringify = require('json-stringify-safe')\n  , crypto = require('crypto')\n\nfunction deferMethod() {\n  if (typeof setImmediate === 'undefined') {\n    return process.nextTick\n  }\n\n  return setImmediate\n}\n\nfunction isFunction(value) {\n  return typeof value === 'function'\n}\n\nfunction paramsHaveRequestBody(params) {\n  return (\n    params.body ||\n    params.requestBodyStream ||\n    (params.json && typeof params.json !== 'boolean') ||\n    params.multipart\n  )\n}\n\nfunction safeStringify (obj, replacer) {\n  var ret\n  try {\n    ret = JSON.stringify(obj, replacer)\n  } catch (e) {\n    ret = jsonSafeStringify(obj, replacer)\n  }\n  return ret\n}\n\nfunction md5 (str) {\n  return crypto.createHash('md5').update(str).digest('hex')\n}\n\nfunction isReadStream (rs) {\n  return rs.readable && rs.path && rs.mode\n}\n\nfunction toBase64 (str) {\n  return (new Buffer(str || '', 'utf8')).toString('base64')\n}\n\nfunction copy (obj) {\n  var o = {}\n  Object.keys(obj).forEach(function (i) {\n    o[i] = obj[i]\n  })\n  return o\n}\n\nfunction version () {\n  var numbers = process.version.replace('v', '').split('.')\n  return {\n    major: parseInt(numbers[0], 10),\n    minor: parseInt(numbers[1], 10),\n    patch: parseInt(numbers[2], 10)\n  }\n}\n\nexports.isFunction            = isFunction\nexports.paramsHaveRequestBody = paramsHaveRequestBody\nexports.safeStringify         = safeStringify\nexports.md5                   = md5\nexports.isReadStream          = isReadStream\nexports.toBase64              = toBase64\nexports.copy                  = copy\nexports.version               = version\nexports.defer                 = deferMethod()\n","/home/travis/build/npmtest/node-npmtest-auto-install/auto-install/node_modules/request/request.js":"'use strict'\n\nvar http = require('http')\n  , https = require('https')\n  , url = require('url')\n  , util = require('util')\n  , stream = require('stream')\n  , zlib = require('zlib')\n  , bl = require('bl')\n  , hawk = require('hawk')\n  , aws2 = require('aws-sign2')\n  , aws4 = require('aws4')\n  , httpSignature = require('http-signature')\n  , mime = require('mime-types')\n  , stringstream = require('stringstream')\n  , caseless = require('caseless')\n  , ForeverAgent = require('forever-agent')\n  , FormData = require('form-data')\n  , extend = require('extend')\n  , isstream = require('isstream')\n  , isTypedArray = require('is-typedarray').strict\n  , helpers = require('./lib/helpers')\n  , cookies = require('./lib/cookies')\n  , getProxyFromURI = require('./lib/getProxyFromURI')\n  , Querystring = require('./lib/querystring').Querystring\n  , Har = require('./lib/har').Har\n  , Auth = require('./lib/auth').Auth\n  , OAuth = require('./lib/oauth').OAuth\n  , Multipart = require('./lib/multipart').Multipart\n  , Redirect = require('./lib/redirect').Redirect\n  , Tunnel = require('./lib/tunnel').Tunnel\n\nvar safeStringify = helpers.safeStringify\n  , isReadStream = helpers.isReadStream\n  , toBase64 = helpers.toBase64\n  , defer = helpers.defer\n  , copy = helpers.copy\n  , version = helpers.version\n  , globalCookieJar = cookies.jar()\n\n\nvar globalPool = {}\n\nfunction filterForNonReserved(reserved, options) {\n  // Filter out properties that are not reserved.\n  // Reserved values are passed in at call site.\n\n  var object = {}\n  for (var i in options) {\n    var notReserved = (reserved.indexOf(i) === -1)\n    if (notReserved) {\n      object[i] = options[i]\n    }\n  }\n  return object\n}\n\nfunction filterOutReservedFunctions(reserved, options) {\n  // Filter out properties that are functions and are reserved.\n  // Reserved values are passed in at call site.\n\n  var object = {}\n  for (var i in options) {\n    var isReserved = !(reserved.indexOf(i) === -1)\n    var isFunction = (typeof options[i] === 'function')\n    if (!(isReserved && isFunction)) {\n      object[i] = options[i]\n    }\n  }\n  return object\n\n}\n\n// Return a simpler request object to allow serialization\nfunction requestToJSON() {\n  var self = this\n  return {\n    uri: self.uri,\n    method: self.method,\n    headers: self.headers\n  }\n}\n\n// Return a simpler response object to allow serialization\nfunction responseToJSON() {\n  var self = this\n  return {\n    statusCode: self.statusCode,\n    body: self.body,\n    headers: self.headers,\n    request: requestToJSON.call(self.request)\n  }\n}\n\nfunction Request (options) {\n  // if given the method property in options, set property explicitMethod to true\n\n  // extend the Request instance with any non-reserved properties\n  // remove any reserved functions from the options object\n  // set Request instance to be readable and writable\n  // call init\n\n  var self = this\n\n  // start with HAR, then override with additional options\n  if (options.har) {\n    self._har = new Har(self)\n    options = self._har.options(options)\n  }\n\n  stream.Stream.call(self)\n  var reserved = Object.keys(Request.prototype)\n  var nonReserved = filterForNonReserved(reserved, options)\n\n  extend(self, nonReserved)\n  options = filterOutReservedFunctions(reserved, options)\n\n  self.readable = true\n  self.writable = true\n  if (options.method) {\n    self.explicitMethod = true\n  }\n  self._qs = new Querystring(self)\n  self._auth = new Auth(self)\n  self._oauth = new OAuth(self)\n  self._multipart = new Multipart(self)\n  self._redirect = new Redirect(self)\n  self._tunnel = new Tunnel(self)\n  self.init(options)\n}\n\nutil.inherits(Request, stream.Stream)\n\n// Debugging\nRequest.debug = process.env.NODE_DEBUG && /\\brequest\\b/.test(process.env.NODE_DEBUG)\nfunction debug() {\n  if (Request.debug) {\n    console.error('REQUEST %s', util.format.apply(util, arguments))\n  }\n}\nRequest.prototype.debug = debug\n\nRequest.prototype.init = function (options) {\n  // init() contains all the code to setup the request object.\n  // the actual outgoing request is not started until start() is called\n  // this function is called from both the constructor and on redirect.\n  var self = this\n  if (!options) {\n    options = {}\n  }\n  self.headers = self.headers ? copy(self.headers) : {}\n\n  // Delete headers with value undefined since they break\n  // ClientRequest.OutgoingMessage.setHeader in node 0.12\n  for (var headerName in self.headers) {\n    if (typeof self.headers[headerName] === 'undefined') {\n      delete self.headers[headerName]\n    }\n  }\n\n  caseless.httpify(self, self.headers)\n\n  if (!self.method) {\n    self.method = options.method || 'GET'\n  }\n  if (!self.localAddress) {\n    self.localAddress = options.localAddress\n  }\n\n  self._qs.init(options)\n\n  debug(options)\n  if (!self.pool && self.pool !== false) {\n    self.pool = globalPool\n  }\n  self.dests = self.dests || []\n  self.__isRequestRequest = true\n\n  // Protect against double callback\n  if (!self._callback && self.callback) {\n    self._callback = self.callback\n    self.callback = function () {\n      if (self._callbackCalled) {\n        return // Print a warning maybe?\n      }\n      self._callbackCalled = true\n      self._callback.apply(self, arguments)\n    }\n    self.on('error', self.callback.bind())\n    self.on('complete', self.callback.bind(self, null))\n  }\n\n  // People use this property instead all the time, so support it\n  if (!self.uri && self.url) {\n    self.uri = self.url\n    delete self.url\n  }\n\n  // If there's a baseUrl, then use it as the base URL (i.e. uri must be\n  // specified as a relative path and is appended to baseUrl).\n  if (self.baseUrl) {\n    if (typeof self.baseUrl !== 'string') {\n      return self.emit('error', new Error('options.baseUrl must be a string'))\n    }\n\n    if (typeof self.uri !== 'string') {\n      return self.emit('error', new Error('options.uri must be a string when using options.baseUrl'))\n    }\n\n    if (self.uri.indexOf('//') === 0 || self.uri.indexOf('://') !== -1) {\n      return self.emit('error', new Error('options.uri must be a path when using options.baseUrl'))\n    }\n\n    // Handle all cases to make sure that there's only one slash between\n    // baseUrl and uri.\n    var baseUrlEndsWithSlash = self.baseUrl.lastIndexOf('/') === self.baseUrl.length - 1\n    var uriStartsWithSlash = self.uri.indexOf('/') === 0\n\n    if (baseUrlEndsWithSlash && uriStartsWithSlash) {\n      self.uri = self.baseUrl + self.uri.slice(1)\n    } else if (baseUrlEndsWithSlash || uriStartsWithSlash) {\n      self.uri = self.baseUrl + self.uri\n    } else if (self.uri === '') {\n      self.uri = self.baseUrl\n    } else {\n      self.uri = self.baseUrl + '/' + self.uri\n    }\n    delete self.baseUrl\n  }\n\n  // A URI is needed by this point, emit error if we haven't been able to get one\n  if (!self.uri) {\n    return self.emit('error', new Error('options.uri is a required argument'))\n  }\n\n  // If a string URI/URL was given, parse it into a URL object\n  if (typeof self.uri === 'string') {\n    self.uri = url.parse(self.uri)\n  }\n\n  // Some URL objects are not from a URL parsed string and need href added\n  if (!self.uri.href) {\n    self.uri.href = url.format(self.uri)\n  }\n\n  // DEPRECATED: Warning for users of the old Unix Sockets URL Scheme\n  if (self.uri.protocol === 'unix:') {\n    return self.emit('error', new Error('`unix://` URL scheme is no longer supported. Please use the format `http://unix:SOCKET:PATH`'))\n  }\n\n  // Support Unix Sockets\n  if (self.uri.host === 'unix') {\n    self.enableUnixSocket()\n  }\n\n  if (self.strictSSL === false) {\n    self.rejectUnauthorized = false\n  }\n\n  if (!self.uri.pathname) {self.uri.pathname = '/'}\n\n  if (!(self.uri.host || (self.uri.hostname && self.uri.port)) && !self.uri.isUnix) {\n    // Invalid URI: it may generate lot of bad errors, like 'TypeError: Cannot call method `indexOf` of undefined' in CookieJar\n    // Detect and reject it as soon as possible\n    var faultyUri = url.format(self.uri)\n    var message = 'Invalid URI \"' + faultyUri + '\"'\n    if (Object.keys(options).length === 0) {\n      // No option ? This can be the sign of a redirect\n      // As this is a case where the user cannot do anything (they didn't call request directly with this URL)\n      // they should be warned that it can be caused by a redirection (can save some hair)\n      message += '. This can be caused by a crappy redirection.'\n    }\n    // This error was fatal\n    self.abort()\n    return self.emit('error', new Error(message))\n  }\n\n  if (!self.hasOwnProperty('proxy')) {\n    self.proxy = getProxyFromURI(self.uri)\n  }\n\n  self.tunnel = self._tunnel.isEnabled()\n  if (self.proxy) {\n    self._tunnel.setup(options)\n  }\n\n  self._redirect.onRequest(options)\n\n  self.setHost = false\n  if (!self.hasHeader('host')) {\n    var hostHeaderName = self.originalHostHeaderName || 'host'\n    self.setHeader(hostHeaderName, self.uri.hostname)\n    if (self.uri.port) {\n      if ( !(self.uri.port === 80 && self.uri.protocol === 'http:') &&\n           !(self.uri.port === 443 && self.uri.protocol === 'https:') ) {\n        self.setHeader(hostHeaderName, self.getHeader('host') + (':' + self.uri.port) )\n      }\n    }\n    self.setHost = true\n  }\n\n  self.jar(self._jar || options.jar)\n\n  if (!self.uri.port) {\n    if (self.uri.protocol === 'http:') {self.uri.port = 80}\n    else if (self.uri.protocol === 'https:') {self.uri.port = 443}\n  }\n\n  if (self.proxy && !self.tunnel) {\n    self.port = self.proxy.port\n    self.host = self.proxy.hostname\n  } else {\n    self.port = self.uri.port\n    self.host = self.uri.hostname\n  }\n\n  if (options.form) {\n    self.form(options.form)\n  }\n\n  if (options.formData) {\n    var formData = options.formData\n    var requestForm = self.form()\n    var appendFormValue = function (key, value) {\n      if (value && value.hasOwnProperty('value') && value.hasOwnProperty('options')) {\n        requestForm.append(key, value.value, value.options)\n      } else {\n        requestForm.append(key, value)\n      }\n    }\n    for (var formKey in formData) {\n      if (formData.hasOwnProperty(formKey)) {\n        var formValue = formData[formKey]\n        if (formValue instanceof Array) {\n          for (var j = 0; j < formValue.length; j++) {\n            appendFormValue(formKey, formValue[j])\n          }\n        } else {\n          appendFormValue(formKey, formValue)\n        }\n      }\n    }\n  }\n\n  if (options.qs) {\n    self.qs(options.qs)\n  }\n\n  if (self.uri.path) {\n    self.path = self.uri.path\n  } else {\n    self.path = self.uri.pathname + (self.uri.search || '')\n  }\n\n  if (self.path.length === 0) {\n    self.path = '/'\n  }\n\n  // Auth must happen last in case signing is dependent on other headers\n  if (options.aws) {\n    self.aws(options.aws)\n  }\n\n  if (options.hawk) {\n    self.hawk(options.hawk)\n  }\n\n  if (options.httpSignature) {\n    self.httpSignature(options.httpSignature)\n  }\n\n  if (options.auth) {\n    if (Object.prototype.hasOwnProperty.call(options.auth, 'username')) {\n      options.auth.user = options.auth.username\n    }\n    if (Object.prototype.hasOwnProperty.call(options.auth, 'password')) {\n      options.auth.pass = options.auth.password\n    }\n\n    self.auth(\n      options.auth.user,\n      options.auth.pass,\n      options.auth.sendImmediately,\n      options.auth.bearer\n    )\n  }\n\n  if (self.gzip && !self.hasHeader('accept-encoding')) {\n    self.setHeader('accept-encoding', 'gzip, deflate')\n  }\n\n  if (self.uri.auth && !self.hasHeader('authorization')) {\n    var uriAuthPieces = self.uri.auth.split(':').map(function(item) {return self._qs.unescape(item)})\n    self.auth(uriAuthPieces[0], uriAuthPieces.slice(1).join(':'), true)\n  }\n\n  if (!self.tunnel && self.proxy && self.proxy.auth && !self.hasHeader('proxy-authorization')) {\n    var proxyAuthPieces = self.proxy.auth.split(':').map(function(item) {return self._qs.unescape(item)})\n    var authHeader = 'Basic ' + toBase64(proxyAuthPieces.join(':'))\n    self.setHeader('proxy-authorization', authHeader)\n  }\n\n  if (self.proxy && !self.tunnel) {\n    self.path = (self.uri.protocol + '//' + self.uri.host + self.path)\n  }\n\n  if (options.json) {\n    self.json(options.json)\n  }\n  if (options.multipart) {\n    self.multipart(options.multipart)\n  }\n\n  if (options.time) {\n    self.timing = true\n    self.elapsedTime = self.elapsedTime || 0\n  }\n\n  function setContentLength () {\n    if (isTypedArray(self.body)) {\n      self.body = new Buffer(self.body)\n    }\n\n    if (!self.hasHeader('content-length')) {\n      var length\n      if (typeof self.body === 'string') {\n        length = Buffer.byteLength(self.body)\n      }\n      else if (Array.isArray(self.body)) {\n        length = self.body.reduce(function (a, b) {return a + b.length}, 0)\n      }\n      else {\n        length = self.body.length\n      }\n\n      if (length) {\n        self.setHeader('content-length', length)\n      } else {\n        self.emit('error', new Error('Argument error, options.body.'))\n      }\n    }\n  }\n  if (self.body && !isstream(self.body)) {\n    setContentLength()\n  }\n\n  if (options.oauth) {\n    self.oauth(options.oauth)\n  } else if (self._oauth.params && self.hasHeader('authorization')) {\n    self.oauth(self._oauth.params)\n  }\n\n  var protocol = self.proxy && !self.tunnel ? self.proxy.protocol : self.uri.protocol\n    , defaultModules = {'http:':http, 'https:':https}\n    , httpModules = self.httpModules || {}\n\n  self.httpModule = httpModules[protocol] || defaultModules[protocol]\n\n  if (!self.httpModule) {\n    return self.emit('error', new Error('Invalid protocol: ' + protocol))\n  }\n\n  if (options.ca) {\n    self.ca = options.ca\n  }\n\n  if (!self.agent) {\n    if (options.agentOptions) {\n      self.agentOptions = options.agentOptions\n    }\n\n    if (options.agentClass) {\n      self.agentClass = options.agentClass\n    } else if (options.forever) {\n      var v = version()\n      // use ForeverAgent in node 0.10- only\n      if (v.major === 0 && v.minor <= 10) {\n        self.agentClass = protocol === 'http:' ? ForeverAgent : ForeverAgent.SSL\n      } else {\n        self.agentClass = self.httpModule.Agent\n        self.agentOptions = self.agentOptions || {}\n        self.agentOptions.keepAlive = true\n      }\n    } else {\n      self.agentClass = self.httpModule.Agent\n    }\n  }\n\n  if (self.pool === false) {\n    self.agent = false\n  } else {\n    self.agent = self.agent || self.getNewAgent()\n  }\n\n  self.on('pipe', function (src) {\n    if (self.ntick && self._started) {\n      self.emit('error', new Error('You cannot pipe to this stream after the outbound request has started.'))\n    }\n    self.src = src\n    if (isReadStream(src)) {\n      if (!self.hasHeader('content-type')) {\n        self.setHeader('content-type', mime.lookup(src.path))\n      }\n    } else {\n      if (src.headers) {\n        for (var i in src.headers) {\n          if (!self.hasHeader(i)) {\n            self.setHeader(i, src.headers[i])\n          }\n        }\n      }\n      if (self._json && !self.hasHeader('content-type')) {\n        self.setHeader('content-type', 'application/json')\n      }\n      if (src.method && !self.explicitMethod) {\n        self.method = src.method\n      }\n    }\n\n    // self.on('pipe', function () {\n    //   console.error('You have already piped to this stream. Pipeing twice is likely to break the request.')\n    // })\n  })\n\n  defer(function () {\n    if (self._aborted) {\n      return\n    }\n\n    var end = function () {\n      if (self._form) {\n        if (!self._auth.hasAuth) {\n          self._form.pipe(self)\n        }\n        else if (self._auth.hasAuth && self._auth.sentAuth) {\n          self._form.pipe(self)\n        }\n      }\n      if (self._multipart && self._multipart.chunked) {\n        self._multipart.body.pipe(self)\n      }\n      if (self.body) {\n        if (isstream(self.body)) {\n          self.body.pipe(self)\n        } else {\n          setContentLength()\n          if (Array.isArray(self.body)) {\n            self.body.forEach(function (part) {\n              self.write(part)\n            })\n          } else {\n            self.write(self.body)\n          }\n          self.end()\n        }\n      } else if (self.requestBodyStream) {\n        console.warn('options.requestBodyStream is deprecated, please pass the request object to stream.pipe.')\n        self.requestBodyStream.pipe(self)\n      } else if (!self.src) {\n        if (self._auth.hasAuth && !self._auth.sentAuth) {\n          self.end()\n          return\n        }\n        if (self.method !== 'GET' && typeof self.method !== 'undefined') {\n          self.setHeader('content-length', 0)\n        }\n        self.end()\n      }\n    }\n\n    if (self._form && !self.hasHeader('content-length')) {\n      // Before ending the request, we had to compute the length of the whole form, asyncly\n      self.setHeader(self._form.getHeaders(), true)\n      self._form.getLength(function (err, length) {\n        if (!err && !isNaN(length)) {\n          self.setHeader('content-length', length)\n        }\n        end()\n      })\n    } else {\n      end()\n    }\n\n    self.ntick = true\n  })\n\n}\n\nRequest.prototype.getNewAgent = function () {\n  var self = this\n  var Agent = self.agentClass\n  var options = {}\n  if (self.agentOptions) {\n    for (var i in self.agentOptions) {\n      options[i] = self.agentOptions[i]\n    }\n  }\n  if (self.ca) {\n    options.ca = self.ca\n  }\n  if (self.ciphers) {\n    options.ciphers = self.ciphers\n  }\n  if (self.secureProtocol) {\n    options.secureProtocol = self.secureProtocol\n  }\n  if (self.secureOptions) {\n    options.secureOptions = self.secureOptions\n  }\n  if (typeof self.rejectUnauthorized !== 'undefined') {\n    options.rejectUnauthorized = self.rejectUnauthorized\n  }\n\n  if (self.cert && self.key) {\n    options.key = self.key\n    options.cert = self.cert\n  }\n\n  if (self.pfx) {\n    options.pfx = self.pfx\n  }\n\n  if (self.passphrase) {\n    options.passphrase = self.passphrase\n  }\n\n  var poolKey = ''\n\n  // different types of agents are in different pools\n  if (Agent !== self.httpModule.Agent) {\n    poolKey += Agent.name\n  }\n\n  // ca option is only relevant if proxy or destination are https\n  var proxy = self.proxy\n  if (typeof proxy === 'string') {\n    proxy = url.parse(proxy)\n  }\n  var isHttps = (proxy && proxy.protocol === 'https:') || this.uri.protocol === 'https:'\n\n  if (isHttps) {\n    if (options.ca) {\n      if (poolKey) {\n        poolKey += ':'\n      }\n      poolKey += options.ca\n    }\n\n    if (typeof options.rejectUnauthorized !== 'undefined') {\n      if (poolKey) {\n        poolKey += ':'\n      }\n      poolKey += options.rejectUnauthorized\n    }\n\n    if (options.cert) {\n      if (poolKey) {\n        poolKey += ':'\n      }\n      poolKey += options.cert.toString('ascii') + options.key.toString('ascii')\n    }\n\n    if (options.pfx) {\n      if (poolKey) {\n        poolKey += ':'\n      }\n      poolKey += options.pfx.toString('ascii')\n    }\n\n    if (options.ciphers) {\n      if (poolKey) {\n        poolKey += ':'\n      }\n      poolKey += options.ciphers\n    }\n\n    if (options.secureProtocol) {\n      if (poolKey) {\n        poolKey += ':'\n      }\n      poolKey += options.secureProtocol\n    }\n\n    if (options.secureOptions) {\n      if (poolKey) {\n        poolKey += ':'\n      }\n      poolKey += options.secureOptions\n    }\n  }\n\n  if (self.pool === globalPool && !poolKey && Object.keys(options).length === 0 && self.httpModule.globalAgent) {\n    // not doing anything special.  Use the globalAgent\n    return self.httpModule.globalAgent\n  }\n\n  // we're using a stored agent.  Make sure it's protocol-specific\n  poolKey = self.uri.protocol + poolKey\n\n  // generate a new agent for this setting if none yet exists\n  if (!self.pool[poolKey]) {\n    self.pool[poolKey] = new Agent(options)\n    // properly set maxSockets on new agents\n    if (self.pool.maxSockets) {\n      self.pool[poolKey].maxSockets = self.pool.maxSockets\n    }\n  }\n\n  return self.pool[poolKey]\n}\n\nRequest.prototype.start = function () {\n  // start() is called once we are ready to send the outgoing HTTP request.\n  // this is usually called on the first write(), end() or on nextTick()\n  var self = this\n\n  if (self._aborted) {\n    return\n  }\n\n  self._started = true\n  self.method = self.method || 'GET'\n  self.href = self.uri.href\n\n  if (self.src && self.src.stat && self.src.stat.size && !self.hasHeader('content-length')) {\n    self.setHeader('content-length', self.src.stat.size)\n  }\n  if (self._aws) {\n    self.aws(self._aws, true)\n  }\n\n  // We have a method named auth, which is completely different from the http.request\n  // auth option.  If we don't remove it, we're gonna have a bad time.\n  var reqOptions = copy(self)\n  delete reqOptions.auth\n\n  debug('make request', self.uri.href)\n\n  try {\n    self.req = self.httpModule.request(reqOptions)\n  } catch (err) {\n    self.emit('error', err)\n    return\n  }\n\n  if (self.timing) {\n    self.startTime = new Date().getTime()\n  }\n\n  if (self.timeout && !self.timeoutTimer) {\n    var timeout = self.timeout < 0 ? 0 : self.timeout\n    // Set a timeout in memory - this block will throw if the server takes more\n    // than `timeout` to write the HTTP status and headers (corresponding to\n    // the on('response') event on the client). NB: this measures wall-clock\n    // time, not the time between bytes sent by the server.\n    self.timeoutTimer = setTimeout(function () {\n      var connectTimeout = self.req.socket && self.req.socket.readable === false\n      self.abort()\n      var e = new Error('ETIMEDOUT')\n      e.code = 'ETIMEDOUT'\n      e.connect = connectTimeout\n      self.emit('error', e)\n    }, timeout)\n\n    if (self.req.setTimeout) { // only works on node 0.6+\n      // Set an additional timeout on the socket, via the `setsockopt` syscall.\n      // This timeout sets the amount of time to wait *between* bytes sent\n      // from the server, and may or may not correspond to the wall-clock time\n      // elapsed from the start of the request.\n      //\n      // In particular, it's useful for erroring if the server fails to send\n      // data halfway through streaming a response.\n      self.req.setTimeout(timeout, function () {\n        if (self.req) {\n          self.req.abort()\n          var e = new Error('ESOCKETTIMEDOUT')\n          e.code = 'ESOCKETTIMEDOUT'\n          e.connect = false\n          self.emit('error', e)\n        }\n      })\n    }\n  }\n\n  self.req.on('response', self.onRequestResponse.bind(self))\n  self.req.on('error', self.onRequestError.bind(self))\n  self.req.on('drain', function() {\n    self.emit('drain')\n  })\n  self.req.on('socket', function(socket) {\n    self.emit('socket', socket)\n  })\n\n  self.emit('request', self.req)\n}\n\nRequest.prototype.onRequestError = function (error) {\n  var self = this\n  if (self._aborted) {\n    return\n  }\n  if (self.req && self.req._reusedSocket && error.code === 'ECONNRESET'\n      && self.agent.addRequestNoreuse) {\n    self.agent = { addRequest: self.agent.addRequestNoreuse.bind(self.agent) }\n    self.start()\n    self.req.end()\n    return\n  }\n  if (self.timeout && self.timeoutTimer) {\n    clearTimeout(self.timeoutTimer)\n    self.timeoutTimer = null\n  }\n  self.emit('error', error)\n}\n\nRequest.prototype.onRequestResponse = function (response) {\n  var self = this\n  debug('onRequestResponse', self.uri.href, response.statusCode, response.headers)\n  response.on('end', function() {\n    if (self.timing) {\n      self.elapsedTime += (new Date().getTime() - self.startTime)\n      debug('elapsed time', self.elapsedTime)\n      response.elapsedTime = self.elapsedTime\n    }\n    debug('response end', self.uri.href, response.statusCode, response.headers)\n  })\n\n  if (self._aborted) {\n    debug('aborted', self.uri.href)\n    response.resume()\n    return\n  }\n\n  self.response = response\n  response.request = self\n  response.toJSON = responseToJSON\n\n  // XXX This is different on 0.10, because SSL is strict by default\n  if (self.httpModule === https &&\n      self.strictSSL && (!response.hasOwnProperty('socket') ||\n      !response.socket.authorized)) {\n    debug('strict ssl error', self.uri.href)\n    var sslErr = response.hasOwnProperty('socket') ? response.socket.authorizationError : self.uri.href + ' does not support SSL'\n    self.emit('error', new Error('SSL Error: ' + sslErr))\n    return\n  }\n\n  // Save the original host before any redirect (if it changes, we need to\n  // remove any authorization headers).  Also remember the case of the header\n  // name because lots of broken servers expect Host instead of host and we\n  // want the caller to be able to specify this.\n  self.originalHost = self.getHeader('host')\n  if (!self.originalHostHeaderName) {\n    self.originalHostHeaderName = self.hasHeader('host')\n  }\n  if (self.setHost) {\n    self.removeHeader('host')\n  }\n  if (self.timeout && self.timeoutTimer) {\n    clearTimeout(self.timeoutTimer)\n    self.timeoutTimer = null\n  }\n\n  var targetCookieJar = (self._jar && self._jar.setCookie) ? self._jar : globalCookieJar\n  var addCookie = function (cookie) {\n    //set the cookie if it's domain in the href's domain.\n    try {\n      targetCookieJar.setCookie(cookie, self.uri.href, {ignoreError: true})\n    } catch (e) {\n      self.emit('error', e)\n    }\n  }\n\n  response.caseless = caseless(response.headers)\n\n  if (response.caseless.has('set-cookie') && (!self._disableCookies)) {\n    var headerName = response.caseless.has('set-cookie')\n    if (Array.isArray(response.headers[headerName])) {\n      response.headers[headerName].forEach(addCookie)\n    } else {\n      addCookie(response.headers[headerName])\n    }\n  }\n\n  if (self._redirect.onResponse(response)) {\n    return // Ignore the rest of the response\n  } else {\n    // Be a good stream and emit end when the response is finished.\n    // Hack to emit end on close because of a core bug that never fires end\n    response.on('close', function () {\n      if (!self._ended) {\n        self.response.emit('end')\n      }\n    })\n\n    response.on('end', function () {\n      self._ended = true\n    })\n\n    var noBody = function (code) {\n      return (\n        self.method === 'HEAD'\n        // Informational\n        || (code >= 100 && code < 200)\n        // No Content\n        || code === 204\n        // Not Modified\n        || code === 304\n      )\n    }\n\n    var responseContent\n    if (self.gzip && !noBody(response.statusCode)) {\n      var contentEncoding = response.headers['content-encoding'] || 'identity'\n      contentEncoding = contentEncoding.trim().toLowerCase()\n\n      if (contentEncoding === 'gzip') {\n        responseContent = zlib.createGunzip()\n        response.pipe(responseContent)\n      } else if (contentEncoding === 'deflate') {\n        responseContent = zlib.createInflate()\n        response.pipe(responseContent)\n      } else {\n        // Since previous versions didn't check for Content-Encoding header,\n        // ignore any invalid values to preserve backwards-compatibility\n        if (contentEncoding !== 'identity') {\n          debug('ignoring unrecognized Content-Encoding ' + contentEncoding)\n        }\n        responseContent = response\n      }\n    } else {\n      responseContent = response\n    }\n\n    if (self.encoding) {\n      if (self.dests.length !== 0) {\n        console.error('Ignoring encoding parameter as this stream is being piped to another stream which makes the encoding option invalid.')\n      } else if (responseContent.setEncoding) {\n        responseContent.setEncoding(self.encoding)\n      } else {\n        // Should only occur on node pre-v0.9.4 (joyent/node@9b5abe5) with\n        // zlib streams.\n        // If/When support for 0.9.4 is dropped, this should be unnecessary.\n        responseContent = responseContent.pipe(stringstream(self.encoding))\n      }\n    }\n\n    if (self._paused) {\n      responseContent.pause()\n    }\n\n    self.responseContent = responseContent\n\n    self.emit('response', response)\n\n    self.dests.forEach(function (dest) {\n      self.pipeDest(dest)\n    })\n\n    responseContent.on('data', function (chunk) {\n      self._destdata = true\n      self.emit('data', chunk)\n    })\n    responseContent.on('end', function (chunk) {\n      self.emit('end', chunk)\n    })\n    responseContent.on('error', function (error) {\n      self.emit('error', error)\n    })\n    responseContent.on('close', function () {self.emit('close')})\n\n    if (self.callback) {\n      self.readResponseBody(response)\n    }\n    //if no callback\n    else {\n      self.on('end', function () {\n        if (self._aborted) {\n          debug('aborted', self.uri.href)\n          return\n        }\n        self.emit('complete', response)\n      })\n    }\n  }\n  debug('finish init function', self.uri.href)\n}\n\nRequest.prototype.readResponseBody = function (response) {\n  var self = this\n  debug('reading response\\'s body')\n  var buffer = bl()\n    , strings = []\n\n  self.on('data', function (chunk) {\n    if (Buffer.isBuffer(chunk)) {\n      buffer.append(chunk)\n    } else {\n      strings.push(chunk)\n    }\n  })\n  self.on('end', function () {\n    debug('end event', self.uri.href)\n    if (self._aborted) {\n      debug('aborted', self.uri.href)\n      // `buffer` is defined in the parent scope and used in a closure it exists for the life of the request.\n      // This can lead to leaky behavior if the user retains a reference to the request object.\n      buffer.destroy()\n      return\n    }\n\n    if (buffer.length) {\n      debug('has body', self.uri.href, buffer.length)\n      if (self.encoding === null) {\n        // response.body = buffer\n        // can't move to this until https://github.com/rvagg/bl/issues/13\n        response.body = buffer.slice()\n      } else {\n        response.body = buffer.toString(self.encoding)\n      }\n      // `buffer` is defined in the parent scope and used in a closure it exists for the life of the Request.\n      // This can lead to leaky behavior if the user retains a reference to the request object.\n      buffer.destroy()\n    } else if (strings.length) {\n      // The UTF8 BOM [0xEF,0xBB,0xBF] is converted to [0xFE,0xFF] in the JS UTC16/UCS2 representation.\n      // Strip this value out when the encoding is set to 'utf8', as upstream consumers won't expect it and it breaks JSON.parse().\n      if (self.encoding === 'utf8' && strings[0].length > 0 && strings[0][0] === '\\uFEFF') {\n        strings[0] = strings[0].substring(1)\n      }\n      response.body = strings.join('')\n    }\n\n    if (self._json) {\n      try {\n        response.body = JSON.parse(response.body, self._jsonReviver)\n      } catch (e) {\n        debug('invalid JSON received', self.uri.href)\n      }\n    }\n    debug('emitting complete', self.uri.href)\n    if (typeof response.body === 'undefined' && !self._json) {\n      response.body = self.encoding === null ? new Buffer(0) : ''\n    }\n    self.emit('complete', response, response.body)\n  })\n}\n\nRequest.prototype.abort = function () {\n  var self = this\n  self._aborted = true\n\n  if (self.req) {\n    self.req.abort()\n  }\n  else if (self.response) {\n    self.response.destroy()\n  }\n\n  self.emit('abort')\n}\n\nRequest.prototype.pipeDest = function (dest) {\n  var self = this\n  var response = self.response\n  // Called after the response is received\n  if (dest.headers && !dest.headersSent) {\n    if (response.caseless.has('content-type')) {\n      var ctname = response.caseless.has('content-type')\n      if (dest.setHeader) {\n        dest.setHeader(ctname, response.headers[ctname])\n      }\n      else {\n        dest.headers[ctname] = response.headers[ctname]\n      }\n    }\n\n    if (response.caseless.has('content-length')) {\n      var clname = response.caseless.has('content-length')\n      if (dest.setHeader) {\n        dest.setHeader(clname, response.headers[clname])\n      } else {\n        dest.headers[clname] = response.headers[clname]\n      }\n    }\n  }\n  if (dest.setHeader && !dest.headersSent) {\n    for (var i in response.headers) {\n      // If the response content is being decoded, the Content-Encoding header\n      // of the response doesn't represent the piped content, so don't pass it.\n      if (!self.gzip || i !== 'content-encoding') {\n        dest.setHeader(i, response.headers[i])\n      }\n    }\n    dest.statusCode = response.statusCode\n  }\n  if (self.pipefilter) {\n    self.pipefilter(response, dest)\n  }\n}\n\nRequest.prototype.qs = function (q, clobber) {\n  var self = this\n  var base\n  if (!clobber && self.uri.query) {\n    base = self._qs.parse(self.uri.query)\n  } else {\n    base = {}\n  }\n\n  for (var i in q) {\n    base[i] = q[i]\n  }\n\n  var qs = self._qs.stringify(base)\n\n  if (qs === '') {\n    return self\n  }\n\n  self.uri = url.parse(self.uri.href.split('?')[0] + '?' + qs)\n  self.url = self.uri\n  self.path = self.uri.path\n\n  if (self.uri.host === 'unix') {\n    self.enableUnixSocket()\n  }\n\n  return self\n}\nRequest.prototype.form = function (form) {\n  var self = this\n  if (form) {\n    if (!/^application\\/x-www-form-urlencoded\\b/.test(self.getHeader('content-type'))) {\n      self.setHeader('content-type', 'application/x-www-form-urlencoded')\n    }\n    self.body = (typeof form === 'string')\n      ? self._qs.rfc3986(form.toString('utf8'))\n      : self._qs.stringify(form).toString('utf8')\n    return self\n  }\n  // create form-data object\n  self._form = new FormData()\n  self._form.on('error', function(err) {\n    err.message = 'form-data: ' + err.message\n    self.emit('error', err)\n    self.abort()\n  })\n  return self._form\n}\nRequest.prototype.multipart = function (multipart) {\n  var self = this\n\n  self._multipart.onRequest(multipart)\n\n  if (!self._multipart.chunked) {\n    self.body = self._multipart.body\n  }\n\n  return self\n}\nRequest.prototype.json = function (val) {\n  var self = this\n\n  if (!self.hasHeader('accept')) {\n    self.setHeader('accept', 'application/json')\n  }\n\n  if (typeof self.jsonReplacer === 'function') {\n    self._jsonReplacer = self.jsonReplacer\n  }\n\n  self._json = true\n  if (typeof val === 'boolean') {\n    if (self.body !== undefined) {\n      if (!/^application\\/x-www-form-urlencoded\\b/.test(self.getHeader('content-type'))) {\n        self.body = safeStringify(self.body, self._jsonReplacer)\n      } else {\n        self.body = self._qs.rfc3986(self.body)\n      }\n      if (!self.hasHeader('content-type')) {\n        self.setHeader('content-type', 'application/json')\n      }\n    }\n  } else {\n    self.body = safeStringify(val, self._jsonReplacer)\n    if (!self.hasHeader('content-type')) {\n      self.setHeader('content-type', 'application/json')\n    }\n  }\n\n  if (typeof self.jsonReviver === 'function') {\n    self._jsonReviver = self.jsonReviver\n  }\n\n  return self\n}\nRequest.prototype.getHeader = function (name, headers) {\n  var self = this\n  var result, re, match\n  if (!headers) {\n    headers = self.headers\n  }\n  Object.keys(headers).forEach(function (key) {\n    if (key.length !== name.length) {\n      return\n    }\n    re = new RegExp(name, 'i')\n    match = key.match(re)\n    if (match) {\n      result = headers[key]\n    }\n  })\n  return result\n}\nRequest.prototype.enableUnixSocket = function () {\n  // Get the socket & request paths from the URL\n  var unixParts = this.uri.path.split(':')\n    , host = unixParts[0]\n    , path = unixParts[1]\n  // Apply unix properties to request\n  this.socketPath = host\n  this.uri.pathname = path\n  this.uri.path = path\n  this.uri.host = host\n  this.uri.hostname = host\n  this.uri.isUnix = true\n}\n\n\nRequest.prototype.auth = function (user, pass, sendImmediately, bearer) {\n  var self = this\n\n  self._auth.onRequest(user, pass, sendImmediately, bearer)\n\n  return self\n}\nRequest.prototype.aws = function (opts, now) {\n  var self = this\n\n  if (!now) {\n    self._aws = opts\n    return self\n  }\n\n  if (opts.sign_version == 4 || opts.sign_version == '4') {\n    // use aws4\n    var options = {\n      host: self.uri.host,\n      path: self.uri.path,\n      method: self.method,\n      headers: {\n        'content-type': self.getHeader('content-type') || ''\n      },\n      body: self.body\n    }\n    var signRes = aws4.sign(options, {\n      accessKeyId: opts.key,\n      secretAccessKey: opts.secret\n    })\n    self.setHeader('authorization', signRes.headers.Authorization)\n    self.setHeader('x-amz-date', signRes.headers['X-Amz-Date'])\n  }\n  else {\n    // default: use aws-sign2\n    var date = new Date()\n    self.setHeader('date', date.toUTCString())\n    var auth =\n      { key: opts.key\n      , secret: opts.secret\n      , verb: self.method.toUpperCase()\n      , date: date\n      , contentType: self.getHeader('content-type') || ''\n      , md5: self.getHeader('content-md5') || ''\n      , amazonHeaders: aws2.canonicalizeHeaders(self.headers)\n      }\n    var path = self.uri.path\n    if (opts.bucket && path) {\n      auth.resource = '/' + opts.bucket + path\n    } else if (opts.bucket && !path) {\n      auth.resource = '/' + opts.bucket\n    } else if (!opts.bucket && path) {\n      auth.resource = path\n    } else if (!opts.bucket && !path) {\n      auth.resource = '/'\n    }\n    auth.resource = aws2.canonicalizeResource(auth.resource)\n    self.setHeader('authorization', aws2.authorization(auth))\n  }\n\n  return self\n}\nRequest.prototype.httpSignature = function (opts) {\n  var self = this\n  httpSignature.signRequest({\n    getHeader: function(header) {\n      return self.getHeader(header, self.headers)\n    },\n    setHeader: function(header, value) {\n      self.setHeader(header, value)\n    },\n    method: self.method,\n    path: self.path\n  }, opts)\n  debug('httpSignature authorization', self.getHeader('authorization'))\n\n  return self\n}\nRequest.prototype.hawk = function (opts) {\n  var self = this\n  self.setHeader('Authorization', hawk.client.header(self.uri, self.method, opts).field)\n}\nRequest.prototype.oauth = function (_oauth) {\n  var self = this\n\n  self._oauth.onRequest(_oauth)\n\n  return self\n}\n\nRequest.prototype.jar = function (jar) {\n  var self = this\n  var cookies\n\n  if (self._redirect.redirectsFollowed === 0) {\n    self.originalCookieHeader = self.getHeader('cookie')\n  }\n\n  if (!jar) {\n    // disable cookies\n    cookies = false\n    self._disableCookies = true\n  } else {\n    var targetCookieJar = (jar && jar.getCookieString) ? jar : globalCookieJar\n    var urihref = self.uri.href\n    //fetch cookie in the Specified host\n    if (targetCookieJar) {\n      cookies = targetCookieJar.getCookieString(urihref)\n    }\n  }\n\n  //if need cookie and cookie is not empty\n  if (cookies && cookies.length) {\n    if (self.originalCookieHeader) {\n      // Don't overwrite existing Cookie header\n      self.setHeader('cookie', self.originalCookieHeader + '; ' + cookies)\n    } else {\n      self.setHeader('cookie', cookies)\n    }\n  }\n  self._jar = jar\n  return self\n}\n\n\n// Stream API\nRequest.prototype.pipe = function (dest, opts) {\n  var self = this\n\n  if (self.response) {\n    if (self._destdata) {\n      self.emit('error', new Error('You cannot pipe after data has been emitted from the response.'))\n    } else if (self._ended) {\n      self.emit('error', new Error('You cannot pipe after the response has been ended.'))\n    } else {\n      stream.Stream.prototype.pipe.call(self, dest, opts)\n      self.pipeDest(dest)\n      return dest\n    }\n  } else {\n    self.dests.push(dest)\n    stream.Stream.prototype.pipe.call(self, dest, opts)\n    return dest\n  }\n}\nRequest.prototype.write = function () {\n  var self = this\n  if (self._aborted) {return}\n\n  if (!self._started) {\n    self.start()\n  }\n  if (self.req) {\n    return self.req.write.apply(self.req, arguments)\n  }\n}\nRequest.prototype.end = function (chunk) {\n  var self = this\n  if (self._aborted) {return}\n\n  if (chunk) {\n    self.write(chunk)\n  }\n  if (!self._started) {\n    self.start()\n  }\n  if (self.req) {\n    self.req.end()\n  }\n}\nRequest.prototype.pause = function () {\n  var self = this\n  if (!self.responseContent) {\n    self._paused = true\n  } else {\n    self.responseContent.pause.apply(self.responseContent, arguments)\n  }\n}\nRequest.prototype.resume = function () {\n  var self = this\n  if (!self.responseContent) {\n    self._paused = false\n  } else {\n    self.responseContent.resume.apply(self.responseContent, arguments)\n  }\n}\nRequest.prototype.destroy = function () {\n  var self = this\n  if (!self._ended) {\n    self.end()\n  } else if (self.response) {\n    self.response.destroy()\n  }\n}\n\nRequest.defaultProxyHeaderWhiteList =\n  Tunnel.defaultProxyHeaderWhiteList.slice()\n\nRequest.defaultProxyHeaderExclusiveList =\n  Tunnel.defaultProxyHeaderExclusiveList.slice()\n\n// Exports\n\nRequest.prototype.toJSON = requestToJSON\nmodule.exports = Request\n","/home/travis/build/npmtest/node-npmtest-auto-install/auto-install/node_modules/caseless/index.js":"function Caseless (dict) {\n  this.dict = dict || {}\n}\nCaseless.prototype.set = function (name, value, clobber) {\n  if (typeof name === 'object') {\n    for (var i in name) {\n      this.set(i, name[i], value)\n    }\n  } else {\n    if (typeof clobber === 'undefined') clobber = true\n    var has = this.has(name)\n\n    if (!clobber && has) this.dict[has] = this.dict[has] + ',' + value\n    else this.dict[has || name] = value\n    return has\n  }\n}\nCaseless.prototype.has = function (name) {\n  var keys = Object.keys(this.dict)\n    , name = name.toLowerCase()\n    ;\n  for (var i=0;i<keys.length;i++) {\n    if (keys[i].toLowerCase() === name) return keys[i]\n  }\n  return false\n}\nCaseless.prototype.get = function (name) {\n  name = name.toLowerCase()\n  var result, _key\n  var headers = this.dict\n  Object.keys(headers).forEach(function (key) {\n    _key = key.toLowerCase()\n    if (name === _key) result = headers[key]\n  })\n  return result\n}\nCaseless.prototype.swap = function (name) {\n  var has = this.has(name)\n  if (!has) throw new Error('There is no header than matches \"'+name+'\"')\n  this.dict[name] = this.dict[has]\n  delete this.dict[has]\n}\nCaseless.prototype.del = function (name) {\n  var has = this.has(name)\n  return delete this.dict[has || name]\n}\n\nmodule.exports = function (dict) {return new Caseless(dict)}\nmodule.exports.httpify = function (resp, headers) {\n  var c = new Caseless(headers)\n  resp.setHeader = function (key, value, clobber) {\n    if (typeof value === 'undefined') return\n    return c.set(key, value, clobber)\n  }\n  resp.hasHeader = function (key) {\n    return c.has(key)\n  }\n  resp.getHeader = function (key) {\n    return c.get(key)\n  }\n  resp.removeHeader = function (key) {\n    return c.del(key)\n  }\n  resp.headers = c.dict\n  return c\n}\n","/home/travis/build/npmtest/node-npmtest-auto-install/auto-install/node_modules/form-data/lib/form_data.js":"var CombinedStream = require('combined-stream');\nvar util = require('util');\nvar path = require('path');\nvar http = require('http');\nvar https = require('https');\nvar parseUrl = require('url').parse;\nvar fs = require('fs');\nvar mime = require('mime-types');\nvar async = require('async');\nvar populate = require('./populate.js');\n\n// Public API\nmodule.exports = FormData;\n\n// make it a Stream\nutil.inherits(FormData, CombinedStream);\n\n/**\n * Create readable \"multipart/form-data\" streams.\n * Can be used to submit forms\n * and file uploads to other web applications.\n *\n * @constructor\n */\nfunction FormData() {\n  if (!(this instanceof FormData)) {\n    throw new TypeError('Failed to construct FormData: Please use the _new_ operator, this object constructor cannot be called as a function.');\n  }\n\n  this._overheadLength = 0;\n  this._valueLength = 0;\n  this._lengthRetrievers = [];\n\n  CombinedStream.call(this);\n}\n\nFormData.LINE_BREAK = '\\r\\n';\nFormData.DEFAULT_CONTENT_TYPE = 'application/octet-stream';\n\nFormData.prototype.append = function(field, value, options) {\n\n  options = options || {};\n\n  // allow filename as single option\n  if (typeof options == 'string') {\n    options = {filename: options};\n  }\n\n  var append = CombinedStream.prototype.append.bind(this);\n\n  // all that streamy business can't handle numbers\n  if (typeof value == 'number') {\n    value = '' + value;\n  }\n\n  // https://github.com/felixge/node-form-data/issues/38\n  if (util.isArray(value)) {\n    // Please convert your array into string\n    // the way web server expects it\n    this._error(new Error('Arrays are not supported.'));\n    return;\n  }\n\n  var header = this._multiPartHeader(field, value, options);\n  var footer = this._multiPartFooter();\n\n  append(header);\n  append(value);\n  append(footer);\n\n  // pass along options.knownLength\n  this._trackLength(header, value, options);\n};\n\nFormData.prototype._trackLength = function(header, value, options) {\n  var valueLength = 0;\n\n  // used w/ getLengthSync(), when length is known.\n  // e.g. for streaming directly from a remote server,\n  // w/ a known file a size, and not wanting to wait for\n  // incoming file to finish to get its size.\n  if (options.knownLength != null) {\n    valueLength += +options.knownLength;\n  } else if (Buffer.isBuffer(value)) {\n    valueLength = value.length;\n  } else if (typeof value === 'string') {\n    valueLength = Buffer.byteLength(value);\n  }\n\n  this._valueLength += valueLength;\n\n  // @check why add CRLF? does this account for custom/multiple CRLFs?\n  this._overheadLength +=\n    Buffer.byteLength(header) +\n    FormData.LINE_BREAK.length;\n\n  // empty or either doesn't have path or not an http response\n  if (!value || ( !value.path && !(value.readable && value.hasOwnProperty('httpVersion')) )) {\n    return;\n  }\n\n  // no need to bother with the length\n  if (!options.knownLength) {\n    this._lengthRetrievers.push(function(next) {\n\n      if (value.hasOwnProperty('fd')) {\n\n        // take read range into a account\n        // `end` = Infinity > read file till the end\n        //\n        // TODO: Looks like there is bug in Node fs.createReadStream\n        // it doesn't respect `end` options without `start` options\n        // Fix it when node fixes it.\n        // https://github.com/joyent/node/issues/7819\n        if (value.end != undefined && value.end != Infinity && value.start != undefined) {\n\n          // when end specified\n          // no need to calculate range\n          // inclusive, starts with 0\n          next(null, value.end + 1 - (value.start ? value.start : 0));\n\n        // not that fast snoopy\n        } else {\n          // still need to fetch file size from fs\n          fs.stat(value.path, function(err, stat) {\n\n            var fileSize;\n\n            if (err) {\n              next(err);\n              return;\n            }\n\n            // update final size based on the range options\n            fileSize = stat.size - (value.start ? value.start : 0);\n            next(null, fileSize);\n          });\n        }\n\n      // or http response\n      } else if (value.hasOwnProperty('httpVersion')) {\n        next(null, +value.headers['content-length']);\n\n      // or request stream http://github.com/mikeal/request\n      } else if (value.hasOwnProperty('httpModule')) {\n        // wait till response come back\n        value.on('response', function(response) {\n          value.pause();\n          next(null, +response.headers['content-length']);\n        });\n        value.resume();\n\n      // something else\n      } else {\n        next('Unknown stream');\n      }\n    });\n  }\n};\n\nFormData.prototype._multiPartHeader = function(field, value, options) {\n  // custom header specified (as string)?\n  // it becomes responsible for boundary\n  // (e.g. to handle extra CRLFs on .NET servers)\n  if (typeof options.header == 'string') {\n    return options.header;\n  }\n\n  var contentDisposition = this._getContentDisposition(value, options);\n  var contentType = this._getContentType(value, options);\n\n  var contents = '';\n  var headers  = {\n    // add custom disposition as third element or keep it two elements if not\n    'Content-Disposition': ['form-data', 'name=\"' + field + '\"'].concat(contentDisposition || []),\n    // if no content type. allow it to be empty array\n    'Content-Type': [].concat(contentType || [])\n  };\n\n  // allow custom headers.\n  if (typeof options.header == 'object') {\n    populate(headers, options.header);\n  }\n\n  var header;\n  for (var prop in headers) {\n    header = headers[prop];\n\n    // skip nullish headers.\n    if (header == null) {\n      continue;\n    }\n\n    // convert all headers to arrays.\n    if (!Array.isArray(header)) {\n      header = [header];\n    }\n\n    // add non-empty headers.\n    if (header.length) {\n      contents += prop + ': ' + header.join('; ') + FormData.LINE_BREAK;\n    }\n  }\n\n  return '--' + this.getBoundary() + FormData.LINE_BREAK + contents + FormData.LINE_BREAK;\n};\n\nFormData.prototype._getContentDisposition = function(value, options) {\n\n  var contentDisposition;\n\n  // custom filename takes precedence\n  // fs- and request- streams have path property\n  // formidable and the browser add a name property.\n  var filename = options.filename || value.name || value.path;\n\n  // or try http response\n  if (!filename && value.readable && value.hasOwnProperty('httpVersion')) {\n    filename = value.client._httpMessage.path;\n  }\n\n  if (filename) {\n    contentDisposition = 'filename=\"' + path.basename(filename) + '\"';\n  }\n\n  return contentDisposition;\n};\n\nFormData.prototype._getContentType = function(value, options) {\n\n  // use custom content-type above all\n  var contentType = options.contentType;\n\n  // or try `name` from formidable, browser\n  if (!contentType && value.name) {\n    contentType = mime.lookup(value.name);\n  }\n\n  // or try `path` from fs-, request- streams\n  if (!contentType && value.path) {\n    contentType = mime.lookup(value.path);\n  }\n\n  // or if it's http-reponse\n  if (!contentType && value.readable && value.hasOwnProperty('httpVersion')) {\n    contentType = value.headers['content-type'];\n  }\n\n  // or guess it from the filename\n  if (!contentType && options.filename) {\n    contentType = mime.lookup(options.filename);\n  }\n\n  // fallback to the default content type if `value` is not simple value\n  if (!contentType && typeof value == 'object') {\n    contentType = FormData.DEFAULT_CONTENT_TYPE;\n  }\n\n  return contentType;\n};\n\nFormData.prototype._multiPartFooter = function() {\n  return function(next) {\n    var footer = FormData.LINE_BREAK;\n\n    var lastPart = (this._streams.length === 0);\n    if (lastPart) {\n      footer += this._lastBoundary();\n    }\n\n    next(footer);\n  }.bind(this);\n};\n\nFormData.prototype._lastBoundary = function() {\n  return '--' + this.getBoundary() + '--' + FormData.LINE_BREAK;\n};\n\nFormData.prototype.getHeaders = function(userHeaders) {\n  var header;\n  var formHeaders = {\n    'content-type': 'multipart/form-data; boundary=' + this.getBoundary()\n  };\n\n  for (header in userHeaders) {\n    if (userHeaders.hasOwnProperty(header)) {\n      formHeaders[header.toLowerCase()] = userHeaders[header];\n    }\n  }\n\n  return formHeaders;\n};\n\n// TODO: Looks like unused function\nFormData.prototype.getCustomHeaders = function(contentType) {\n  contentType = contentType ? contentType : 'multipart/form-data';\n\n  var formHeaders = {\n    'content-type': contentType + '; boundary=' + this.getBoundary(),\n    'content-length': this.getLengthSync()\n  };\n\n  return formHeaders;\n};\n\nFormData.prototype.getBoundary = function() {\n  if (!this._boundary) {\n    this._generateBoundary();\n  }\n\n  return this._boundary;\n};\n\nFormData.prototype._generateBoundary = function() {\n  // This generates a 50 character boundary similar to those used by Firefox.\n  // They are optimized for boyer-moore parsing.\n  var boundary = '--------------------------';\n  for (var i = 0; i < 24; i++) {\n    boundary += Math.floor(Math.random() * 10).toString(16);\n  }\n\n  this._boundary = boundary;\n};\n\n// Note: getLengthSync DOESN'T calculate streams length\n// As workaround one can calculate file size manually\n// and add it as knownLength option\nFormData.prototype.getLengthSync = function() {\n  var knownLength = this._overheadLength + this._valueLength;\n\n  // Don't get confused, there are 3 \"internal\" streams for each keyval pair\n  // so it basically checks if there is any value added to the form\n  if (this._streams.length) {\n    knownLength += this._lastBoundary().length;\n  }\n\n  // https://github.com/form-data/form-data/issues/40\n  if (this._lengthRetrievers.length) {\n    // Some async length retrievers are present\n    // therefore synchronous length calculation is false.\n    // Please use getLength(callback) to get proper length\n    this._error(new Error('Cannot calculate proper length in synchronous way.'));\n  }\n\n  return knownLength;\n};\n\nFormData.prototype.getLength = function(cb) {\n  var knownLength = this._overheadLength + this._valueLength;\n\n  if (this._streams.length) {\n    knownLength += this._lastBoundary().length;\n  }\n\n  if (!this._lengthRetrievers.length) {\n    process.nextTick(cb.bind(this, null, knownLength));\n    return;\n  }\n\n  async.parallel(this._lengthRetrievers, function(err, values) {\n    if (err) {\n      cb(err);\n      return;\n    }\n\n    values.forEach(function(length) {\n      knownLength += length;\n    });\n\n    cb(null, knownLength);\n  });\n};\n\nFormData.prototype.submit = function(params, cb) {\n  var request\n    , options\n    , defaults = {method: 'post'}\n    ;\n\n  // parse provided url if it's string\n  // or treat it as options object\n  if (typeof params == 'string') {\n\n    params = parseUrl(params);\n    options = populate({\n      port: params.port,\n      path: params.pathname,\n      host: params.hostname\n    }, defaults);\n\n  // use custom params\n  } else {\n\n    options = populate(params, defaults);\n    // if no port provided use default one\n    if (!options.port) {\n      options.port = options.protocol == 'https:' ? 443 : 80;\n    }\n  }\n\n  // put that good code in getHeaders to some use\n  options.headers = this.getHeaders(params.headers);\n\n  // https if specified, fallback to http in any other case\n  if (options.protocol == 'https:') {\n    request = https.request(options);\n  } else {\n    request = http.request(options);\n  }\n\n  // get content length and fire away\n  this.getLength(function(err, length) {\n    if (err) {\n      this._error(err);\n      return;\n    }\n\n    // add content length\n    request.setHeader('Content-Length', length);\n\n    this.pipe(request);\n    if (cb) {\n      request.on('error', cb);\n      request.on('response', cb.bind(this, null));\n    }\n  }.bind(this));\n\n  return request;\n};\n\nFormData.prototype._error = function(err) {\n  if (!this.error) {\n    this.error = err;\n    this.pause();\n    this.emit('error', err);\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-auto-install/auto-install/node_modules/form-data/lib/populate.js":"// populates missing values\nmodule.exports = function(dst, src) {\n\n  Object.keys(src).forEach(function(prop)\n  {\n    dst[prop] = dst[prop] || src[prop];\n  });\n\n  return dst;\n};\n","/home/travis/build/npmtest/node-npmtest-auto-install/auto-install/node_modules/request/lib/getProxyFromURI.js":"'use strict'\n\nfunction formatHostname(hostname) {\n  // canonicalize the hostname, so that 'oogle.com' won't match 'google.com'\n  return hostname.replace(/^\\.*/, '.').toLowerCase()\n}\n\nfunction parseNoProxyZone(zone) {\n  zone = zone.trim().toLowerCase()\n\n  var zoneParts = zone.split(':', 2)\n    , zoneHost = formatHostname(zoneParts[0])\n    , zonePort = zoneParts[1]\n    , hasPort = zone.indexOf(':') > -1\n\n  return {hostname: zoneHost, port: zonePort, hasPort: hasPort}\n}\n\nfunction uriInNoProxy(uri, noProxy) {\n  var port = uri.port || (uri.protocol === 'https:' ? '443' : '80')\n    , hostname = formatHostname(uri.hostname)\n    , noProxyList = noProxy.split(',')\n\n  // iterate through the noProxyList until it finds a match.\n  return noProxyList.map(parseNoProxyZone).some(function(noProxyZone) {\n    var isMatchedAt = hostname.indexOf(noProxyZone.hostname)\n      , hostnameMatched = (\n          isMatchedAt > -1 &&\n          (isMatchedAt === hostname.length - noProxyZone.hostname.length)\n        )\n\n    if (noProxyZone.hasPort) {\n      return (port === noProxyZone.port) && hostnameMatched\n    }\n\n    return hostnameMatched\n  })\n}\n\nfunction getProxyFromURI(uri) {\n  // Decide the proper request proxy to use based on the request URI object and the\n  // environmental variables (NO_PROXY, HTTP_PROXY, etc.)\n  // respect NO_PROXY environment variables (see: http://lynx.isc.org/current/breakout/lynx_help/keystrokes/environments.html)\n\n  var noProxy = process.env.NO_PROXY || process.env.no_proxy || ''\n\n  // if the noProxy is a wildcard then return null\n\n  if (noProxy === '*') {\n    return null\n  }\n\n  // if the noProxy is not empty and the uri is found return null\n\n  if (noProxy !== '' && uriInNoProxy(uri, noProxy)) {\n    return null\n  }\n\n  // Check for HTTP or HTTPS Proxy in environment Else default to null\n\n  if (uri.protocol === 'http:') {\n    return process.env.HTTP_PROXY ||\n           process.env.http_proxy || null\n  }\n\n  if (uri.protocol === 'https:') {\n    return process.env.HTTPS_PROXY ||\n           process.env.https_proxy ||\n           process.env.HTTP_PROXY  ||\n           process.env.http_proxy  || null\n  }\n\n  // if none of that works, return null\n  // (What uri protocol are you using then?)\n\n  return null\n}\n\nmodule.exports = getProxyFromURI\n","/home/travis/build/npmtest/node-npmtest-auto-install/auto-install/node_modules/request/lib/querystring.js":"'use strict'\n\nvar qs = require('qs')\n  , querystring = require('querystring')\n\n\nfunction Querystring (request) {\n  this.request = request\n  this.lib = null\n  this.useQuerystring = null\n  this.parseOptions = null\n  this.stringifyOptions = null\n}\n\nQuerystring.prototype.init = function (options) {\n  if (this.lib) {return}\n\n  this.useQuerystring = options.useQuerystring\n  this.lib = (this.useQuerystring ? querystring : qs)\n\n  this.parseOptions = options.qsParseOptions || {}\n  this.stringifyOptions = options.qsStringifyOptions || {}\n}\n\nQuerystring.prototype.stringify = function (obj) {\n  return (this.useQuerystring)\n    ? this.rfc3986(this.lib.stringify(obj,\n      this.stringifyOptions.sep || null,\n      this.stringifyOptions.eq || null,\n      this.stringifyOptions))\n    : this.lib.stringify(obj, this.stringifyOptions)\n}\n\nQuerystring.prototype.parse = function (str) {\n  return (this.useQuerystring)\n    ? this.lib.parse(str,\n      this.parseOptions.sep || null,\n      this.parseOptions.eq || null,\n      this.parseOptions)\n    : this.lib.parse(str, this.parseOptions)\n}\n\nQuerystring.prototype.rfc3986 = function (str) {\n  return str.replace(/[!'()*]/g, function (c) {\n    return '%' + c.charCodeAt(0).toString(16).toUpperCase()\n  })\n}\n\nQuerystring.prototype.unescape = querystring.unescape\n\nexports.Querystring = Querystring\n","/home/travis/build/npmtest/node-npmtest-auto-install/auto-install/node_modules/qs/lib/index.js":"'use strict';\n\nvar Stringify = require('./stringify');\nvar Parse = require('./parse');\n\nmodule.exports = {\n    stringify: Stringify,\n    parse: Parse\n};\n","/home/travis/build/npmtest/node-npmtest-auto-install/auto-install/node_modules/qs/lib/stringify.js":"'use strict';\n\nvar Utils = require('./utils');\n\nvar arrayPrefixGenerators = {\n    brackets: function brackets(prefix) {\n        return prefix + '[]';\n    },\n    indices: function indices(prefix, key) {\n        return prefix + '[' + key + ']';\n    },\n    repeat: function repeat(prefix) {\n        return prefix;\n    }\n};\n\nvar defaults = {\n    delimiter: '&',\n    strictNullHandling: false,\n    skipNulls: false,\n    encode: true,\n    encoder: Utils.encode\n};\n\nvar stringify = function stringify(object, prefix, generateArrayPrefix, strictNullHandling, skipNulls, encoder, filter, sort, allowDots) {\n    var obj = object;\n    if (typeof filter === 'function') {\n        obj = filter(prefix, obj);\n    } else if (obj instanceof Date) {\n        obj = obj.toISOString();\n    } else if (obj === null) {\n        if (strictNullHandling) {\n            return encoder ? encoder(prefix) : prefix;\n        }\n\n        obj = '';\n    }\n\n    if (typeof obj === 'string' || typeof obj === 'number' || typeof obj === 'boolean' || Utils.isBuffer(obj)) {\n        if (encoder) {\n            return [encoder(prefix) + '=' + encoder(obj)];\n        }\n        return [prefix + '=' + String(obj)];\n    }\n\n    var values = [];\n\n    if (typeof obj === 'undefined') {\n        return values;\n    }\n\n    var objKeys;\n    if (Array.isArray(filter)) {\n        objKeys = filter;\n    } else {\n        var keys = Object.keys(obj);\n        objKeys = sort ? keys.sort(sort) : keys;\n    }\n\n    for (var i = 0; i < objKeys.length; ++i) {\n        var key = objKeys[i];\n\n        if (skipNulls && obj[key] === null) {\n            continue;\n        }\n\n        if (Array.isArray(obj)) {\n            values = values.concat(stringify(obj[key], generateArrayPrefix(prefix, key), generateArrayPrefix, strictNullHandling, skipNulls, encoder, filter, sort, allowDots));\n        } else {\n            values = values.concat(stringify(obj[key], prefix + (allowDots ? '.' + key : '[' + key + ']'), generateArrayPrefix, strictNullHandling, skipNulls, encoder, filter, sort, allowDots));\n        }\n    }\n\n    return values;\n};\n\nmodule.exports = function (object, opts) {\n    var obj = object;\n    var options = opts || {};\n    var delimiter = typeof options.delimiter === 'undefined' ? defaults.delimiter : options.delimiter;\n    var strictNullHandling = typeof options.strictNullHandling === 'boolean' ? options.strictNullHandling : defaults.strictNullHandling;\n    var skipNulls = typeof options.skipNulls === 'boolean' ? options.skipNulls : defaults.skipNulls;\n    var encode = typeof options.encode === 'boolean' ? options.encode : defaults.encode;\n    var encoder = encode ? (typeof options.encoder === 'function' ? options.encoder : defaults.encoder) : null;\n    var sort = typeof options.sort === 'function' ? options.sort : null;\n    var allowDots = typeof options.allowDots === 'undefined' ? false : options.allowDots;\n    var objKeys;\n    var filter;\n\n    if (options.encoder !== null && options.encoder !== undefined && typeof options.encoder !== 'function') {\n        throw new TypeError('Encoder has to be a function.');\n    }\n\n    if (typeof options.filter === 'function') {\n        filter = options.filter;\n        obj = filter('', obj);\n    } else if (Array.isArray(options.filter)) {\n        objKeys = filter = options.filter;\n    }\n\n    var keys = [];\n\n    if (typeof obj !== 'object' || obj === null) {\n        return '';\n    }\n\n    var arrayFormat;\n    if (options.arrayFormat in arrayPrefixGenerators) {\n        arrayFormat = options.arrayFormat;\n    } else if ('indices' in options) {\n        arrayFormat = options.indices ? 'indices' : 'repeat';\n    } else {\n        arrayFormat = 'indices';\n    }\n\n    var generateArrayPrefix = arrayPrefixGenerators[arrayFormat];\n\n    if (!objKeys) {\n        objKeys = Object.keys(obj);\n    }\n\n    if (sort) {\n        objKeys.sort(sort);\n    }\n\n    for (var i = 0; i < objKeys.length; ++i) {\n        var key = objKeys[i];\n\n        if (skipNulls && obj[key] === null) {\n            continue;\n        }\n\n        keys = keys.concat(stringify(obj[key], key, generateArrayPrefix, strictNullHandling, skipNulls, encoder, filter, sort, allowDots));\n    }\n\n    return keys.join(delimiter);\n};\n","/home/travis/build/npmtest/node-npmtest-auto-install/auto-install/node_modules/qs/lib/utils.js":"'use strict';\n\nvar hexTable = (function () {\n    var array = new Array(256);\n    for (var i = 0; i < 256; ++i) {\n        array[i] = '%' + ((i < 16 ? '0' : '') + i.toString(16)).toUpperCase();\n    }\n\n    return array;\n}());\n\nvar has = Object.prototype.hasOwnProperty;\n\nexports.arrayToObject = function (source, options) {\n    var obj = options.plainObjects ? Object.create(null) : {};\n    for (var i = 0; i < source.length; ++i) {\n        if (typeof source[i] !== 'undefined') {\n            obj[i] = source[i];\n        }\n    }\n\n    return obj;\n};\n\nexports.merge = function (target, source, options) {\n    if (!source) {\n        return target;\n    }\n\n    if (typeof source !== 'object') {\n        if (Array.isArray(target)) {\n            target.push(source);\n        } else if (typeof target === 'object') {\n            if (options.plainObjects || options.allowPrototypes || !has.call(Object.prototype, source)) {\n                target[source] = true;\n            }\n        } else {\n            return [target, source];\n        }\n\n        return target;\n    }\n\n    if (typeof target !== 'object') {\n        return [target].concat(source);\n    }\n\n    var mergeTarget = target;\n    if (Array.isArray(target) && !Array.isArray(source)) {\n        mergeTarget = exports.arrayToObject(target, options);\n    }\n\n    return Object.keys(source).reduce(function (acc, key) {\n        var value = source[key];\n\n        if (has.call(acc, key)) {\n            acc[key] = exports.merge(acc[key], value, options);\n        } else {\n            acc[key] = value;\n        }\n        return acc;\n    }, mergeTarget);\n};\n\nexports.decode = function (str) {\n    try {\n        return decodeURIComponent(str.replace(/\\+/g, ' '));\n    } catch (e) {\n        return str;\n    }\n};\n\nexports.encode = function (str) {\n    // This code was originally written by Brian White (mscdex) for the io.js core querystring library.\n    // It has been adapted here for stricter adherence to RFC 3986\n    if (str.length === 0) {\n        return str;\n    }\n\n    var string = typeof str === 'string' ? str : String(str);\n\n    var out = '';\n    for (var i = 0; i < string.length; ++i) {\n        var c = string.charCodeAt(i);\n\n        if (\n            c === 0x2D || // -\n            c === 0x2E || // .\n            c === 0x5F || // _\n            c === 0x7E || // ~\n            (c >= 0x30 && c <= 0x39) || // 0-9\n            (c >= 0x41 && c <= 0x5A) || // a-z\n            (c >= 0x61 && c <= 0x7A) // A-Z\n        ) {\n            out += string.charAt(i);\n            continue;\n        }\n\n        if (c < 0x80) {\n            out = out + hexTable[c];\n            continue;\n        }\n\n        if (c < 0x800) {\n            out = out + (hexTable[0xC0 | (c >> 6)] + hexTable[0x80 | (c & 0x3F)]);\n            continue;\n        }\n\n        if (c < 0xD800 || c >= 0xE000) {\n            out = out + (hexTable[0xE0 | (c >> 12)] + hexTable[0x80 | ((c >> 6) & 0x3F)] + hexTable[0x80 | (c & 0x3F)]);\n            continue;\n        }\n\n        i += 1;\n        c = 0x10000 + (((c & 0x3FF) << 10) | (string.charCodeAt(i) & 0x3FF));\n        out += hexTable[0xF0 | (c >> 18)] + hexTable[0x80 | ((c >> 12) & 0x3F)] + hexTable[0x80 | ((c >> 6) & 0x3F)] + hexTable[0x80 | (c & 0x3F)];\n    }\n\n    return out;\n};\n\nexports.compact = function (obj, references) {\n    if (typeof obj !== 'object' || obj === null) {\n        return obj;\n    }\n\n    var refs = references || [];\n    var lookup = refs.indexOf(obj);\n    if (lookup !== -1) {\n        return refs[lookup];\n    }\n\n    refs.push(obj);\n\n    if (Array.isArray(obj)) {\n        var compacted = [];\n\n        for (var i = 0; i < obj.length; ++i) {\n            if (obj[i] && typeof obj[i] === 'object') {\n                compacted.push(exports.compact(obj[i], refs));\n            } else if (typeof obj[i] !== 'undefined') {\n                compacted.push(obj[i]);\n            }\n        }\n\n        return compacted;\n    }\n\n    var keys = Object.keys(obj);\n    for (var j = 0; j < keys.length; ++j) {\n        var key = keys[j];\n        obj[key] = exports.compact(obj[key], refs);\n    }\n\n    return obj;\n};\n\nexports.isRegExp = function (obj) {\n    return Object.prototype.toString.call(obj) === '[object RegExp]';\n};\n\nexports.isBuffer = function (obj) {\n    if (obj === null || typeof obj === 'undefined') {\n        return false;\n    }\n\n    return !!(obj.constructor && obj.constructor.isBuffer && obj.constructor.isBuffer(obj));\n};\n","/home/travis/build/npmtest/node-npmtest-auto-install/auto-install/node_modules/qs/lib/parse.js":"'use strict';\n\nvar Utils = require('./utils');\n\nvar has = Object.prototype.hasOwnProperty;\n\nvar defaults = {\n    delimiter: '&',\n    depth: 5,\n    arrayLimit: 20,\n    parameterLimit: 1000,\n    strictNullHandling: false,\n    plainObjects: false,\n    allowPrototypes: false,\n    allowDots: false,\n    decoder: Utils.decode\n};\n\nvar parseValues = function parseValues(str, options) {\n    var obj = {};\n    var parts = str.split(options.delimiter, options.parameterLimit === Infinity ? undefined : options.parameterLimit);\n\n    for (var i = 0; i < parts.length; ++i) {\n        var part = parts[i];\n        var pos = part.indexOf(']=') === -1 ? part.indexOf('=') : part.indexOf(']=') + 1;\n\n        var key, val;\n        if (pos === -1) {\n            key = options.decoder(part);\n            val = options.strictNullHandling ? null : '';\n        } else {\n            key = options.decoder(part.slice(0, pos));\n            val = options.decoder(part.slice(pos + 1));\n        }\n        if (has.call(obj, key)) {\n            obj[key] = [].concat(obj[key]).concat(val);\n        } else {\n            obj[key] = val;\n        }\n    }\n\n    return obj;\n};\n\nvar parseObject = function parseObject(chain, val, options) {\n    if (!chain.length) {\n        return val;\n    }\n\n    var root = chain.shift();\n\n    var obj;\n    if (root === '[]') {\n        obj = [];\n        obj = obj.concat(parseObject(chain, val, options));\n    } else {\n        obj = options.plainObjects ? Object.create(null) : {};\n        var cleanRoot = root.charAt(0) === '[' && root.charAt(root.length - 1) === ']' ? root.slice(1, -1) : root;\n        var index = parseInt(cleanRoot, 10);\n        if (\n            !isNaN(index) &&\n            root !== cleanRoot &&\n            String(index) === cleanRoot &&\n            index >= 0 &&\n            (options.parseArrays && index <= options.arrayLimit)\n        ) {\n            obj = [];\n            obj[index] = parseObject(chain, val, options);\n        } else {\n            obj[cleanRoot] = parseObject(chain, val, options);\n        }\n    }\n\n    return obj;\n};\n\nvar parseKeys = function parseKeys(givenKey, val, options) {\n    if (!givenKey) {\n        return;\n    }\n\n    // Transform dot notation to bracket notation\n    var key = options.allowDots ? givenKey.replace(/\\.([^.[]+)/g, '[$1]') : givenKey;\n\n    // The regex chunks\n\n    var brackets = /(\\[[^[\\]]*])/;\n    var child = /(\\[[^[\\]]*])/g;\n\n    // Get the parent\n\n    var segment = brackets.exec(key);\n    var parent = segment ? key.slice(0, segment.index) : key;\n\n    // Stash the parent if it exists\n\n    var keys = [];\n    if (parent) {\n        // If we aren't using plain objects, optionally prefix keys\n        // that would overwrite object prototype properties\n        if (!options.plainObjects && has.call(Object.prototype, parent)) {\n            if (!options.allowPrototypes) {\n                return;\n            }\n        }\n\n        keys.push(parent);\n    }\n\n    // Loop through children appending to the array until we hit depth\n\n    var i = 0;\n    while ((segment = child.exec(key)) !== null && i < options.depth) {\n        i += 1;\n        if (!options.plainObjects && has.call(Object.prototype, segment[1].slice(1, -1))) {\n            if (!options.allowPrototypes) {\n                return;\n            }\n        }\n        keys.push(segment[1]);\n    }\n\n    // If there's a remainder, just add whatever is left\n\n    if (segment) {\n        keys.push('[' + key.slice(segment.index) + ']');\n    }\n\n    return parseObject(keys, val, options);\n};\n\nmodule.exports = function (str, opts) {\n    var options = opts || {};\n\n    if (options.decoder !== null && options.decoder !== undefined && typeof options.decoder !== 'function') {\n        throw new TypeError('Decoder has to be a function.');\n    }\n\n    options.delimiter = typeof options.delimiter === 'string' || Utils.isRegExp(options.delimiter) ? options.delimiter : defaults.delimiter;\n    options.depth = typeof options.depth === 'number' ? options.depth : defaults.depth;\n    options.arrayLimit = typeof options.arrayLimit === 'number' ? options.arrayLimit : defaults.arrayLimit;\n    options.parseArrays = options.parseArrays !== false;\n    options.decoder = typeof options.decoder === 'function' ? options.decoder : defaults.decoder;\n    options.allowDots = typeof options.allowDots === 'boolean' ? options.allowDots : defaults.allowDots;\n    options.plainObjects = typeof options.plainObjects === 'boolean' ? options.plainObjects : defaults.plainObjects;\n    options.allowPrototypes = typeof options.allowPrototypes === 'boolean' ? options.allowPrototypes : defaults.allowPrototypes;\n    options.parameterLimit = typeof options.parameterLimit === 'number' ? options.parameterLimit : defaults.parameterLimit;\n    options.strictNullHandling = typeof options.strictNullHandling === 'boolean' ? options.strictNullHandling : defaults.strictNullHandling;\n\n    if (str === '' || str === null || typeof str === 'undefined') {\n        return options.plainObjects ? Object.create(null) : {};\n    }\n\n    var tempObj = typeof str === 'string' ? parseValues(str, options) : str;\n    var obj = options.plainObjects ? Object.create(null) : {};\n\n    // Iterate over the keys and setup the new object\n\n    var keys = Object.keys(tempObj);\n    for (var i = 0; i < keys.length; ++i) {\n        var key = keys[i];\n        var newObj = parseKeys(key, tempObj[key], options);\n        obj = Utils.merge(obj, newObj, options);\n    }\n\n    return Utils.compact(obj);\n};\n","/home/travis/build/npmtest/node-npmtest-auto-install/auto-install/node_modules/request/lib/har.js":"'use strict'\n\nvar fs = require('fs')\nvar qs = require('querystring')\nvar validate = require('har-validator')\nvar extend = require('extend')\n\nfunction Har (request) {\n  this.request = request\n}\n\nHar.prototype.reducer = function (obj, pair) {\n  // new property ?\n  if (obj[pair.name] === undefined) {\n    obj[pair.name] = pair.value\n    return obj\n  }\n\n  // existing? convert to array\n  var arr = [\n    obj[pair.name],\n    pair.value\n  ]\n\n  obj[pair.name] = arr\n\n  return obj\n}\n\nHar.prototype.prep = function (data) {\n  // construct utility properties\n  data.queryObj = {}\n  data.headersObj = {}\n  data.postData.jsonObj = false\n  data.postData.paramsObj = false\n\n  // construct query objects\n  if (data.queryString && data.queryString.length) {\n    data.queryObj = data.queryString.reduce(this.reducer, {})\n  }\n\n  // construct headers objects\n  if (data.headers && data.headers.length) {\n    // loweCase header keys\n    data.headersObj = data.headers.reduceRight(function (headers, header) {\n      headers[header.name] = header.value\n      return headers\n    }, {})\n  }\n\n  // construct Cookie header\n  if (data.cookies && data.cookies.length) {\n    var cookies = data.cookies.map(function (cookie) {\n      return cookie.name + '=' + cookie.value\n    })\n\n    if (cookies.length) {\n      data.headersObj.cookie = cookies.join('; ')\n    }\n  }\n\n  // prep body\n  function some (arr) {\n    return arr.some(function (type) {\n      return data.postData.mimeType.indexOf(type) === 0\n    })\n  }\n\n  if (some([\n    'multipart/mixed',\n    'multipart/related',\n    'multipart/form-data',\n    'multipart/alternative'])) {\n\n    // reset values\n    data.postData.mimeType = 'multipart/form-data'\n  }\n\n  else if (some([\n    'application/x-www-form-urlencoded'])) {\n\n    if (!data.postData.params) {\n      data.postData.text = ''\n    } else {\n      data.postData.paramsObj = data.postData.params.reduce(this.reducer, {})\n\n      // always overwrite\n      data.postData.text = qs.stringify(data.postData.paramsObj)\n    }\n  }\n\n  else if (some([\n    'text/json',\n    'text/x-json',\n    'application/json',\n    'application/x-json'])) {\n\n    data.postData.mimeType = 'application/json'\n\n    if (data.postData.text) {\n      try {\n        data.postData.jsonObj = JSON.parse(data.postData.text)\n      } catch (e) {\n        this.request.debug(e)\n\n        // force back to text/plain\n        data.postData.mimeType = 'text/plain'\n      }\n    }\n  }\n\n  return data\n}\n\nHar.prototype.options = function (options) {\n  // skip if no har property defined\n  if (!options.har) {\n    return options\n  }\n\n  var har = {}\n  extend(har, options.har)\n\n  // only process the first entry\n  if (har.log && har.log.entries) {\n    har = har.log.entries[0]\n  }\n\n  // add optional properties to make validation successful\n  har.url = har.url || options.url || options.uri || options.baseUrl || '/'\n  har.httpVersion = har.httpVersion || 'HTTP/1.1'\n  har.queryString = har.queryString || []\n  har.headers = har.headers || []\n  har.cookies = har.cookies || []\n  har.postData = har.postData || {}\n  har.postData.mimeType = har.postData.mimeType || 'application/octet-stream'\n\n  har.bodySize = 0\n  har.headersSize = 0\n  har.postData.size = 0\n\n  if (!validate.request(har)) {\n    return options\n  }\n\n  // clean up and get some utility properties\n  var req = this.prep(har)\n\n  // construct new options\n  if (req.url) {\n    options.url = req.url\n  }\n\n  if (req.method) {\n    options.method = req.method\n  }\n\n  if (Object.keys(req.queryObj).length) {\n    options.qs = req.queryObj\n  }\n\n  if (Object.keys(req.headersObj).length) {\n    options.headers = req.headersObj\n  }\n\n  function test (type) {\n    return req.postData.mimeType.indexOf(type) === 0\n  }\n  if (test('application/x-www-form-urlencoded')) {\n    options.form = req.postData.paramsObj\n  }\n  else if (test('application/json')) {\n    if (req.postData.jsonObj) {\n      options.body = req.postData.jsonObj\n      options.json = true\n    }\n  }\n  else if (test('multipart/form-data')) {\n    options.formData = {}\n\n    req.postData.params.forEach(function (param) {\n      var attachment = {}\n\n      if (!param.fileName && !param.fileName && !param.contentType) {\n        options.formData[param.name] = param.value\n        return\n      }\n\n      // attempt to read from disk!\n      if (param.fileName && !param.value) {\n        attachment.value = fs.createReadStream(param.fileName)\n      } else if (param.value) {\n        attachment.value = param.value\n      }\n\n      if (param.fileName) {\n        attachment.options = {\n          filename: param.fileName,\n          contentType: param.contentType ? param.contentType : null\n        }\n      }\n\n      options.formData[param.name] = attachment\n    })\n  }\n  else {\n    if (req.postData.text) {\n      options.body = req.postData.text\n    }\n  }\n\n  return options\n}\n\nexports.Har = Har\n","/home/travis/build/npmtest/node-npmtest-auto-install/auto-install/node_modules/har-validator/lib/index.js":"'use strict'\n\nvar Promise = require('pinkie-promise')\nvar runner = require('./runner')\nvar schemas = require('./schemas')\n\nvar promisify = function (schema) {\n  return function (data) {\n    return new Promise(function (resolve, reject) {\n      runner(schema, data, function (err, valid) {\n        return err === null ? resolve(data) : reject(err)\n      })\n    })\n  }\n}\n\nmodule.exports = promisify(schemas.har)\n\n// utility methods for all parts of the schema\nObject.keys(schemas).map(function (name) {\n  module.exports[name] = promisify(schemas[name])\n})\n","/home/travis/build/npmtest/node-npmtest-auto-install/auto-install/node_modules/har-validator/lib/runner.js":"'use strict'\n\nvar schemas = require('./schemas')\nvar ValidationError = require('./error')\nvar validator = require('is-my-json-valid')\n\nmodule.exports = function (schema, data, cb) {\n  // default value\n  var valid = false\n\n  // validator config\n  var validate = validator(schema, {\n    greedy: true,\n    verbose: true,\n    schemas: schemas\n  })\n\n  // execute is-my-json-valid\n  if (data !== undefined) {\n    valid = validate(data)\n  }\n\n  // callback?\n  if (typeof cb === 'function') {\n    return cb(validate.errors ? new ValidationError(validate.errors) : null, valid)\n  }\n\n  return valid\n}\n","/home/travis/build/npmtest/node-npmtest-auto-install/auto-install/node_modules/har-validator/lib/schemas/index.js":"'use strict'\n\nvar schemas = {\n  cache: require('./cache.json'),\n  cacheEntry: require('./cacheEntry.json'),\n  content: require('./content.json'),\n  cookie: require('./cookie.json'),\n  creator: require('./creator.json'),\n  entry: require('./entry.json'),\n  har: require('./har.json'),\n  log: require('./log.json'),\n  page: require('./page.json'),\n  pageTimings: require('./pageTimings.json'),\n  postData: require('./postData.json'),\n  record: require('./record.json'),\n  request: require('./request.json'),\n  response: require('./response.json'),\n  timings: require('./timings.json')\n}\n\n// is-my-json-valid does not provide meaningful error messages for external schemas\n// this is a workaround\nschemas.cache.properties.beforeRequest = schemas.cacheEntry\nschemas.cache.properties.afterRequest = schemas.cacheEntry\n\nschemas.page.properties.pageTimings = schemas.pageTimings\n\nschemas.request.properties.cookies.items = schemas.cookie\nschemas.request.properties.headers.items = schemas.record\nschemas.request.properties.queryString.items = schemas.record\nschemas.request.properties.postData = schemas.postData\n\nschemas.response.properties.cookies.items = schemas.cookie\nschemas.response.properties.headers.items = schemas.record\nschemas.response.properties.content = schemas.content\n\nschemas.entry.properties.request = schemas.request\nschemas.entry.properties.response = schemas.response\nschemas.entry.properties.cache = schemas.cache\nschemas.entry.properties.timings = schemas.timings\n\nschemas.log.properties.creator = schemas.creator\nschemas.log.properties.browser = schemas.creator\nschemas.log.properties.pages.items = schemas.page\nschemas.log.properties.entries.items = schemas.entry\n\nschemas.har.properties.log = schemas.log\n\nmodule.exports = schemas\n","/home/travis/build/npmtest/node-npmtest-auto-install/auto-install/node_modules/har-validator/lib/error.js":"'use strict'\n\nfunction ValidationError (errors) {\n  this.name = 'ValidationError'\n  this.errors = errors\n}\n\nValidationError.prototype = Error.prototype\n\nmodule.exports = ValidationError\n","/home/travis/build/npmtest/node-npmtest-auto-install/auto-install/node_modules/request/lib/auth.js":"'use strict'\n\nvar caseless = require('caseless')\n  , uuid = require('node-uuid')\n  , helpers = require('./helpers')\n\nvar md5 = helpers.md5\n  , toBase64 = helpers.toBase64\n\n\nfunction Auth (request) {\n  // define all public properties here\n  this.request = request\n  this.hasAuth = false\n  this.sentAuth = false\n  this.bearerToken = null\n  this.user = null\n  this.pass = null\n}\n\nAuth.prototype.basic = function (user, pass, sendImmediately) {\n  var self = this\n  if (typeof user !== 'string' || (pass !== undefined && typeof pass !== 'string')) {\n    self.request.emit('error', new Error('auth() received invalid user or password'))\n  }\n  self.user = user\n  self.pass = pass\n  self.hasAuth = true\n  var header = user + ':' + (pass || '')\n  if (sendImmediately || typeof sendImmediately === 'undefined') {\n    var authHeader = 'Basic ' + toBase64(header)\n    self.sentAuth = true\n    return authHeader\n  }\n}\n\nAuth.prototype.bearer = function (bearer, sendImmediately) {\n  var self = this\n  self.bearerToken = bearer\n  self.hasAuth = true\n  if (sendImmediately || typeof sendImmediately === 'undefined') {\n    if (typeof bearer === 'function') {\n      bearer = bearer()\n    }\n    var authHeader = 'Bearer ' + (bearer || '')\n    self.sentAuth = true\n    return authHeader\n  }\n}\n\nAuth.prototype.digest = function (method, path, authHeader) {\n  // TODO: More complete implementation of RFC 2617.\n  //   - handle challenge.domain\n  //   - support qop=\"auth-int\" only\n  //   - handle Authentication-Info (not necessarily?)\n  //   - check challenge.stale (not necessarily?)\n  //   - increase nc (not necessarily?)\n  // For reference:\n  // http://tools.ietf.org/html/rfc2617#section-3\n  // https://github.com/bagder/curl/blob/master/lib/http_digest.c\n\n  var self = this\n\n  var challenge = {}\n  var re = /([a-z0-9_-]+)=(?:\"([^\"]+)\"|([a-z0-9_-]+))/gi\n  for (;;) {\n    var match = re.exec(authHeader)\n    if (!match) {\n      break\n    }\n    challenge[match[1]] = match[2] || match[3]\n  }\n\n  /**\n   * RFC 2617: handle both MD5 and MD5-sess algorithms.\n   *\n   * If the algorithm directive's value is \"MD5\" or unspecified, then HA1 is\n   *   HA1=MD5(username:realm:password)\n   * If the algorithm directive's value is \"MD5-sess\", then HA1 is\n   *   HA1=MD5(MD5(username:realm:password):nonce:cnonce)\n   */\n  var ha1Compute = function (algorithm, user, realm, pass, nonce, cnonce) {\n    var ha1 = md5(user + ':' + realm + ':' + pass)\n    if (algorithm && algorithm.toLowerCase() === 'md5-sess') {\n      return md5(ha1 + ':' + nonce + ':' + cnonce)\n    } else {\n      return ha1\n    }\n  }\n\n  var qop = /(^|,)\\s*auth\\s*($|,)/.test(challenge.qop) && 'auth'\n  var nc = qop && '00000001'\n  var cnonce = qop && uuid().replace(/-/g, '')\n  var ha1 = ha1Compute(challenge.algorithm, self.user, challenge.realm, self.pass, challenge.nonce, cnonce)\n  var ha2 = md5(method + ':' + path)\n  var digestResponse = qop\n    ? md5(ha1 + ':' + challenge.nonce + ':' + nc + ':' + cnonce + ':' + qop + ':' + ha2)\n    : md5(ha1 + ':' + challenge.nonce + ':' + ha2)\n  var authValues = {\n    username: self.user,\n    realm: challenge.realm,\n    nonce: challenge.nonce,\n    uri: path,\n    qop: qop,\n    response: digestResponse,\n    nc: nc,\n    cnonce: cnonce,\n    algorithm: challenge.algorithm,\n    opaque: challenge.opaque\n  }\n\n  authHeader = []\n  for (var k in authValues) {\n    if (authValues[k]) {\n      if (k === 'qop' || k === 'nc' || k === 'algorithm') {\n        authHeader.push(k + '=' + authValues[k])\n      } else {\n        authHeader.push(k + '=\"' + authValues[k] + '\"')\n      }\n    }\n  }\n  authHeader = 'Digest ' + authHeader.join(', ')\n  self.sentAuth = true\n  return authHeader\n}\n\nAuth.prototype.onRequest = function (user, pass, sendImmediately, bearer) {\n  var self = this\n    , request = self.request\n\n  var authHeader\n  if (bearer === undefined && user === undefined) {\n    self.request.emit('error', new Error('no auth mechanism defined'))\n  } else if (bearer !== undefined) {\n    authHeader = self.bearer(bearer, sendImmediately)\n  } else {\n    authHeader = self.basic(user, pass, sendImmediately)\n  }\n  if (authHeader) {\n    request.setHeader('authorization', authHeader)\n  }\n}\n\nAuth.prototype.onResponse = function (response) {\n  var self = this\n    , request = self.request\n\n  if (!self.hasAuth || self.sentAuth) { return null }\n\n  var c = caseless(response.headers)\n\n  var authHeader = c.get('www-authenticate')\n  var authVerb = authHeader && authHeader.split(' ')[0].toLowerCase()\n  request.debug('reauth', authVerb)\n\n  switch (authVerb) {\n    case 'basic':\n      return self.basic(self.user, self.pass, true)\n\n    case 'bearer':\n      return self.bearer(self.bearerToken, true)\n\n    case 'digest':\n      return self.digest(request.method, request.path, authHeader)\n  }\n}\n\nexports.Auth = Auth\n","/home/travis/build/npmtest/node-npmtest-auto-install/auto-install/node_modules/node-uuid/uuid.js":"//     uuid.js\n//\n//     Copyright (c) 2010-2012 Robert Kieffer\n//     MIT License - http://opensource.org/licenses/mit-license.php\n\n/*global window, require, define */\n(function(_window) {\n  'use strict';\n\n  // Unique ID creation requires a high quality random # generator.  We feature\n  // detect to determine the best RNG source, normalizing to a function that\n  // returns 128-bits of randomness, since that's what's usually required\n  var _rng, _mathRNG, _nodeRNG, _whatwgRNG, _previousRoot;\n\n  function setupBrowser() {\n    // Allow for MSIE11 msCrypto\n    var _crypto = _window.crypto || _window.msCrypto;\n\n    if (!_rng && _crypto && _crypto.getRandomValues) {\n      // WHATWG crypto-based RNG - http://wiki.whatwg.org/wiki/Crypto\n      //\n      // Moderately fast, high quality\n      try {\n        var _rnds8 = new Uint8Array(16);\n        _whatwgRNG = _rng = function whatwgRNG() {\n          _crypto.getRandomValues(_rnds8);\n          return _rnds8;\n        };\n        _rng();\n      } catch(e) {}\n    }\n\n    if (!_rng) {\n      // Math.random()-based (RNG)\n      //\n      // If all else fails, use Math.random().  It's fast, but is of unspecified\n      // quality.\n      var  _rnds = new Array(16);\n      _mathRNG = _rng = function() {\n        for (var i = 0, r; i < 16; i++) {\n          if ((i & 0x03) === 0) { r = Math.random() * 0x100000000; }\n          _rnds[i] = r >>> ((i & 0x03) << 3) & 0xff;\n        }\n\n        return _rnds;\n      };\n      if ('undefined' !== typeof console && console.warn) {\n        console.warn(\"[SECURITY] node-uuid: crypto not usable, falling back to insecure Math.random()\");\n      }\n    }\n  }\n\n  function setupNode() {\n    // Node.js crypto-based RNG - http://nodejs.org/docs/v0.6.2/api/crypto.html\n    //\n    // Moderately fast, high quality\n    if ('function' === typeof require) {\n      try {\n        var _rb = require('crypto').randomBytes;\n        _nodeRNG = _rng = _rb && function() {return _rb(16);};\n        _rng();\n      } catch(e) {}\n    }\n  }\n\n  if (_window) {\n    setupBrowser();\n  } else {\n    setupNode();\n  }\n\n  // Buffer class to use\n  var BufferClass = ('function' === typeof Buffer) ? Buffer : Array;\n\n  // Maps for number <-> hex string conversion\n  var _byteToHex = [];\n  var _hexToByte = {};\n  for (var i = 0; i < 256; i++) {\n    _byteToHex[i] = (i + 0x100).toString(16).substr(1);\n    _hexToByte[_byteToHex[i]] = i;\n  }\n\n  // **`parse()` - Parse a UUID into it's component bytes**\n  function parse(s, buf, offset) {\n    var i = (buf && offset) || 0, ii = 0;\n\n    buf = buf || [];\n    s.toLowerCase().replace(/[0-9a-f]{2}/g, function(oct) {\n      if (ii < 16) { // Don't overflow!\n        buf[i + ii++] = _hexToByte[oct];\n      }\n    });\n\n    // Zero out remaining bytes if string was short\n    while (ii < 16) {\n      buf[i + ii++] = 0;\n    }\n\n    return buf;\n  }\n\n  // **`unparse()` - Convert UUID byte array (ala parse()) into a string**\n  function unparse(buf, offset) {\n    var i = offset || 0, bth = _byteToHex;\n    return  bth[buf[i++]] + bth[buf[i++]] +\n            bth[buf[i++]] + bth[buf[i++]] + '-' +\n            bth[buf[i++]] + bth[buf[i++]] + '-' +\n            bth[buf[i++]] + bth[buf[i++]] + '-' +\n            bth[buf[i++]] + bth[buf[i++]] + '-' +\n            bth[buf[i++]] + bth[buf[i++]] +\n            bth[buf[i++]] + bth[buf[i++]] +\n            bth[buf[i++]] + bth[buf[i++]];\n  }\n\n  // **`v1()` - Generate time-based UUID**\n  //\n  // Inspired by https://github.com/LiosK/UUID.js\n  // and http://docs.python.org/library/uuid.html\n\n  // random #'s we need to init node and clockseq\n  var _seedBytes = _rng();\n\n  // Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)\n  var _nodeId = [\n    _seedBytes[0] | 0x01,\n    _seedBytes[1], _seedBytes[2], _seedBytes[3], _seedBytes[4], _seedBytes[5]\n  ];\n\n  // Per 4.2.2, randomize (14 bit) clockseq\n  var _clockseq = (_seedBytes[6] << 8 | _seedBytes[7]) & 0x3fff;\n\n  // Previous uuid creation time\n  var _lastMSecs = 0, _lastNSecs = 0;\n\n  // See https://github.com/broofa/node-uuid for API details\n  function v1(options, buf, offset) {\n    var i = buf && offset || 0;\n    var b = buf || [];\n\n    options = options || {};\n\n    var clockseq = (options.clockseq != null) ? options.clockseq : _clockseq;\n\n    // UUID timestamps are 100 nano-second units since the Gregorian epoch,\n    // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so\n    // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'\n    // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.\n    var msecs = (options.msecs != null) ? options.msecs : new Date().getTime();\n\n    // Per 4.2.1.2, use count of uuid's generated during the current clock\n    // cycle to simulate higher resolution clock\n    var nsecs = (options.nsecs != null) ? options.nsecs : _lastNSecs + 1;\n\n    // Time since last uuid creation (in msecs)\n    var dt = (msecs - _lastMSecs) + (nsecs - _lastNSecs)/10000;\n\n    // Per 4.2.1.2, Bump clockseq on clock regression\n    if (dt < 0 && options.clockseq == null) {\n      clockseq = clockseq + 1 & 0x3fff;\n    }\n\n    // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new\n    // time interval\n    if ((dt < 0 || msecs > _lastMSecs) && options.nsecs == null) {\n      nsecs = 0;\n    }\n\n    // Per 4.2.1.2 Throw error if too many uuids are requested\n    if (nsecs >= 10000) {\n      throw new Error('uuid.v1(): Can\\'t create more than 10M uuids/sec');\n    }\n\n    _lastMSecs = msecs;\n    _lastNSecs = nsecs;\n    _clockseq = clockseq;\n\n    // Per 4.1.4 - Convert from unix epoch to Gregorian epoch\n    msecs += 12219292800000;\n\n    // `time_low`\n    var tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;\n    b[i++] = tl >>> 24 & 0xff;\n    b[i++] = tl >>> 16 & 0xff;\n    b[i++] = tl >>> 8 & 0xff;\n    b[i++] = tl & 0xff;\n\n    // `time_mid`\n    var tmh = (msecs / 0x100000000 * 10000) & 0xfffffff;\n    b[i++] = tmh >>> 8 & 0xff;\n    b[i++] = tmh & 0xff;\n\n    // `time_high_and_version`\n    b[i++] = tmh >>> 24 & 0xf | 0x10; // include version\n    b[i++] = tmh >>> 16 & 0xff;\n\n    // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)\n    b[i++] = clockseq >>> 8 | 0x80;\n\n    // `clock_seq_low`\n    b[i++] = clockseq & 0xff;\n\n    // `node`\n    var node = options.node || _nodeId;\n    for (var n = 0; n < 6; n++) {\n      b[i + n] = node[n];\n    }\n\n    return buf ? buf : unparse(b);\n  }\n\n  // **`v4()` - Generate random UUID**\n\n  // See https://github.com/broofa/node-uuid for API details\n  function v4(options, buf, offset) {\n    // Deprecated - 'format' argument, as supported in v1.2\n    var i = buf && offset || 0;\n\n    if (typeof(options) === 'string') {\n      buf = (options === 'binary') ? new BufferClass(16) : null;\n      options = null;\n    }\n    options = options || {};\n\n    var rnds = options.random || (options.rng || _rng)();\n\n    // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n    rnds[6] = (rnds[6] & 0x0f) | 0x40;\n    rnds[8] = (rnds[8] & 0x3f) | 0x80;\n\n    // Copy bytes to buffer, if provided\n    if (buf) {\n      for (var ii = 0; ii < 16; ii++) {\n        buf[i + ii] = rnds[ii];\n      }\n    }\n\n    return buf || unparse(rnds);\n  }\n\n  // Export public API\n  var uuid = v4;\n  uuid.v1 = v1;\n  uuid.v4 = v4;\n  uuid.parse = parse;\n  uuid.unparse = unparse;\n  uuid.BufferClass = BufferClass;\n  uuid._rng = _rng;\n  uuid._mathRNG = _mathRNG;\n  uuid._nodeRNG = _nodeRNG;\n  uuid._whatwgRNG = _whatwgRNG;\n\n  if (('undefined' !== typeof module) && module.exports) {\n    // Publish as node.js module\n    module.exports = uuid;\n  } else if (typeof define === 'function' && define.amd) {\n    // Publish as AMD module\n    define(function() {return uuid;});\n\n\n  } else {\n    // Publish as global (in browsers)\n    _previousRoot = _window.uuid;\n\n    // **`noConflict()` - (browser only) to reset global 'uuid' var**\n    uuid.noConflict = function() {\n      _window.uuid = _previousRoot;\n      return uuid;\n    };\n\n    _window.uuid = uuid;\n  }\n})('undefined' !== typeof window ? window : null);\n","/home/travis/build/npmtest/node-npmtest-auto-install/auto-install/node_modules/request/lib/oauth.js":"'use strict'\n\nvar url = require('url')\n  , qs = require('qs')\n  , caseless = require('caseless')\n  , uuid = require('node-uuid')\n  , oauth = require('oauth-sign')\n  , crypto = require('crypto')\n\n\nfunction OAuth (request) {\n  this.request = request\n  this.params = null\n}\n\nOAuth.prototype.buildParams = function (_oauth, uri, method, query, form, qsLib) {\n  var oa = {}\n  for (var i in _oauth) {\n    oa['oauth_' + i] = _oauth[i]\n  }\n  if (!oa.oauth_version) {\n    oa.oauth_version = '1.0'\n  }\n  if (!oa.oauth_timestamp) {\n    oa.oauth_timestamp = Math.floor( Date.now() / 1000 ).toString()\n  }\n  if (!oa.oauth_nonce) {\n    oa.oauth_nonce = uuid().replace(/-/g, '')\n  }\n  if (!oa.oauth_signature_method) {\n    oa.oauth_signature_method = 'HMAC-SHA1'\n  }\n\n  var consumer_secret_or_private_key = oa.oauth_consumer_secret || oa.oauth_private_key\n  delete oa.oauth_consumer_secret\n  delete oa.oauth_private_key\n\n  var token_secret = oa.oauth_token_secret\n  delete oa.oauth_token_secret\n\n  var realm = oa.oauth_realm\n  delete oa.oauth_realm\n  delete oa.oauth_transport_method\n\n  var baseurl = uri.protocol + '//' + uri.host + uri.pathname\n  var params = qsLib.parse([].concat(query, form, qsLib.stringify(oa)).join('&'))\n\n  oa.oauth_signature = oauth.sign(\n    oa.oauth_signature_method,\n    method,\n    baseurl,\n    params,\n    consumer_secret_or_private_key,\n    token_secret)\n\n  if (realm) {\n    oa.realm = realm\n  }\n\n  return oa\n}\n\nOAuth.prototype.buildBodyHash = function(_oauth, body) {\n  if (['HMAC-SHA1', 'RSA-SHA1'].indexOf(_oauth.signature_method || 'HMAC-SHA1') < 0) {\n    this.request.emit('error', new Error('oauth: ' + _oauth.signature_method +\n      ' signature_method not supported with body_hash signing.'))\n  }\n\n  var shasum = crypto.createHash('sha1')\n  shasum.update(body || '')\n  var sha1 = shasum.digest('hex')\n\n  return new Buffer(sha1).toString('base64')\n}\n\nOAuth.prototype.concatParams = function (oa, sep, wrap) {\n  wrap = wrap || ''\n\n  var params = Object.keys(oa).filter(function (i) {\n    return i !== 'realm' && i !== 'oauth_signature'\n  }).sort()\n\n  if (oa.realm) {\n    params.splice(0, 0, 'realm')\n  }\n  params.push('oauth_signature')\n\n  return params.map(function (i) {\n    return i + '=' + wrap + oauth.rfc3986(oa[i]) + wrap\n  }).join(sep)\n}\n\nOAuth.prototype.onRequest = function (_oauth) {\n  var self = this\n  self.params = _oauth\n\n  var uri = self.request.uri || {}\n    , method = self.request.method || ''\n    , headers = caseless(self.request.headers)\n    , body = self.request.body || ''\n    , qsLib = self.request.qsLib || qs\n\n  var form\n    , query\n    , contentType = headers.get('content-type') || ''\n    , formContentType = 'application/x-www-form-urlencoded'\n    , transport = _oauth.transport_method || 'header'\n\n  if (contentType.slice(0, formContentType.length) === formContentType) {\n    contentType = formContentType\n    form = body\n  }\n  if (uri.query) {\n    query = uri.query\n  }\n  if (transport === 'body' && (method !== 'POST' || contentType !== formContentType)) {\n    self.request.emit('error', new Error('oauth: transport_method of body requires POST ' +\n      'and content-type ' + formContentType))\n  }\n\n  if (!form && typeof _oauth.body_hash === 'boolean') {\n    _oauth.body_hash = self.buildBodyHash(_oauth, self.request.body.toString())\n  }\n\n  var oa = self.buildParams(_oauth, uri, method, query, form, qsLib)\n\n  switch (transport) {\n    case 'header':\n      self.request.setHeader('Authorization', 'OAuth ' + self.concatParams(oa, ',', '\"'))\n      break\n\n    case 'query':\n      var href = self.request.uri.href += (query ? '&' : '?') + self.concatParams(oa, '&')\n      self.request.uri = url.parse(href)\n      self.request.path = self.request.uri.path\n      break\n\n    case 'body':\n      self.request.body = (form ? form + '&' : '') + self.concatParams(oa, '&')\n      break\n\n    default:\n      self.request.emit('error', new Error('oauth: transport_method invalid'))\n  }\n}\n\nexports.OAuth = OAuth\n","/home/travis/build/npmtest/node-npmtest-auto-install/auto-install/node_modules/request/lib/multipart.js":"'use strict'\n\nvar uuid = require('node-uuid')\n  , CombinedStream = require('combined-stream')\n  , isstream = require('isstream')\n\n\nfunction Multipart (request) {\n  this.request = request\n  this.boundary = uuid()\n  this.chunked = false\n  this.body = null\n}\n\nMultipart.prototype.isChunked = function (options) {\n  var self = this\n    , chunked = false\n    , parts = options.data || options\n\n  if (!parts.forEach) {\n    self.request.emit('error', new Error('Argument error, options.multipart.'))\n  }\n\n  if (options.chunked !== undefined) {\n    chunked = options.chunked\n  }\n\n  if (self.request.getHeader('transfer-encoding') === 'chunked') {\n    chunked = true\n  }\n\n  if (!chunked) {\n    parts.forEach(function (part) {\n      if (typeof part.body === 'undefined') {\n        self.request.emit('error', new Error('Body attribute missing in multipart.'))\n      }\n      if (isstream(part.body)) {\n        chunked = true\n      }\n    })\n  }\n\n  return chunked\n}\n\nMultipart.prototype.setHeaders = function (chunked) {\n  var self = this\n\n  if (chunked && !self.request.hasHeader('transfer-encoding')) {\n    self.request.setHeader('transfer-encoding', 'chunked')\n  }\n\n  var header = self.request.getHeader('content-type')\n\n  if (!header || header.indexOf('multipart') === -1) {\n    self.request.setHeader('content-type', 'multipart/related; boundary=' + self.boundary)\n  } else {\n    if (header.indexOf('boundary') !== -1) {\n      self.boundary = header.replace(/.*boundary=([^\\s;]+).*/, '$1')\n    } else {\n      self.request.setHeader('content-type', header + '; boundary=' + self.boundary)\n    }\n  }\n}\n\nMultipart.prototype.build = function (parts, chunked) {\n  var self = this\n  var body = chunked ? new CombinedStream() : []\n\n  function add (part) {\n    if (typeof part === 'number') {\n      part = part.toString()\n    }\n    return chunked ? body.append(part) : body.push(new Buffer(part))\n  }\n\n  if (self.request.preambleCRLF) {\n    add('\\r\\n')\n  }\n\n  parts.forEach(function (part) {\n    var preamble = '--' + self.boundary + '\\r\\n'\n    Object.keys(part).forEach(function (key) {\n      if (key === 'body') { return }\n      preamble += key + ': ' + part[key] + '\\r\\n'\n    })\n    preamble += '\\r\\n'\n    add(preamble)\n    add(part.body)\n    add('\\r\\n')\n  })\n  add('--' + self.boundary + '--')\n\n  if (self.request.postambleCRLF) {\n    add('\\r\\n')\n  }\n\n  return body\n}\n\nMultipart.prototype.onRequest = function (options) {\n  var self = this\n\n  var chunked = self.isChunked(options)\n    , parts = options.data || options\n\n  self.setHeaders(chunked)\n  self.chunked = chunked\n  self.body = self.build(parts, chunked)\n}\n\nexports.Multipart = Multipart\n","/home/travis/build/npmtest/node-npmtest-auto-install/auto-install/node_modules/request/lib/redirect.js":"'use strict'\n\nvar url = require('url')\nvar isUrl = /^https?:/\n\nfunction Redirect (request) {\n  this.request = request\n  this.followRedirect = true\n  this.followRedirects = true\n  this.followAllRedirects = false\n  this.allowRedirect = function () {return true}\n  this.maxRedirects = 10\n  this.redirects = []\n  this.redirectsFollowed = 0\n  this.removeRefererHeader = false\n}\n\nRedirect.prototype.onRequest = function (options) {\n  var self = this\n\n  if (options.maxRedirects !== undefined) {\n    self.maxRedirects = options.maxRedirects\n  }\n  if (typeof options.followRedirect === 'function') {\n    self.allowRedirect = options.followRedirect\n  }\n  if (options.followRedirect !== undefined) {\n    self.followRedirects = !!options.followRedirect\n  }\n  if (options.followAllRedirects !== undefined) {\n    self.followAllRedirects = options.followAllRedirects\n  }\n  if (self.followRedirects || self.followAllRedirects) {\n    self.redirects = self.redirects || []\n  }\n  if (options.removeRefererHeader !== undefined) {\n    self.removeRefererHeader = options.removeRefererHeader\n  }\n}\n\nRedirect.prototype.redirectTo = function (response) {\n  var self = this\n    , request = self.request\n\n  var redirectTo = null\n  if (response.statusCode >= 300 && response.statusCode < 400 && response.caseless.has('location')) {\n    var location = response.caseless.get('location')\n    request.debug('redirect', location)\n\n    if (self.followAllRedirects) {\n      redirectTo = location\n    } else if (self.followRedirects) {\n      switch (request.method) {\n        case 'PATCH':\n        case 'PUT':\n        case 'POST':\n        case 'DELETE':\n          // Do not follow redirects\n          break\n        default:\n          redirectTo = location\n          break\n      }\n    }\n  } else if (response.statusCode === 401) {\n    var authHeader = request._auth.onResponse(response)\n    if (authHeader) {\n      request.setHeader('authorization', authHeader)\n      redirectTo = request.uri\n    }\n  }\n  return redirectTo\n}\n\nRedirect.prototype.onResponse = function (response) {\n  var self = this\n    , request = self.request\n\n  var redirectTo = self.redirectTo(response)\n  if (!redirectTo || !self.allowRedirect.call(request, response)) {\n    return false\n  }\n\n  request.debug('redirect to', redirectTo)\n\n  // ignore any potential response body.  it cannot possibly be useful\n  // to us at this point.\n  // response.resume should be defined, but check anyway before calling. Workaround for browserify.\n  if (response.resume) {\n    response.resume()\n  }\n\n  if (self.redirectsFollowed >= self.maxRedirects) {\n    request.emit('error', new Error('Exceeded maxRedirects. Probably stuck in a redirect loop ' + request.uri.href))\n    return false\n  }\n  self.redirectsFollowed += 1\n\n  if (!isUrl.test(redirectTo)) {\n    redirectTo = url.resolve(request.uri.href, redirectTo)\n  }\n\n  var uriPrev = request.uri\n  request.uri = url.parse(redirectTo)\n\n  // handle the case where we change protocol from https to http or vice versa\n  if (request.uri.protocol !== uriPrev.protocol) {\n    delete request.agent\n  }\n\n  self.redirects.push(\n    { statusCode : response.statusCode\n    , redirectUri: redirectTo\n    }\n  )\n  if (self.followAllRedirects && request.method !== 'HEAD'\n    && response.statusCode !== 401 && response.statusCode !== 307) {\n    request.method = 'GET'\n  }\n  // request.method = 'GET' // Force all redirects to use GET || commented out fixes #215\n  delete request.src\n  delete request.req\n  delete request._started\n  if (response.statusCode !== 401 && response.statusCode !== 307) {\n    // Remove parameters from the previous response, unless this is the second request\n    // for a server that requires digest authentication.\n    delete request.body\n    delete request._form\n    if (request.headers) {\n      request.removeHeader('host')\n      request.removeHeader('content-type')\n      request.removeHeader('content-length')\n      if (request.uri.hostname !== request.originalHost.split(':')[0]) {\n        // Remove authorization if changing hostnames (but not if just\n        // changing ports or protocols).  This matches the behavior of curl:\n        // https://github.com/bagder/curl/blob/6beb0eee/lib/http.c#L710\n        request.removeHeader('authorization')\n      }\n    }\n  }\n\n  if (!self.removeRefererHeader) {\n    request.setHeader('referer', uriPrev.href)\n  }\n\n  request.emit('redirect')\n\n  request.init()\n\n  return true\n}\n\nexports.Redirect = Redirect\n","/home/travis/build/npmtest/node-npmtest-auto-install/auto-install/node_modules/request/lib/tunnel.js":"'use strict'\n\nvar url = require('url')\n  , tunnel = require('tunnel-agent')\n\nvar defaultProxyHeaderWhiteList = [\n  'accept',\n  'accept-charset',\n  'accept-encoding',\n  'accept-language',\n  'accept-ranges',\n  'cache-control',\n  'content-encoding',\n  'content-language',\n  'content-location',\n  'content-md5',\n  'content-range',\n  'content-type',\n  'connection',\n  'date',\n  'expect',\n  'max-forwards',\n  'pragma',\n  'referer',\n  'te',\n  'user-agent',\n  'via'\n]\n\nvar defaultProxyHeaderExclusiveList = [\n  'proxy-authorization'\n]\n\nfunction constructProxyHost(uriObject) {\n  var port = uriObject.port\n    , protocol = uriObject.protocol\n    , proxyHost = uriObject.hostname + ':'\n\n  if (port) {\n    proxyHost += port\n  } else if (protocol === 'https:') {\n    proxyHost += '443'\n  } else {\n    proxyHost += '80'\n  }\n\n  return proxyHost\n}\n\nfunction constructProxyHeaderWhiteList(headers, proxyHeaderWhiteList) {\n  var whiteList = proxyHeaderWhiteList\n    .reduce(function (set, header) {\n      set[header.toLowerCase()] = true\n      return set\n    }, {})\n\n  return Object.keys(headers)\n    .filter(function (header) {\n      return whiteList[header.toLowerCase()]\n    })\n    .reduce(function (set, header) {\n      set[header] = headers[header]\n      return set\n    }, {})\n}\n\nfunction constructTunnelOptions (request, proxyHeaders) {\n  var proxy = request.proxy\n\n  var tunnelOptions = {\n    proxy : {\n      host      : proxy.hostname,\n      port      : +proxy.port,\n      proxyAuth : proxy.auth,\n      headers   : proxyHeaders\n    },\n    headers            : request.headers,\n    ca                 : request.ca,\n    cert               : request.cert,\n    key                : request.key,\n    passphrase         : request.passphrase,\n    pfx                : request.pfx,\n    ciphers            : request.ciphers,\n    rejectUnauthorized : request.rejectUnauthorized,\n    secureOptions      : request.secureOptions,\n    secureProtocol     : request.secureProtocol\n  }\n\n  return tunnelOptions\n}\n\nfunction constructTunnelFnName(uri, proxy) {\n  var uriProtocol = (uri.protocol === 'https:' ? 'https' : 'http')\n  var proxyProtocol = (proxy.protocol === 'https:' ? 'Https' : 'Http')\n  return [uriProtocol, proxyProtocol].join('Over')\n}\n\nfunction getTunnelFn(request) {\n  var uri = request.uri\n  var proxy = request.proxy\n  var tunnelFnName = constructTunnelFnName(uri, proxy)\n  return tunnel[tunnelFnName]\n}\n\n\nfunction Tunnel (request) {\n  this.request = request\n  this.proxyHeaderWhiteList = defaultProxyHeaderWhiteList\n  this.proxyHeaderExclusiveList = []\n  if (typeof request.tunnel !== 'undefined') {\n    this.tunnelOverride = request.tunnel\n  }\n}\n\nTunnel.prototype.isEnabled = function () {\n  var self = this\n    , request = self.request\n  // Tunnel HTTPS by default. Allow the user to override this setting.\n\n  // If self.tunnelOverride is set (the user specified a value), use it.\n  if (typeof self.tunnelOverride !== 'undefined') {\n    return self.tunnelOverride\n  }\n\n  // If the destination is HTTPS, tunnel.\n  if (request.uri.protocol === 'https:') {\n    return true\n  }\n\n  // Otherwise, do not use tunnel.\n  return false\n}\n\nTunnel.prototype.setup = function (options) {\n  var self = this\n    , request = self.request\n\n  options = options || {}\n\n  if (typeof request.proxy === 'string') {\n    request.proxy = url.parse(request.proxy)\n  }\n\n  if (!request.proxy || !request.tunnel) {\n    return false\n  }\n\n  // Setup Proxy Header Exclusive List and White List\n  if (options.proxyHeaderWhiteList) {\n    self.proxyHeaderWhiteList = options.proxyHeaderWhiteList\n  }\n  if (options.proxyHeaderExclusiveList) {\n    self.proxyHeaderExclusiveList = options.proxyHeaderExclusiveList\n  }\n\n  var proxyHeaderExclusiveList = self.proxyHeaderExclusiveList.concat(defaultProxyHeaderExclusiveList)\n  var proxyHeaderWhiteList = self.proxyHeaderWhiteList.concat(proxyHeaderExclusiveList)\n\n  // Setup Proxy Headers and Proxy Headers Host\n  // Only send the Proxy White Listed Header names\n  var proxyHeaders = constructProxyHeaderWhiteList(request.headers, proxyHeaderWhiteList)\n  proxyHeaders.host = constructProxyHost(request.uri)\n\n  proxyHeaderExclusiveList.forEach(request.removeHeader, request)\n\n  // Set Agent from Tunnel Data\n  var tunnelFn = getTunnelFn(request)\n  var tunnelOptions = constructTunnelOptions(request, proxyHeaders)\n  request.agent = tunnelFn(tunnelOptions)\n\n  return true\n}\n\nTunnel.defaultProxyHeaderWhiteList = defaultProxyHeaderWhiteList\nTunnel.defaultProxyHeaderExclusiveList = defaultProxyHeaderExclusiveList\nexports.Tunnel = Tunnel\n","/home/travis/build/npmtest/node-npmtest-auto-install/auto-install/node_modules/tunnel-agent/index.js":"'use strict'\n\nvar net = require('net')\n  , tls = require('tls')\n  , http = require('http')\n  , https = require('https')\n  , events = require('events')\n  , assert = require('assert')\n  , util = require('util')\n  ;\n\nexports.httpOverHttp = httpOverHttp\nexports.httpsOverHttp = httpsOverHttp\nexports.httpOverHttps = httpOverHttps\nexports.httpsOverHttps = httpsOverHttps\n\n\nfunction httpOverHttp(options) {\n  var agent = new TunnelingAgent(options)\n  agent.request = http.request\n  return agent\n}\n\nfunction httpsOverHttp(options) {\n  var agent = new TunnelingAgent(options)\n  agent.request = http.request\n  agent.createSocket = createSecureSocket\n  agent.defaultPort = 443\n  return agent\n}\n\nfunction httpOverHttps(options) {\n  var agent = new TunnelingAgent(options)\n  agent.request = https.request\n  return agent\n}\n\nfunction httpsOverHttps(options) {\n  var agent = new TunnelingAgent(options)\n  agent.request = https.request\n  agent.createSocket = createSecureSocket\n  agent.defaultPort = 443\n  return agent\n}\n\n\nfunction TunnelingAgent(options) {\n  var self = this\n  self.options = options || {}\n  self.proxyOptions = self.options.proxy || {}\n  self.maxSockets = self.options.maxSockets || http.Agent.defaultMaxSockets\n  self.requests = []\n  self.sockets = []\n\n  self.on('free', function onFree(socket, host, port) {\n    for (var i = 0, len = self.requests.length; i < len; ++i) {\n      var pending = self.requests[i]\n      if (pending.host === host && pending.port === port) {\n        // Detect the request to connect same origin server,\n        // reuse the connection.\n        self.requests.splice(i, 1)\n        pending.request.onSocket(socket)\n        return\n      }\n    }\n    socket.destroy()\n    self.removeSocket(socket)\n  })\n}\nutil.inherits(TunnelingAgent, events.EventEmitter)\n\nTunnelingAgent.prototype.addRequest = function addRequest(req, options) {\n  var self = this\n\n   // Legacy API: addRequest(req, host, port, path)\n  if (typeof options === 'string') {\n    options = {\n      host: options,\n      port: arguments[2],\n      path: arguments[3]\n    };\n  }\n\n  if (self.sockets.length >= this.maxSockets) {\n    // We are over limit so we'll add it to the queue.\n    self.requests.push({host: options.host, port: options.port, request: req})\n    return\n  }\n\n  // If we are under maxSockets create a new one.\n  self.createConnection({host: options.host, port: options.port, request: req})\n}\n\nTunnelingAgent.prototype.createConnection = function createConnection(pending) {\n  var self = this\n\n  self.createSocket(pending, function(socket) {\n    socket.on('free', onFree)\n    socket.on('close', onCloseOrRemove)\n    socket.on('agentRemove', onCloseOrRemove)\n    pending.request.onSocket(socket)\n\n    function onFree() {\n      self.emit('free', socket, pending.host, pending.port)\n    }\n\n    function onCloseOrRemove(err) {\n      self.removeSocket(socket)\n      socket.removeListener('free', onFree)\n      socket.removeListener('close', onCloseOrRemove)\n      socket.removeListener('agentRemove', onCloseOrRemove)\n    }\n  })\n}\n\nTunnelingAgent.prototype.createSocket = function createSocket(options, cb) {\n  var self = this\n  var placeholder = {}\n  self.sockets.push(placeholder)\n\n  var connectOptions = mergeOptions({}, self.proxyOptions, \n    { method: 'CONNECT'\n    , path: options.host + ':' + options.port\n    , agent: false\n    }\n  )\n  if (connectOptions.proxyAuth) {\n    connectOptions.headers = connectOptions.headers || {}\n    connectOptions.headers['Proxy-Authorization'] = 'Basic ' +\n        new Buffer(connectOptions.proxyAuth).toString('base64')\n  }\n\n  debug('making CONNECT request')\n  var connectReq = self.request(connectOptions)\n  connectReq.useChunkedEncodingByDefault = false // for v0.6\n  connectReq.once('response', onResponse) // for v0.6\n  connectReq.once('upgrade', onUpgrade)   // for v0.6\n  connectReq.once('connect', onConnect)   // for v0.7 or later\n  connectReq.once('error', onError)\n  connectReq.end()\n\n  function onResponse(res) {\n    // Very hacky. This is necessary to avoid http-parser leaks.\n    res.upgrade = true\n  }\n\n  function onUpgrade(res, socket, head) {\n    // Hacky.\n    process.nextTick(function() {\n      onConnect(res, socket, head)\n    })\n  }\n\n  function onConnect(res, socket, head) {\n    connectReq.removeAllListeners()\n    socket.removeAllListeners()\n\n    if (res.statusCode === 200) {\n      assert.equal(head.length, 0)\n      debug('tunneling connection has established')\n      self.sockets[self.sockets.indexOf(placeholder)] = socket\n      cb(socket)\n    } else {\n      debug('tunneling socket could not be established, statusCode=%d', res.statusCode)\n      var error = new Error('tunneling socket could not be established, ' + 'statusCode=' + res.statusCode)\n      error.code = 'ECONNRESET'\n      options.request.emit('error', error)\n      self.removeSocket(placeholder)\n    }\n  }\n\n  function onError(cause) {\n    connectReq.removeAllListeners()\n\n    debug('tunneling socket could not be established, cause=%s\\n', cause.message, cause.stack)\n    var error = new Error('tunneling socket could not be established, ' + 'cause=' + cause.message)\n    error.code = 'ECONNRESET'\n    options.request.emit('error', error)\n    self.removeSocket(placeholder)\n  }\n}\n\nTunnelingAgent.prototype.removeSocket = function removeSocket(socket) {\n  var pos = this.sockets.indexOf(socket)\n  if (pos === -1) return\n  \n  this.sockets.splice(pos, 1)\n\n  var pending = this.requests.shift()\n  if (pending) {\n    // If we have pending requests and a socket gets closed a new one\n    // needs to be created to take over in the pool for the one that closed.\n    this.createConnection(pending)\n  }\n}\n\nfunction createSecureSocket(options, cb) {\n  var self = this\n  TunnelingAgent.prototype.createSocket.call(self, options, function(socket) {\n    // 0 is dummy port for v0.6\n    var secureSocket = tls.connect(0, mergeOptions({}, self.options, \n      { servername: options.host\n      , socket: socket\n      }\n    ))\n    self.sockets[self.sockets.indexOf(socket)] = secureSocket\n    cb(secureSocket)\n  })\n}\n\n\nfunction mergeOptions(target) {\n  for (var i = 1, len = arguments.length; i < len; ++i) {\n    var overrides = arguments[i]\n    if (typeof overrides === 'object') {\n      var keys = Object.keys(overrides)\n      for (var j = 0, keyLen = keys.length; j < keyLen; ++j) {\n        var k = keys[j]\n        if (overrides[k] !== undefined) {\n          target[k] = overrides[k]\n        }\n      }\n    }\n  }\n  return target\n}\n\n\nvar debug\nif (process.env.NODE_DEBUG && /\\btunnel\\b/.test(process.env.NODE_DEBUG)) {\n  debug = function() {\n    var args = Array.prototype.slice.call(arguments)\n    if (typeof args[0] === 'string') {\n      args[0] = 'TUNNEL: ' + args[0]\n    } else {\n      args.unshift('TUNNEL:')\n    }\n    console.error.apply(console, args)\n  }\n} else {\n  debug = function() {}\n}\nexports.debug = debug // for test\n","/home/travis/build/npmtest/node-npmtest-auto-install/auto-install/node_modules/detective/index.js":"var acorn = require('acorn');\nvar walk = require('acorn/dist/walk');\nvar defined = require('defined');\n\nvar requireRe = /\\brequire\\b/;\n\nfunction parse (src, opts) {\n    if (!opts) opts = {};\n    return acorn.parse(src, {\n        ecmaVersion: defined(opts.ecmaVersion, 6),\n        sourceType: opts.sourceType,\n        ranges: defined(opts.ranges, opts.range),\n        locations: defined(opts.locations, opts.loc),\n        allowReserved: defined(opts.allowReserved, true),\n        allowReturnOutsideFunction: defined(\n            opts.allowReturnOutsideFunction, true\n        ),\n        allowHashBang: defined(opts.allowHashBang, true)\n    });\n}\n\nvar exports = module.exports = function (src, opts) {\n    return exports.find(src, opts).strings;\n};\n\nexports.find = function (src, opts) {\n    if (!opts) opts = {};\n    \n    var word = opts.word === undefined ? 'require' : opts.word;\n    if (typeof src !== 'string') src = String(src);\n    \n    var isRequire = opts.isRequire || function (node) {\n        return node.callee.type === 'Identifier'\n            && node.callee.name === word\n        ;\n    };\n    \n    var modules = { strings : [], expressions : [] };\n    if (opts.nodes) modules.nodes = [];\n    \n    var wordRe = word === 'require' ? requireRe : RegExp('\\\\b' + word + '\\\\b');\n    if (!wordRe.test(src)) return modules;\n    \n    var ast = parse(src, opts.parse);\n    \n    function visit(node, st, c) {\n        var hasRequire = wordRe.test(src.slice(node.start, node.end));\n        if (!hasRequire) return;\n        walk.base[node.type](node, st, c);\n        if (node.type !== 'CallExpression') return;\n        if (isRequire(node)) {\n            if (node.arguments.length) {\n                var arg = node.arguments[0];\n                if (arg.type === 'Literal') {\n                    modules.strings.push(arg.value);\n                }\n                else {\n                    modules.expressions.push(src.slice(arg.start, arg.end));\n                }\n            }\n            if (opts.nodes) modules.nodes.push(node);\n        }\n    }\n    \n    walk.recursive(ast, null, {\n        Statement: visit,\n        Expression: visit\n    });\n    \n    return modules;\n};\n","/home/travis/build/npmtest/node-npmtest-auto-install/auto-install/node_modules/acorn/dist/acorn.js":"(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n  typeof define === 'function' && define.amd ? define(['exports'], factory) :\n  (factory((global.acorn = global.acorn || {})));\n}(this, function (exports) { 'use strict';\n\n  // Reserved word lists for various dialects of the language\n\n  var reservedWords = {\n    3: \"abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile\",\n    5: \"class enum extends super const export import\",\n    6: \"enum\",\n    7: \"enum\",\n    strict: \"implements interface let package private protected public static yield\",\n    strictBind: \"eval arguments\"\n  }\n\n  // And the keywords\n\n  var ecma5AndLessKeywords = \"break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this\"\n\n  var keywords = {\n    5: ecma5AndLessKeywords,\n    6: ecma5AndLessKeywords + \" const class extends export import super\"\n  }\n\n  // ## Character categories\n\n  // Big ugly regular expressions that match characters in the\n  // whitespace, identifier, and identifier-start categories. These\n  // are only applied when a character is found to actually have a\n  // code point above 128.\n  // Generated by `bin/generate-identifier-regex.js`.\n\n  var nonASCIIidentifierStartChars = \"\\xaa\\xb5\\xba\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u02c1\\u02c6-\\u02d1\\u02e0-\\u02e4\\u02ec\\u02ee\\u0370-\\u0374\\u0376\\u0377\\u037a-\\u037d\\u037f\\u0386\\u0388-\\u038a\\u038c\\u038e-\\u03a1\\u03a3-\\u03f5\\u03f7-\\u0481\\u048a-\\u052f\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u05d0-\\u05ea\\u05f0-\\u05f2\\u0620-\\u064a\\u066e\\u066f\\u0671-\\u06d3\\u06d5\\u06e5\\u06e6\\u06ee\\u06ef\\u06fa-\\u06fc\\u06ff\\u0710\\u0712-\\u072f\\u074d-\\u07a5\\u07b1\\u07ca-\\u07ea\\u07f4\\u07f5\\u07fa\\u0800-\\u0815\\u081a\\u0824\\u0828\\u0840-\\u0858\\u08a0-\\u08b4\\u08b6-\\u08bd\\u0904-\\u0939\\u093d\\u0950\\u0958-\\u0961\\u0971-\\u0980\\u0985-\\u098c\\u098f\\u0990\\u0993-\\u09a8\\u09aa-\\u09b0\\u09b2\\u09b6-\\u09b9\\u09bd\\u09ce\\u09dc\\u09dd\\u09df-\\u09e1\\u09f0\\u09f1\\u0a05-\\u0a0a\\u0a0f\\u0a10\\u0a13-\\u0a28\\u0a2a-\\u0a30\\u0a32\\u0a33\\u0a35\\u0a36\\u0a38\\u0a39\\u0a59-\\u0a5c\\u0a5e\\u0a72-\\u0a74\\u0a85-\\u0a8d\\u0a8f-\\u0a91\\u0a93-\\u0aa8\\u0aaa-\\u0ab0\\u0ab2\\u0ab3\\u0ab5-\\u0ab9\\u0abd\\u0ad0\\u0ae0\\u0ae1\\u0af9\\u0b05-\\u0b0c\\u0b0f\\u0b10\\u0b13-\\u0b28\\u0b2a-\\u0b30\\u0b32\\u0b33\\u0b35-\\u0b39\\u0b3d\\u0b5c\\u0b5d\\u0b5f-\\u0b61\\u0b71\\u0b83\\u0b85-\\u0b8a\\u0b8e-\\u0b90\\u0b92-\\u0b95\\u0b99\\u0b9a\\u0b9c\\u0b9e\\u0b9f\\u0ba3\\u0ba4\\u0ba8-\\u0baa\\u0bae-\\u0bb9\\u0bd0\\u0c05-\\u0c0c\\u0c0e-\\u0c10\\u0c12-\\u0c28\\u0c2a-\\u0c39\\u0c3d\\u0c58-\\u0c5a\\u0c60\\u0c61\\u0c80\\u0c85-\\u0c8c\\u0c8e-\\u0c90\\u0c92-\\u0ca8\\u0caa-\\u0cb3\\u0cb5-\\u0cb9\\u0cbd\\u0cde\\u0ce0\\u0ce1\\u0cf1\\u0cf2\\u0d05-\\u0d0c\\u0d0e-\\u0d10\\u0d12-\\u0d3a\\u0d3d\\u0d4e\\u0d54-\\u0d56\\u0d5f-\\u0d61\\u0d7a-\\u0d7f\\u0d85-\\u0d96\\u0d9a-\\u0db1\\u0db3-\\u0dbb\\u0dbd\\u0dc0-\\u0dc6\\u0e01-\\u0e30\\u0e32\\u0e33\\u0e40-\\u0e46\\u0e81\\u0e82\\u0e84\\u0e87\\u0e88\\u0e8a\\u0e8d\\u0e94-\\u0e97\\u0e99-\\u0e9f\\u0ea1-\\u0ea3\\u0ea5\\u0ea7\\u0eaa\\u0eab\\u0ead-\\u0eb0\\u0eb2\\u0eb3\\u0ebd\\u0ec0-\\u0ec4\\u0ec6\\u0edc-\\u0edf\\u0f00\\u0f40-\\u0f47\\u0f49-\\u0f6c\\u0f88-\\u0f8c\\u1000-\\u102a\\u103f\\u1050-\\u1055\\u105a-\\u105d\\u1061\\u1065\\u1066\\u106e-\\u1070\\u1075-\\u1081\\u108e\\u10a0-\\u10c5\\u10c7\\u10cd\\u10d0-\\u10fa\\u10fc-\\u1248\\u124a-\\u124d\\u1250-\\u1256\\u1258\\u125a-\\u125d\\u1260-\\u1288\\u128a-\\u128d\\u1290-\\u12b0\\u12b2-\\u12b5\\u12b8-\\u12be\\u12c0\\u12c2-\\u12c5\\u12c8-\\u12d6\\u12d8-\\u1310\\u1312-\\u1315\\u1318-\\u135a\\u1380-\\u138f\\u13a0-\\u13f5\\u13f8-\\u13fd\\u1401-\\u166c\\u166f-\\u167f\\u1681-\\u169a\\u16a0-\\u16ea\\u16ee-\\u16f8\\u1700-\\u170c\\u170e-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176c\\u176e-\\u1770\\u1780-\\u17b3\\u17d7\\u17dc\\u1820-\\u1877\\u1880-\\u18a8\\u18aa\\u18b0-\\u18f5\\u1900-\\u191e\\u1950-\\u196d\\u1970-\\u1974\\u1980-\\u19ab\\u19b0-\\u19c9\\u1a00-\\u1a16\\u1a20-\\u1a54\\u1aa7\\u1b05-\\u1b33\\u1b45-\\u1b4b\\u1b83-\\u1ba0\\u1bae\\u1baf\\u1bba-\\u1be5\\u1c00-\\u1c23\\u1c4d-\\u1c4f\\u1c5a-\\u1c7d\\u1c80-\\u1c88\\u1ce9-\\u1cec\\u1cee-\\u1cf1\\u1cf5\\u1cf6\\u1d00-\\u1dbf\\u1e00-\\u1f15\\u1f18-\\u1f1d\\u1f20-\\u1f45\\u1f48-\\u1f4d\\u1f50-\\u1f57\\u1f59\\u1f5b\\u1f5d\\u1f5f-\\u1f7d\\u1f80-\\u1fb4\\u1fb6-\\u1fbc\\u1fbe\\u1fc2-\\u1fc4\\u1fc6-\\u1fcc\\u1fd0-\\u1fd3\\u1fd6-\\u1fdb\\u1fe0-\\u1fec\\u1ff2-\\u1ff4\\u1ff6-\\u1ffc\\u2071\\u207f\\u2090-\\u209c\\u2102\\u2107\\u210a-\\u2113\\u2115\\u2118-\\u211d\\u2124\\u2126\\u2128\\u212a-\\u2139\\u213c-\\u213f\\u2145-\\u2149\\u214e\\u2160-\\u2188\\u2c00-\\u2c2e\\u2c30-\\u2c5e\\u2c60-\\u2ce4\\u2ceb-\\u2cee\\u2cf2\\u2cf3\\u2d00-\\u2d25\\u2d27\\u2d2d\\u2d30-\\u2d67\\u2d6f\\u2d80-\\u2d96\\u2da0-\\u2da6\\u2da8-\\u2dae\\u2db0-\\u2db6\\u2db8-\\u2dbe\\u2dc0-\\u2dc6\\u2dc8-\\u2dce\\u2dd0-\\u2dd6\\u2dd8-\\u2dde\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303c\\u3041-\\u3096\\u309b-\\u309f\\u30a1-\\u30fa\\u30fc-\\u30ff\\u3105-\\u312d\\u3131-\\u318e\\u31a0-\\u31ba\\u31f0-\\u31ff\\u3400-\\u4db5\\u4e00-\\u9fd5\\ua000-\\ua48c\\ua4d0-\\ua4fd\\ua500-\\ua60c\\ua610-\\ua61f\\ua62a\\ua62b\\ua640-\\ua66e\\ua67f-\\ua69d\\ua6a0-\\ua6ef\\ua717-\\ua71f\\ua722-\\ua788\\ua78b-\\ua7ae\\ua7b0-\\ua7b7\\ua7f7-\\ua801\\ua803-\\ua805\\ua807-\\ua80a\\ua80c-\\ua822\\ua840-\\ua873\\ua882-\\ua8b3\\ua8f2-\\ua8f7\\ua8fb\\ua8fd\\ua90a-\\ua925\\ua930-\\ua946\\ua960-\\ua97c\\ua984-\\ua9b2\\ua9cf\\ua9e0-\\ua9e4\\ua9e6-\\ua9ef\\ua9fa-\\ua9fe\\uaa00-\\uaa28\\uaa40-\\uaa42\\uaa44-\\uaa4b\\uaa60-\\uaa76\\uaa7a\\uaa7e-\\uaaaf\\uaab1\\uaab5\\uaab6\\uaab9-\\uaabd\\uaac0\\uaac2\\uaadb-\\uaadd\\uaae0-\\uaaea\\uaaf2-\\uaaf4\\uab01-\\uab06\\uab09-\\uab0e\\uab11-\\uab16\\uab20-\\uab26\\uab28-\\uab2e\\uab30-\\uab5a\\uab5c-\\uab65\\uab70-\\uabe2\\uac00-\\ud7a3\\ud7b0-\\ud7c6\\ud7cb-\\ud7fb\\uf900-\\ufa6d\\ufa70-\\ufad9\\ufb00-\\ufb06\\ufb13-\\ufb17\\ufb1d\\ufb1f-\\ufb28\\ufb2a-\\ufb36\\ufb38-\\ufb3c\\ufb3e\\ufb40\\ufb41\\ufb43\\ufb44\\ufb46-\\ufbb1\\ufbd3-\\ufd3d\\ufd50-\\ufd8f\\ufd92-\\ufdc7\\ufdf0-\\ufdfb\\ufe70-\\ufe74\\ufe76-\\ufefc\\uff21-\\uff3a\\uff41-\\uff5a\\uff66-\\uffbe\\uffc2-\\uffc7\\uffca-\\uffcf\\uffd2-\\uffd7\\uffda-\\uffdc\"\n  var nonASCIIidentifierChars = \"\\u200c\\u200d\\xb7\\u0300-\\u036f\\u0387\\u0483-\\u0487\\u0591-\\u05bd\\u05bf\\u05c1\\u05c2\\u05c4\\u05c5\\u05c7\\u0610-\\u061a\\u064b-\\u0669\\u0670\\u06d6-\\u06dc\\u06df-\\u06e4\\u06e7\\u06e8\\u06ea-\\u06ed\\u06f0-\\u06f9\\u0711\\u0730-\\u074a\\u07a6-\\u07b0\\u07c0-\\u07c9\\u07eb-\\u07f3\\u0816-\\u0819\\u081b-\\u0823\\u0825-\\u0827\\u0829-\\u082d\\u0859-\\u085b\\u08d4-\\u08e1\\u08e3-\\u0903\\u093a-\\u093c\\u093e-\\u094f\\u0951-\\u0957\\u0962\\u0963\\u0966-\\u096f\\u0981-\\u0983\\u09bc\\u09be-\\u09c4\\u09c7\\u09c8\\u09cb-\\u09cd\\u09d7\\u09e2\\u09e3\\u09e6-\\u09ef\\u0a01-\\u0a03\\u0a3c\\u0a3e-\\u0a42\\u0a47\\u0a48\\u0a4b-\\u0a4d\\u0a51\\u0a66-\\u0a71\\u0a75\\u0a81-\\u0a83\\u0abc\\u0abe-\\u0ac5\\u0ac7-\\u0ac9\\u0acb-\\u0acd\\u0ae2\\u0ae3\\u0ae6-\\u0aef\\u0b01-\\u0b03\\u0b3c\\u0b3e-\\u0b44\\u0b47\\u0b48\\u0b4b-\\u0b4d\\u0b56\\u0b57\\u0b62\\u0b63\\u0b66-\\u0b6f\\u0b82\\u0bbe-\\u0bc2\\u0bc6-\\u0bc8\\u0bca-\\u0bcd\\u0bd7\\u0be6-\\u0bef\\u0c00-\\u0c03\\u0c3e-\\u0c44\\u0c46-\\u0c48\\u0c4a-\\u0c4d\\u0c55\\u0c56\\u0c62\\u0c63\\u0c66-\\u0c6f\\u0c81-\\u0c83\\u0cbc\\u0cbe-\\u0cc4\\u0cc6-\\u0cc8\\u0cca-\\u0ccd\\u0cd5\\u0cd6\\u0ce2\\u0ce3\\u0ce6-\\u0cef\\u0d01-\\u0d03\\u0d3e-\\u0d44\\u0d46-\\u0d48\\u0d4a-\\u0d4d\\u0d57\\u0d62\\u0d63\\u0d66-\\u0d6f\\u0d82\\u0d83\\u0dca\\u0dcf-\\u0dd4\\u0dd6\\u0dd8-\\u0ddf\\u0de6-\\u0def\\u0df2\\u0df3\\u0e31\\u0e34-\\u0e3a\\u0e47-\\u0e4e\\u0e50-\\u0e59\\u0eb1\\u0eb4-\\u0eb9\\u0ebb\\u0ebc\\u0ec8-\\u0ecd\\u0ed0-\\u0ed9\\u0f18\\u0f19\\u0f20-\\u0f29\\u0f35\\u0f37\\u0f39\\u0f3e\\u0f3f\\u0f71-\\u0f84\\u0f86\\u0f87\\u0f8d-\\u0f97\\u0f99-\\u0fbc\\u0fc6\\u102b-\\u103e\\u1040-\\u1049\\u1056-\\u1059\\u105e-\\u1060\\u1062-\\u1064\\u1067-\\u106d\\u1071-\\u1074\\u1082-\\u108d\\u108f-\\u109d\\u135d-\\u135f\\u1369-\\u1371\\u1712-\\u1714\\u1732-\\u1734\\u1752\\u1753\\u1772\\u1773\\u17b4-\\u17d3\\u17dd\\u17e0-\\u17e9\\u180b-\\u180d\\u1810-\\u1819\\u18a9\\u1920-\\u192b\\u1930-\\u193b\\u1946-\\u194f\\u19d0-\\u19da\\u1a17-\\u1a1b\\u1a55-\\u1a5e\\u1a60-\\u1a7c\\u1a7f-\\u1a89\\u1a90-\\u1a99\\u1ab0-\\u1abd\\u1b00-\\u1b04\\u1b34-\\u1b44\\u1b50-\\u1b59\\u1b6b-\\u1b73\\u1b80-\\u1b82\\u1ba1-\\u1bad\\u1bb0-\\u1bb9\\u1be6-\\u1bf3\\u1c24-\\u1c37\\u1c40-\\u1c49\\u1c50-\\u1c59\\u1cd0-\\u1cd2\\u1cd4-\\u1ce8\\u1ced\\u1cf2-\\u1cf4\\u1cf8\\u1cf9\\u1dc0-\\u1df5\\u1dfb-\\u1dff\\u203f\\u2040\\u2054\\u20d0-\\u20dc\\u20e1\\u20e5-\\u20f0\\u2cef-\\u2cf1\\u2d7f\\u2de0-\\u2dff\\u302a-\\u302f\\u3099\\u309a\\ua620-\\ua629\\ua66f\\ua674-\\ua67d\\ua69e\\ua69f\\ua6f0\\ua6f1\\ua802\\ua806\\ua80b\\ua823-\\ua827\\ua880\\ua881\\ua8b4-\\ua8c5\\ua8d0-\\ua8d9\\ua8e0-\\ua8f1\\ua900-\\ua909\\ua926-\\ua92d\\ua947-\\ua953\\ua980-\\ua983\\ua9b3-\\ua9c0\\ua9d0-\\ua9d9\\ua9e5\\ua9f0-\\ua9f9\\uaa29-\\uaa36\\uaa43\\uaa4c\\uaa4d\\uaa50-\\uaa59\\uaa7b-\\uaa7d\\uaab0\\uaab2-\\uaab4\\uaab7\\uaab8\\uaabe\\uaabf\\uaac1\\uaaeb-\\uaaef\\uaaf5\\uaaf6\\uabe3-\\uabea\\uabec\\uabed\\uabf0-\\uabf9\\ufb1e\\ufe00-\\ufe0f\\ufe20-\\ufe2f\\ufe33\\ufe34\\ufe4d-\\ufe4f\\uff10-\\uff19\\uff3f\"\n\n  var nonASCIIidentifierStart = new RegExp(\"[\" + nonASCIIidentifierStartChars + \"]\")\n  var nonASCIIidentifier = new RegExp(\"[\" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + \"]\")\n\n  nonASCIIidentifierStartChars = nonASCIIidentifierChars = null\n\n  // These are a run-length and offset encoded representation of the\n  // >0xffff code points that are a valid part of identifiers. The\n  // offset starts at 0x10000, and each pair of numbers represents an\n  // offset to the next range, and then a size of the range. They were\n  // generated by bin/generate-identifier-regex.js\n  var astralIdentifierStartCodes = [0,11,2,25,2,18,2,1,2,14,3,13,35,122,70,52,268,28,4,48,48,31,17,26,6,37,11,29,3,35,5,7,2,4,43,157,19,35,5,35,5,39,9,51,157,310,10,21,11,7,153,5,3,0,2,43,2,1,4,0,3,22,11,22,10,30,66,18,2,1,11,21,11,25,71,55,7,1,65,0,16,3,2,2,2,26,45,28,4,28,36,7,2,27,28,53,11,21,11,18,14,17,111,72,56,50,14,50,785,52,76,44,33,24,27,35,42,34,4,0,13,47,15,3,22,0,2,0,36,17,2,24,85,6,2,0,2,3,2,14,2,9,8,46,39,7,3,1,3,21,2,6,2,1,2,4,4,0,19,0,13,4,159,52,19,3,54,47,21,1,2,0,185,46,42,3,37,47,21,0,60,42,86,25,391,63,32,0,449,56,264,8,2,36,18,0,50,29,881,921,103,110,18,195,2749,1070,4050,582,8634,568,8,30,114,29,19,47,17,3,32,20,6,18,881,68,12,0,67,12,65,0,32,6124,20,754,9486,1,3071,106,6,12,4,8,8,9,5991,84,2,70,2,1,3,0,3,1,3,3,2,11,2,0,2,6,2,64,2,3,3,7,2,6,2,27,2,3,2,4,2,0,4,6,2,339,3,24,2,24,2,30,2,24,2,30,2,24,2,30,2,24,2,30,2,24,2,7,4149,196,60,67,1213,3,2,26,2,1,2,0,3,0,2,9,2,3,2,0,2,0,7,0,5,0,2,0,2,0,2,2,2,1,2,0,3,0,2,0,2,0,2,0,2,0,2,1,2,0,3,3,2,6,2,3,2,3,2,0,2,9,2,16,6,2,2,4,2,16,4421,42710,42,4148,12,221,3,5761,10591,541]\n  var astralIdentifierCodes = [509,0,227,0,150,4,294,9,1368,2,2,1,6,3,41,2,5,0,166,1,1306,2,54,14,32,9,16,3,46,10,54,9,7,2,37,13,2,9,52,0,13,2,49,13,10,2,4,9,83,11,7,0,161,11,6,9,7,3,57,0,2,6,3,1,3,2,10,0,11,1,3,6,4,4,193,17,10,9,87,19,13,9,214,6,3,8,28,1,83,16,16,9,82,12,9,9,84,14,5,9,423,9,838,7,2,7,17,9,57,21,2,13,19882,9,135,4,60,6,26,9,1016,45,17,3,19723,1,5319,4,4,5,9,7,3,6,31,3,149,2,1418,49,513,54,5,49,9,0,15,0,23,4,2,14,1361,6,2,16,3,6,2,1,2,4,2214,6,110,6,6,9,792487,239]\n\n  // This has a complexity linear to the value of the code. The\n  // assumption is that looking up astral identifier characters is\n  // rare.\n  function isInAstralSet(code, set) {\n    var pos = 0x10000\n    for (var i = 0; i < set.length; i += 2) {\n      pos += set[i]\n      if (pos > code) return false\n      pos += set[i + 1]\n      if (pos >= code) return true\n    }\n  }\n\n  // Test whether a given character code starts an identifier.\n\n  function isIdentifierStart(code, astral) {\n    if (code < 65) return code === 36\n    if (code < 91) return true\n    if (code < 97) return code === 95\n    if (code < 123) return true\n    if (code <= 0xffff) return code >= 0xaa && nonASCIIidentifierStart.test(String.fromCharCode(code))\n    if (astral === false) return false\n    return isInAstralSet(code, astralIdentifierStartCodes)\n  }\n\n  // Test whether a given character is part of an identifier.\n\n  function isIdentifierChar(code, astral) {\n    if (code < 48) return code === 36\n    if (code < 58) return true\n    if (code < 65) return false\n    if (code < 91) return true\n    if (code < 97) return code === 95\n    if (code < 123) return true\n    if (code <= 0xffff) return code >= 0xaa && nonASCIIidentifier.test(String.fromCharCode(code))\n    if (astral === false) return false\n    return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes)\n  }\n\n  // ## Token types\n\n  // The assignment of fine-grained, information-carrying type objects\n  // allows the tokenizer to store the information it has about a\n  // token in a way that is very cheap for the parser to look up.\n\n  // All token type variables start with an underscore, to make them\n  // easy to recognize.\n\n  // The `beforeExpr` property is used to disambiguate between regular\n  // expressions and divisions. It is set on all token types that can\n  // be followed by an expression (thus, a slash after them would be a\n  // regular expression).\n  //\n  // The `startsExpr` property is used to check if the token ends a\n  // `yield` expression. It is set on all token types that either can\n  // directly start an expression (like a quotation mark) or can\n  // continue an expression (like the body of a string).\n  //\n  // `isLoop` marks a keyword as starting a loop, which is important\n  // to know when parsing a label, in order to allow or disallow\n  // continue jumps to that label.\n\n  var TokenType = function TokenType(label, conf) {\n    if ( conf === void 0 ) conf = {};\n\n    this.label = label\n    this.keyword = conf.keyword\n    this.beforeExpr = !!conf.beforeExpr\n    this.startsExpr = !!conf.startsExpr\n    this.isLoop = !!conf.isLoop\n    this.isAssign = !!conf.isAssign\n    this.prefix = !!conf.prefix\n    this.postfix = !!conf.postfix\n    this.binop = conf.binop || null\n    this.updateContext = null\n  };\n\n  function binop(name, prec) {\n    return new TokenType(name, {beforeExpr: true, binop: prec})\n  }\n  var beforeExpr = {beforeExpr: true};\n  var startsExpr = {startsExpr: true};\n  // Map keyword names to token types.\n\n  var keywordTypes = {}\n\n  // Succinct definitions of keyword token types\n  function kw(name, options) {\n    if ( options === void 0 ) options = {};\n\n    options.keyword = name\n    return keywordTypes[name] = new TokenType(name, options)\n  }\n\n  var tt = {\n    num: new TokenType(\"num\", startsExpr),\n    regexp: new TokenType(\"regexp\", startsExpr),\n    string: new TokenType(\"string\", startsExpr),\n    name: new TokenType(\"name\", startsExpr),\n    eof: new TokenType(\"eof\"),\n\n    // Punctuation token types.\n    bracketL: new TokenType(\"[\", {beforeExpr: true, startsExpr: true}),\n    bracketR: new TokenType(\"]\"),\n    braceL: new TokenType(\"{\", {beforeExpr: true, startsExpr: true}),\n    braceR: new TokenType(\"}\"),\n    parenL: new TokenType(\"(\", {beforeExpr: true, startsExpr: true}),\n    parenR: new TokenType(\")\"),\n    comma: new TokenType(\",\", beforeExpr),\n    semi: new TokenType(\";\", beforeExpr),\n    colon: new TokenType(\":\", beforeExpr),\n    dot: new TokenType(\".\"),\n    question: new TokenType(\"?\", beforeExpr),\n    arrow: new TokenType(\"=>\", beforeExpr),\n    template: new TokenType(\"template\"),\n    ellipsis: new TokenType(\"...\", beforeExpr),\n    backQuote: new TokenType(\"`\", startsExpr),\n    dollarBraceL: new TokenType(\"${\", {beforeExpr: true, startsExpr: true}),\n\n    // Operators. These carry several kinds of properties to help the\n    // parser use them properly (the presence of these properties is\n    // what categorizes them as operators).\n    //\n    // `binop`, when present, specifies that this operator is a binary\n    // operator, and will refer to its precedence.\n    //\n    // `prefix` and `postfix` mark the operator as a prefix or postfix\n    // unary operator.\n    //\n    // `isAssign` marks all of `=`, `+=`, `-=` etcetera, which act as\n    // binary operators with a very low precedence, that should result\n    // in AssignmentExpression nodes.\n\n    eq: new TokenType(\"=\", {beforeExpr: true, isAssign: true}),\n    assign: new TokenType(\"_=\", {beforeExpr: true, isAssign: true}),\n    incDec: new TokenType(\"++/--\", {prefix: true, postfix: true, startsExpr: true}),\n    prefix: new TokenType(\"prefix\", {beforeExpr: true, prefix: true, startsExpr: true}),\n    logicalOR: binop(\"||\", 1),\n    logicalAND: binop(\"&&\", 2),\n    bitwiseOR: binop(\"|\", 3),\n    bitwiseXOR: binop(\"^\", 4),\n    bitwiseAND: binop(\"&\", 5),\n    equality: binop(\"==/!=\", 6),\n    relational: binop(\"</>\", 7),\n    bitShift: binop(\"<</>>\", 8),\n    plusMin: new TokenType(\"+/-\", {beforeExpr: true, binop: 9, prefix: true, startsExpr: true}),\n    modulo: binop(\"%\", 10),\n    star: binop(\"*\", 10),\n    slash: binop(\"/\", 10),\n    starstar: new TokenType(\"**\", {beforeExpr: true}),\n\n    // Keyword token types.\n    _break: kw(\"break\"),\n    _case: kw(\"case\", beforeExpr),\n    _catch: kw(\"catch\"),\n    _continue: kw(\"continue\"),\n    _debugger: kw(\"debugger\"),\n    _default: kw(\"default\", beforeExpr),\n    _do: kw(\"do\", {isLoop: true, beforeExpr: true}),\n    _else: kw(\"else\", beforeExpr),\n    _finally: kw(\"finally\"),\n    _for: kw(\"for\", {isLoop: true}),\n    _function: kw(\"function\", startsExpr),\n    _if: kw(\"if\"),\n    _return: kw(\"return\", beforeExpr),\n    _switch: kw(\"switch\"),\n    _throw: kw(\"throw\", beforeExpr),\n    _try: kw(\"try\"),\n    _var: kw(\"var\"),\n    _const: kw(\"const\"),\n    _while: kw(\"while\", {isLoop: true}),\n    _with: kw(\"with\"),\n    _new: kw(\"new\", {beforeExpr: true, startsExpr: true}),\n    _this: kw(\"this\", startsExpr),\n    _super: kw(\"super\", startsExpr),\n    _class: kw(\"class\"),\n    _extends: kw(\"extends\", beforeExpr),\n    _export: kw(\"export\"),\n    _import: kw(\"import\"),\n    _null: kw(\"null\", startsExpr),\n    _true: kw(\"true\", startsExpr),\n    _false: kw(\"false\", startsExpr),\n    _in: kw(\"in\", {beforeExpr: true, binop: 7}),\n    _instanceof: kw(\"instanceof\", {beforeExpr: true, binop: 7}),\n    _typeof: kw(\"typeof\", {beforeExpr: true, prefix: true, startsExpr: true}),\n    _void: kw(\"void\", {beforeExpr: true, prefix: true, startsExpr: true}),\n    _delete: kw(\"delete\", {beforeExpr: true, prefix: true, startsExpr: true})\n  }\n\n  // Matches a whole line break (where CRLF is considered a single\n  // line break). Used to count lines.\n\n  var lineBreak = /\\r\\n?|\\n|\\u2028|\\u2029/\n  var lineBreakG = new RegExp(lineBreak.source, \"g\")\n\n  function isNewLine(code) {\n    return code === 10 || code === 13 || code === 0x2028 || code == 0x2029\n  }\n\n  var nonASCIIwhitespace = /[\\u1680\\u180e\\u2000-\\u200a\\u202f\\u205f\\u3000\\ufeff]/\n\n  var skipWhiteSpace = /(?:\\s|\\/\\/.*|\\/\\*[^]*?\\*\\/)*/g\n\n  function isArray(obj) {\n    return Object.prototype.toString.call(obj) === \"[object Array]\"\n  }\n\n  // Checks if an object has a property.\n\n  function has(obj, propName) {\n    return Object.prototype.hasOwnProperty.call(obj, propName)\n  }\n\n  // These are used when `options.locations` is on, for the\n  // `startLoc` and `endLoc` properties.\n\n  var Position = function Position(line, col) {\n    this.line = line\n    this.column = col\n  };\n\n  Position.prototype.offset = function offset (n) {\n    return new Position(this.line, this.column + n)\n  };\n\n  var SourceLocation = function SourceLocation(p, start, end) {\n    this.start = start\n    this.end = end\n    if (p.sourceFile !== null) this.source = p.sourceFile\n  };\n\n  // The `getLineInfo` function is mostly useful when the\n  // `locations` option is off (for performance reasons) and you\n  // want to find the line/column position for a given character\n  // offset. `input` should be the code string that the offset refers\n  // into.\n\n  function getLineInfo(input, offset) {\n    for (var line = 1, cur = 0;;) {\n      lineBreakG.lastIndex = cur\n      var match = lineBreakG.exec(input)\n      if (match && match.index < offset) {\n        ++line\n        cur = match.index + match[0].length\n      } else {\n        return new Position(line, offset - cur)\n      }\n    }\n  }\n\n  // A second optional argument can be given to further configure\n  // the parser process. These options are recognized:\n\n  var defaultOptions = {\n    // `ecmaVersion` indicates the ECMAScript version to parse. Must\n    // be either 3, or 5, or 6. This influences support for strict\n    // mode, the set of reserved words, support for getters and\n    // setters and other features. The default is 6.\n    ecmaVersion: 6,\n    // Source type (\"script\" or \"module\") for different semantics\n    sourceType: \"script\",\n    // `onInsertedSemicolon` can be a callback that will be called\n    // when a semicolon is automatically inserted. It will be passed\n    // th position of the comma as an offset, and if `locations` is\n    // enabled, it is given the location as a `{line, column}` object\n    // as second argument.\n    onInsertedSemicolon: null,\n    // `onTrailingComma` is similar to `onInsertedSemicolon`, but for\n    // trailing commas.\n    onTrailingComma: null,\n    // By default, reserved words are only enforced if ecmaVersion >= 5.\n    // Set `allowReserved` to a boolean value to explicitly turn this on\n    // an off. When this option has the value \"never\", reserved words\n    // and keywords can also not be used as property names.\n    allowReserved: null,\n    // When enabled, a return at the top level is not considered an\n    // error.\n    allowReturnOutsideFunction: false,\n    // When enabled, import/export statements are not constrained to\n    // appearing at the top of the program.\n    allowImportExportEverywhere: false,\n    // When enabled, hashbang directive in the beginning of file\n    // is allowed and treated as a line comment.\n    allowHashBang: false,\n    // When `locations` is on, `loc` properties holding objects with\n    // `start` and `end` properties in `{line, column}` form (with\n    // line being 1-based and column 0-based) will be attached to the\n    // nodes.\n    locations: false,\n    // A function can be passed as `onToken` option, which will\n    // cause Acorn to call that function with object in the same\n    // format as tokens returned from `tokenizer().getToken()`. Note\n    // that you are not allowed to call the parser from the\n    // callbackthat will corrupt its internal state.\n    onToken: null,\n    // A function can be passed as `onComment` option, which will\n    // cause Acorn to call that function with `(block, text, start,\n    // end)` parameters whenever a comment is skipped. `block` is a\n    // boolean indicating whether this is a block (`/* */`) comment,\n    // `text` is the content of the comment, and `start` and `end` are\n    // character offsets that denote the start and end of the comment.\n    // When the `locations` option is on, two more parameters are\n    // passed, the full `{line, column}` locations of the start and\n    // end of the comments. Note that you are not allowed to call the\n    // parser from the callbackthat will corrupt its internal state.\n    onComment: null,\n    // Nodes have their start and end characters offsets recorded in\n    // `start` and `end` properties (directly on the node, rather than\n    // the `loc` object, which holds line/column data. To also add a\n    // [semi-standardized][range] `range` property holding a `[start,\n    // end]` array with the same numbers, set the `ranges` option to\n    // `true`.\n    //\n    // [range]: https://bugzilla.mozilla.org/show_bug.cgi?id=745678\n    ranges: false,\n    // It is possible to parse multiple files into a single AST by\n    // passing the tree produced by parsing the first file as\n    // `program` option in subsequent parses. This will add the\n    // toplevel forms of the parsed file to the `Program` (top) node\n    // of an existing parse tree.\n    program: null,\n    // When `locations` is on, you can pass this to record the source\n    // file in every node's `loc` object.\n    sourceFile: null,\n    // This value, if given, is stored in every node, whether\n    // `locations` is on or off.\n    directSourceFile: null,\n    // When enabled, parenthesized expressions are represented by\n    // (non-standard) ParenthesizedExpression nodes\n    preserveParens: false,\n    plugins: {}\n  }\n\n  // Interpret and default an options object\n\n  function getOptions(opts) {\n    var options = {}\n    for (var opt in defaultOptions)\n      options[opt] = opts && has(opts, opt) ? opts[opt] : defaultOptions[opt]\n    if (options.allowReserved == null)\n      options.allowReserved = options.ecmaVersion < 5\n\n    if (isArray(options.onToken)) {\n      var tokens = options.onToken\n      options.onToken = function (token) { return tokens.push(token); }\n    }\n    if (isArray(options.onComment))\n      options.onComment = pushComment(options, options.onComment)\n\n    return options\n  }\n\n  function pushComment(options, array) {\n    return function (block, text, start, end, startLoc, endLoc) {\n      var comment = {\n        type: block ? 'Block' : 'Line',\n        value: text,\n        start: start,\n        end: end\n      }\n      if (options.locations)\n        comment.loc = new SourceLocation(this, startLoc, endLoc)\n      if (options.ranges)\n        comment.range = [start, end]\n      array.push(comment)\n    }\n  }\n\n  // Registered plugins\n  var plugins = {}\n\n  function keywordRegexp(words) {\n    return new RegExp(\"^(\" + words.replace(/ /g, \"|\") + \")$\")\n  }\n\n  var Parser = function Parser(options, input, startPos) {\n    this.options = options = getOptions(options)\n    this.sourceFile = options.sourceFile\n    this.keywords = keywordRegexp(keywords[options.ecmaVersion >= 6 ? 6 : 5])\n    var reserved = options.allowReserved ? \"\" :\n        reservedWords[options.ecmaVersion] + (options.sourceType == \"module\" ? \" await\" : \"\")\n    this.reservedWords = keywordRegexp(reserved)\n    var reservedStrict = (reserved ? reserved + \" \" : \"\") + reservedWords.strict\n    this.reservedWordsStrict = keywordRegexp(reservedStrict)\n    this.reservedWordsStrictBind = keywordRegexp(reservedStrict + \" \" + reservedWords.strictBind)\n    this.input = String(input)\n\n    // Used to signal to callers of `readWord1` whether the word\n    // contained any escape sequences. This is needed because words with\n    // escape sequences must not be interpreted as keywords.\n    this.containsEsc = false\n\n    // Load plugins\n    this.loadPlugins(options.plugins)\n\n    // Set up token state\n\n    // The current position of the tokenizer in the input.\n    if (startPos) {\n      this.pos = startPos\n      this.lineStart = Math.max(0, this.input.lastIndexOf(\"\\n\", startPos))\n      this.curLine = this.input.slice(0, this.lineStart).split(lineBreak).length\n    } else {\n      this.pos = this.lineStart = 0\n      this.curLine = 1\n    }\n\n    // Properties of the current token:\n    // Its type\n    this.type = tt.eof\n    // For tokens that include more information than their type, the value\n    this.value = null\n    // Its start and end offset\n    this.start = this.end = this.pos\n    // And, if locations are used, the {line, column} object\n    // corresponding to those offsets\n    this.startLoc = this.endLoc = this.curPosition()\n\n    // Position information for the previous token\n    this.lastTokEndLoc = this.lastTokStartLoc = null\n    this.lastTokStart = this.lastTokEnd = this.pos\n\n    // The context stack is used to superficially track syntactic\n    // context to predict whether a regular expression is allowed in a\n    // given position.\n    this.context = this.initialContext()\n    this.exprAllowed = true\n\n    // Figure out if it's a module code.\n    this.strict = this.inModule = options.sourceType === \"module\"\n\n    // Used to signify the start of a potential arrow function\n    this.potentialArrowAt = -1\n\n    // Flags to track whether we are in a function, a generator.\n    this.inFunction = this.inGenerator = false\n    // Labels in scope.\n    this.labels = []\n\n    // If enabled, skip leading hashbang line.\n    if (this.pos === 0 && options.allowHashBang && this.input.slice(0, 2) === '#!')\n      this.skipLineComment(2)\n  };\n\n  // DEPRECATED Kept for backwards compatibility until 3.0 in case a plugin uses them\n  Parser.prototype.isKeyword = function isKeyword (word) { return this.keywords.test(word) };\n  Parser.prototype.isReservedWord = function isReservedWord (word) { return this.reservedWords.test(word) };\n\n  Parser.prototype.extend = function extend (name, f) {\n    this[name] = f(this[name])\n  };\n\n  Parser.prototype.loadPlugins = function loadPlugins (pluginConfigs) {\n      var this$1 = this;\n\n    for (var name in pluginConfigs) {\n      var plugin = plugins[name]\n      if (!plugin) throw new Error(\"Plugin '\" + name + \"' not found\")\n      plugin(this$1, pluginConfigs[name])\n    }\n  };\n\n  Parser.prototype.parse = function parse () {\n    var node = this.options.program || this.startNode()\n    this.nextToken()\n    return this.parseTopLevel(node)\n  };\n\n  var pp = Parser.prototype\n\n  // ## Parser utilities\n\n  // Test whether a statement node is the string literal `\"use strict\"`.\n\n  pp.isUseStrict = function(stmt) {\n    return this.options.ecmaVersion >= 5 && stmt.type === \"ExpressionStatement\" &&\n      stmt.expression.type === \"Literal\" &&\n      stmt.expression.raw.slice(1, -1) === \"use strict\"\n  }\n\n  // Predicate that tests whether the next token is of the given\n  // type, and if yes, consumes it as a side effect.\n\n  pp.eat = function(type) {\n    if (this.type === type) {\n      this.next()\n      return true\n    } else {\n      return false\n    }\n  }\n\n  // Tests whether parsed token is a contextual keyword.\n\n  pp.isContextual = function(name) {\n    return this.type === tt.name && this.value === name\n  }\n\n  // Consumes contextual keyword if possible.\n\n  pp.eatContextual = function(name) {\n    return this.value === name && this.eat(tt.name)\n  }\n\n  // Asserts that following token is given contextual keyword.\n\n  pp.expectContextual = function(name) {\n    if (!this.eatContextual(name)) this.unexpected()\n  }\n\n  // Test whether a semicolon can be inserted at the current position.\n\n  pp.canInsertSemicolon = function() {\n    return this.type === tt.eof ||\n      this.type === tt.braceR ||\n      lineBreak.test(this.input.slice(this.lastTokEnd, this.start))\n  }\n\n  pp.insertSemicolon = function() {\n    if (this.canInsertSemicolon()) {\n      if (this.options.onInsertedSemicolon)\n        this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc)\n      return true\n    }\n  }\n\n  // Consume a semicolon, or, failing that, see if we are allowed to\n  // pretend that there is a semicolon at this position.\n\n  pp.semicolon = function() {\n    if (!this.eat(tt.semi) && !this.insertSemicolon()) this.unexpected()\n  }\n\n  pp.afterTrailingComma = function(tokType) {\n    if (this.type == tokType) {\n      if (this.options.onTrailingComma)\n        this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc)\n      this.next()\n      return true\n    }\n  }\n\n  // Expect a token of a given type. If found, consume it, otherwise,\n  // raise an unexpected token error.\n\n  pp.expect = function(type) {\n    this.eat(type) || this.unexpected()\n  }\n\n  // Raise an unexpected token error.\n\n  pp.unexpected = function(pos) {\n    this.raise(pos != null ? pos : this.start, \"Unexpected token\")\n  }\n\n  var DestructuringErrors = function DestructuringErrors() {\n    this.shorthandAssign = 0\n    this.trailingComma = 0\n  };\n\n  pp.checkPatternErrors = function(refDestructuringErrors, andThrow) {\n    var trailing = refDestructuringErrors && refDestructuringErrors.trailingComma\n    if (!andThrow) return !!trailing\n    if (trailing) this.raise(trailing, \"Comma is not permitted after the rest element\")\n  }\n\n  pp.checkExpressionErrors = function(refDestructuringErrors, andThrow) {\n    var pos = refDestructuringErrors && refDestructuringErrors.shorthandAssign\n    if (!andThrow) return !!pos\n    if (pos) this.raise(pos, \"Shorthand property assignments are valid only in destructuring patterns\")\n  }\n\n  var pp$1 = Parser.prototype\n\n  // ### Statement parsing\n\n  // Parse a program. Initializes the parser, reads any number of\n  // statements, and wraps them in a Program node.  Optionally takes a\n  // `program` argument.  If present, the statements will be appended\n  // to its body instead of creating a new node.\n\n  pp$1.parseTopLevel = function(node) {\n    var this$1 = this;\n\n    var first = true\n    if (!node.body) node.body = []\n    while (this.type !== tt.eof) {\n      var stmt = this$1.parseStatement(true, true)\n      node.body.push(stmt)\n      if (first) {\n        if (this$1.isUseStrict(stmt)) this$1.setStrict(true)\n        first = false\n      }\n    }\n    this.next()\n    if (this.options.ecmaVersion >= 6) {\n      node.sourceType = this.options.sourceType\n    }\n    return this.finishNode(node, \"Program\")\n  }\n\n  var loopLabel = {kind: \"loop\"};\n  var switchLabel = {kind: \"switch\"};\n  pp$1.isLet = function() {\n    if (this.type !== tt.name || this.options.ecmaVersion < 6 || this.value != \"let\") return false\n    skipWhiteSpace.lastIndex = this.pos\n    var skip = skipWhiteSpace.exec(this.input)\n    var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next)\n    if (nextCh === 91 || nextCh == 123) return true // '{' and '['\n    if (isIdentifierStart(nextCh, true)) {\n      for (var pos = next + 1; isIdentifierChar(this.input.charCodeAt(pos), true); ++pos) {}\n      var ident = this.input.slice(next, pos)\n      if (!this.isKeyword(ident)) return true\n    }\n    return false\n  }\n\n  // Parse a single statement.\n  //\n  // If expecting a statement and finding a slash operator, parse a\n  // regular expression literal. This is to handle cases like\n  // `if (foo) /blah/.exec(foo)`, where looking at the previous token\n  // does not help.\n\n  pp$1.parseStatement = function(declaration, topLevel) {\n    var starttype = this.type, node = this.startNode(), kind\n\n    if (this.isLet()) {\n      starttype = tt._var\n      kind = \"let\"\n    }\n\n    // Most types of statements are recognized by the keyword they\n    // start with. Many are trivial to parse, some require a bit of\n    // complexity.\n\n    switch (starttype) {\n    case tt._break: case tt._continue: return this.parseBreakContinueStatement(node, starttype.keyword)\n    case tt._debugger: return this.parseDebuggerStatement(node)\n    case tt._do: return this.parseDoStatement(node)\n    case tt._for: return this.parseForStatement(node)\n    case tt._function:\n      if (!declaration && this.options.ecmaVersion >= 6) this.unexpected()\n      return this.parseFunctionStatement(node)\n    case tt._class:\n      if (!declaration) this.unexpected()\n      return this.parseClass(node, true)\n    case tt._if: return this.parseIfStatement(node)\n    case tt._return: return this.parseReturnStatement(node)\n    case tt._switch: return this.parseSwitchStatement(node)\n    case tt._throw: return this.parseThrowStatement(node)\n    case tt._try: return this.parseTryStatement(node)\n    case tt._const: case tt._var:\n      kind = kind || this.value\n      if (!declaration && kind != \"var\") this.unexpected()\n      return this.parseVarStatement(node, kind)\n    case tt._while: return this.parseWhileStatement(node)\n    case tt._with: return this.parseWithStatement(node)\n    case tt.braceL: return this.parseBlock()\n    case tt.semi: return this.parseEmptyStatement(node)\n    case tt._export:\n    case tt._import:\n      if (!this.options.allowImportExportEverywhere) {\n        if (!topLevel)\n          this.raise(this.start, \"'import' and 'export' may only appear at the top level\")\n        if (!this.inModule)\n          this.raise(this.start, \"'import' and 'export' may appear only with 'sourceType: module'\")\n      }\n      return starttype === tt._import ? this.parseImport(node) : this.parseExport(node)\n\n      // If the statement does not start with a statement keyword or a\n      // brace, it's an ExpressionStatement or LabeledStatement. We\n      // simply start parsing an expression, and afterwards, if the\n      // next token is a colon and the expression was a simple\n      // Identifier node, we switch to interpreting it as a label.\n    default:\n      var maybeName = this.value, expr = this.parseExpression()\n      if (starttype === tt.name && expr.type === \"Identifier\" && this.eat(tt.colon))\n        return this.parseLabeledStatement(node, maybeName, expr)\n      else return this.parseExpressionStatement(node, expr)\n    }\n  }\n\n  pp$1.parseBreakContinueStatement = function(node, keyword) {\n    var this$1 = this;\n\n    var isBreak = keyword == \"break\"\n    this.next()\n    if (this.eat(tt.semi) || this.insertSemicolon()) node.label = null\n    else if (this.type !== tt.name) this.unexpected()\n    else {\n      node.label = this.parseIdent()\n      this.semicolon()\n    }\n\n    // Verify that there is an actual destination to break or\n    // continue to.\n    for (var i = 0; i < this.labels.length; ++i) {\n      var lab = this$1.labels[i]\n      if (node.label == null || lab.name === node.label.name) {\n        if (lab.kind != null && (isBreak || lab.kind === \"loop\")) break\n        if (node.label && isBreak) break\n      }\n    }\n    if (i === this.labels.length) this.raise(node.start, \"Unsyntactic \" + keyword)\n    return this.finishNode(node, isBreak ? \"BreakStatement\" : \"ContinueStatement\")\n  }\n\n  pp$1.parseDebuggerStatement = function(node) {\n    this.next()\n    this.semicolon()\n    return this.finishNode(node, \"DebuggerStatement\")\n  }\n\n  pp$1.parseDoStatement = function(node) {\n    this.next()\n    this.labels.push(loopLabel)\n    node.body = this.parseStatement(false)\n    this.labels.pop()\n    this.expect(tt._while)\n    node.test = this.parseParenExpression()\n    if (this.options.ecmaVersion >= 6)\n      this.eat(tt.semi)\n    else\n      this.semicolon()\n    return this.finishNode(node, \"DoWhileStatement\")\n  }\n\n  // Disambiguating between a `for` and a `for`/`in` or `for`/`of`\n  // loop is non-trivial. Basically, we have to parse the init `var`\n  // statement or expression, disallowing the `in` operator (see\n  // the second parameter to `parseExpression`), and then check\n  // whether the next token is `in` or `of`. When there is no init\n  // part (semicolon immediately after the opening parenthesis), it\n  // is a regular `for` loop.\n\n  pp$1.parseForStatement = function(node) {\n    this.next()\n    this.labels.push(loopLabel)\n    this.expect(tt.parenL)\n    if (this.type === tt.semi) return this.parseFor(node, null)\n    var isLet = this.isLet()\n    if (this.type === tt._var || this.type === tt._const || isLet) {\n      var init$1 = this.startNode(), kind = isLet ? \"let\" : this.value\n      this.next()\n      this.parseVar(init$1, true, kind)\n      this.finishNode(init$1, \"VariableDeclaration\")\n      if ((this.type === tt._in || (this.options.ecmaVersion >= 6 && this.isContextual(\"of\"))) && init$1.declarations.length === 1 &&\n          !(kind !== \"var\" && init$1.declarations[0].init))\n        return this.parseForIn(node, init$1)\n      return this.parseFor(node, init$1)\n    }\n    var refDestructuringErrors = new DestructuringErrors\n    var init = this.parseExpression(true, refDestructuringErrors)\n    if (this.type === tt._in || (this.options.ecmaVersion >= 6 && this.isContextual(\"of\"))) {\n      this.checkPatternErrors(refDestructuringErrors, true)\n      this.toAssignable(init)\n      this.checkLVal(init)\n      return this.parseForIn(node, init)\n    } else {\n      this.checkExpressionErrors(refDestructuringErrors, true)\n    }\n    return this.parseFor(node, init)\n  }\n\n  pp$1.parseFunctionStatement = function(node) {\n    this.next()\n    return this.parseFunction(node, true)\n  }\n\n  pp$1.parseIfStatement = function(node) {\n    this.next()\n    node.test = this.parseParenExpression()\n    node.consequent = this.parseStatement(false)\n    node.alternate = this.eat(tt._else) ? this.parseStatement(false) : null\n    return this.finishNode(node, \"IfStatement\")\n  }\n\n  pp$1.parseReturnStatement = function(node) {\n    if (!this.inFunction && !this.options.allowReturnOutsideFunction)\n      this.raise(this.start, \"'return' outside of function\")\n    this.next()\n\n    // In `return` (and `break`/`continue`), the keywords with\n    // optional arguments, we eagerly look for a semicolon or the\n    // possibility to insert one.\n\n    if (this.eat(tt.semi) || this.insertSemicolon()) node.argument = null\n    else { node.argument = this.parseExpression(); this.semicolon() }\n    return this.finishNode(node, \"ReturnStatement\")\n  }\n\n  pp$1.parseSwitchStatement = function(node) {\n    var this$1 = this;\n\n    this.next()\n    node.discriminant = this.parseParenExpression()\n    node.cases = []\n    this.expect(tt.braceL)\n    this.labels.push(switchLabel)\n\n    // Statements under must be grouped (by label) in SwitchCase\n    // nodes. `cur` is used to keep the node that we are currently\n    // adding statements to.\n\n    for (var cur, sawDefault = false; this.type != tt.braceR;) {\n      if (this$1.type === tt._case || this$1.type === tt._default) {\n        var isCase = this$1.type === tt._case\n        if (cur) this$1.finishNode(cur, \"SwitchCase\")\n        node.cases.push(cur = this$1.startNode())\n        cur.consequent = []\n        this$1.next()\n        if (isCase) {\n          cur.test = this$1.parseExpression()\n        } else {\n          if (sawDefault) this$1.raiseRecoverable(this$1.lastTokStart, \"Multiple default clauses\")\n          sawDefault = true\n          cur.test = null\n        }\n        this$1.expect(tt.colon)\n      } else {\n        if (!cur) this$1.unexpected()\n        cur.consequent.push(this$1.parseStatement(true))\n      }\n    }\n    if (cur) this.finishNode(cur, \"SwitchCase\")\n    this.next() // Closing brace\n    this.labels.pop()\n    return this.finishNode(node, \"SwitchStatement\")\n  }\n\n  pp$1.parseThrowStatement = function(node) {\n    this.next()\n    if (lineBreak.test(this.input.slice(this.lastTokEnd, this.start)))\n      this.raise(this.lastTokEnd, \"Illegal newline after throw\")\n    node.argument = this.parseExpression()\n    this.semicolon()\n    return this.finishNode(node, \"ThrowStatement\")\n  }\n\n  // Reused empty array added for node fields that are always empty.\n\n  var empty = []\n\n  pp$1.parseTryStatement = function(node) {\n    this.next()\n    node.block = this.parseBlock()\n    node.handler = null\n    if (this.type === tt._catch) {\n      var clause = this.startNode()\n      this.next()\n      this.expect(tt.parenL)\n      clause.param = this.parseBindingAtom()\n      this.checkLVal(clause.param, true)\n      this.expect(tt.parenR)\n      clause.body = this.parseBlock()\n      node.handler = this.finishNode(clause, \"CatchClause\")\n    }\n    node.finalizer = this.eat(tt._finally) ? this.parseBlock() : null\n    if (!node.handler && !node.finalizer)\n      this.raise(node.start, \"Missing catch or finally clause\")\n    return this.finishNode(node, \"TryStatement\")\n  }\n\n  pp$1.parseVarStatement = function(node, kind) {\n    this.next()\n    this.parseVar(node, false, kind)\n    this.semicolon()\n    return this.finishNode(node, \"VariableDeclaration\")\n  }\n\n  pp$1.parseWhileStatement = function(node) {\n    this.next()\n    node.test = this.parseParenExpression()\n    this.labels.push(loopLabel)\n    node.body = this.parseStatement(false)\n    this.labels.pop()\n    return this.finishNode(node, \"WhileStatement\")\n  }\n\n  pp$1.parseWithStatement = function(node) {\n    if (this.strict) this.raise(this.start, \"'with' in strict mode\")\n    this.next()\n    node.object = this.parseParenExpression()\n    node.body = this.parseStatement(false)\n    return this.finishNode(node, \"WithStatement\")\n  }\n\n  pp$1.parseEmptyStatement = function(node) {\n    this.next()\n    return this.finishNode(node, \"EmptyStatement\")\n  }\n\n  pp$1.parseLabeledStatement = function(node, maybeName, expr) {\n    var this$1 = this;\n\n    for (var i = 0; i < this.labels.length; ++i)\n      if (this$1.labels[i].name === maybeName) this$1.raise(expr.start, \"Label '\" + maybeName + \"' is already declared\")\n    var kind = this.type.isLoop ? \"loop\" : this.type === tt._switch ? \"switch\" : null\n    for (var i$1 = this.labels.length - 1; i$1 >= 0; i$1--) {\n      var label = this$1.labels[i$1]\n      if (label.statementStart == node.start) {\n        label.statementStart = this$1.start\n        label.kind = kind\n      } else break\n    }\n    this.labels.push({name: maybeName, kind: kind, statementStart: this.start})\n    node.body = this.parseStatement(true)\n    this.labels.pop()\n    node.label = expr\n    return this.finishNode(node, \"LabeledStatement\")\n  }\n\n  pp$1.parseExpressionStatement = function(node, expr) {\n    node.expression = expr\n    this.semicolon()\n    return this.finishNode(node, \"ExpressionStatement\")\n  }\n\n  // Parse a semicolon-enclosed block of statements, handling `\"use\n  // strict\"` declarations when `allowStrict` is true (used for\n  // function bodies).\n\n  pp$1.parseBlock = function(allowStrict) {\n    var this$1 = this;\n\n    var node = this.startNode(), first = true, oldStrict\n    node.body = []\n    this.expect(tt.braceL)\n    while (!this.eat(tt.braceR)) {\n      var stmt = this$1.parseStatement(true)\n      node.body.push(stmt)\n      if (first && allowStrict && this$1.isUseStrict(stmt)) {\n        oldStrict = this$1.strict\n        this$1.setStrict(this$1.strict = true)\n      }\n      first = false\n    }\n    if (oldStrict === false) this.setStrict(false)\n    return this.finishNode(node, \"BlockStatement\")\n  }\n\n  // Parse a regular `for` loop. The disambiguation code in\n  // `parseStatement` will already have parsed the init statement or\n  // expression.\n\n  pp$1.parseFor = function(node, init) {\n    node.init = init\n    this.expect(tt.semi)\n    node.test = this.type === tt.semi ? null : this.parseExpression()\n    this.expect(tt.semi)\n    node.update = this.type === tt.parenR ? null : this.parseExpression()\n    this.expect(tt.parenR)\n    node.body = this.parseStatement(false)\n    this.labels.pop()\n    return this.finishNode(node, \"ForStatement\")\n  }\n\n  // Parse a `for`/`in` and `for`/`of` loop, which are almost\n  // same from parser's perspective.\n\n  pp$1.parseForIn = function(node, init) {\n    var type = this.type === tt._in ? \"ForInStatement\" : \"ForOfStatement\"\n    this.next()\n    node.left = init\n    node.right = this.parseExpression()\n    this.expect(tt.parenR)\n    node.body = this.parseStatement(false)\n    this.labels.pop()\n    return this.finishNode(node, type)\n  }\n\n  // Parse a list of variable declarations.\n\n  pp$1.parseVar = function(node, isFor, kind) {\n    var this$1 = this;\n\n    node.declarations = []\n    node.kind = kind\n    for (;;) {\n      var decl = this$1.startNode()\n      this$1.parseVarId(decl)\n      if (this$1.eat(tt.eq)) {\n        decl.init = this$1.parseMaybeAssign(isFor)\n      } else if (kind === \"const\" && !(this$1.type === tt._in || (this$1.options.ecmaVersion >= 6 && this$1.isContextual(\"of\")))) {\n        this$1.unexpected()\n      } else if (decl.id.type != \"Identifier\" && !(isFor && (this$1.type === tt._in || this$1.isContextual(\"of\")))) {\n        this$1.raise(this$1.lastTokEnd, \"Complex binding patterns require an initialization value\")\n      } else {\n        decl.init = null\n      }\n      node.declarations.push(this$1.finishNode(decl, \"VariableDeclarator\"))\n      if (!this$1.eat(tt.comma)) break\n    }\n    return node\n  }\n\n  pp$1.parseVarId = function(decl) {\n    decl.id = this.parseBindingAtom()\n    this.checkLVal(decl.id, true)\n  }\n\n  // Parse a function declaration or literal (depending on the\n  // `isStatement` parameter).\n\n  pp$1.parseFunction = function(node, isStatement, allowExpressionBody) {\n    this.initFunction(node)\n    if (this.options.ecmaVersion >= 6)\n      node.generator = this.eat(tt.star)\n    var oldInGen = this.inGenerator\n    this.inGenerator = node.generator\n    if (isStatement || this.type === tt.name)\n      node.id = this.parseIdent()\n    this.parseFunctionParams(node)\n    this.parseFunctionBody(node, allowExpressionBody)\n    this.inGenerator = oldInGen\n    return this.finishNode(node, isStatement ? \"FunctionDeclaration\" : \"FunctionExpression\")\n  }\n\n  pp$1.parseFunctionParams = function(node) {\n    this.expect(tt.parenL)\n    node.params = this.parseBindingList(tt.parenR, false, false, true)\n  }\n\n  // Parse a class declaration or literal (depending on the\n  // `isStatement` parameter).\n\n  pp$1.parseClass = function(node, isStatement) {\n    var this$1 = this;\n\n    this.next()\n    this.parseClassId(node, isStatement)\n    this.parseClassSuper(node)\n    var classBody = this.startNode()\n    var hadConstructor = false\n    classBody.body = []\n    this.expect(tt.braceL)\n    while (!this.eat(tt.braceR)) {\n      if (this$1.eat(tt.semi)) continue\n      var method = this$1.startNode()\n      var isGenerator = this$1.eat(tt.star)\n      var isMaybeStatic = this$1.type === tt.name && this$1.value === \"static\"\n      this$1.parsePropertyName(method)\n      method.static = isMaybeStatic && this$1.type !== tt.parenL\n      if (method.static) {\n        if (isGenerator) this$1.unexpected()\n        isGenerator = this$1.eat(tt.star)\n        this$1.parsePropertyName(method)\n      }\n      method.kind = \"method\"\n      var isGetSet = false\n      if (!method.computed) {\n        var key = method.key;\n        if (!isGenerator && key.type === \"Identifier\" && this$1.type !== tt.parenL && (key.name === \"get\" || key.name === \"set\")) {\n          isGetSet = true\n          method.kind = key.name\n          key = this$1.parsePropertyName(method)\n        }\n        if (!method.static && (key.type === \"Identifier\" && key.name === \"constructor\" ||\n            key.type === \"Literal\" && key.value === \"constructor\")) {\n          if (hadConstructor) this$1.raise(key.start, \"Duplicate constructor in the same class\")\n          if (isGetSet) this$1.raise(key.start, \"Constructor can't have get/set modifier\")\n          if (isGenerator) this$1.raise(key.start, \"Constructor can't be a generator\")\n          method.kind = \"constructor\"\n          hadConstructor = true\n        }\n      }\n      this$1.parseClassMethod(classBody, method, isGenerator)\n      if (isGetSet) {\n        var paramCount = method.kind === \"get\" ? 0 : 1\n        if (method.value.params.length !== paramCount) {\n          var start = method.value.start\n          if (method.kind === \"get\")\n            this$1.raiseRecoverable(start, \"getter should have no params\")\n          else\n            this$1.raiseRecoverable(start, \"setter should have exactly one param\")\n        }\n        if (method.kind === \"set\" && method.value.params[0].type === \"RestElement\")\n          this$1.raise(method.value.params[0].start, \"Setter cannot use rest params\")\n      }\n    }\n    node.body = this.finishNode(classBody, \"ClassBody\")\n    return this.finishNode(node, isStatement ? \"ClassDeclaration\" : \"ClassExpression\")\n  }\n\n  pp$1.parseClassMethod = function(classBody, method, isGenerator) {\n    method.value = this.parseMethod(isGenerator)\n    classBody.body.push(this.finishNode(method, \"MethodDefinition\"))\n  }\n\n  pp$1.parseClassId = function(node, isStatement) {\n    node.id = this.type === tt.name ? this.parseIdent() : isStatement ? this.unexpected() : null\n  }\n\n  pp$1.parseClassSuper = function(node) {\n    node.superClass = this.eat(tt._extends) ? this.parseExprSubscripts() : null\n  }\n\n  // Parses module export declaration.\n\n  pp$1.parseExport = function(node) {\n    var this$1 = this;\n\n    this.next()\n    // export * from '...'\n    if (this.eat(tt.star)) {\n      this.expectContextual(\"from\")\n      node.source = this.type === tt.string ? this.parseExprAtom() : this.unexpected()\n      this.semicolon()\n      return this.finishNode(node, \"ExportAllDeclaration\")\n    }\n    if (this.eat(tt._default)) { // export default ...\n      var parens = this.type == tt.parenL\n      var expr = this.parseMaybeAssign()\n      var needsSemi = true\n      if (!parens && (expr.type == \"FunctionExpression\" ||\n                      expr.type == \"ClassExpression\")) {\n        needsSemi = false\n        if (expr.id) {\n          expr.type = expr.type == \"FunctionExpression\"\n            ? \"FunctionDeclaration\"\n            : \"ClassDeclaration\"\n        }\n      }\n      node.declaration = expr\n      if (needsSemi) this.semicolon()\n      return this.finishNode(node, \"ExportDefaultDeclaration\")\n    }\n    // export var|const|let|function|class ...\n    if (this.shouldParseExportStatement()) {\n      node.declaration = this.parseStatement(true)\n      node.specifiers = []\n      node.source = null\n    } else { // export { x, y as z } [from '...']\n      node.declaration = null\n      node.specifiers = this.parseExportSpecifiers()\n      if (this.eatContextual(\"from\")) {\n        node.source = this.type === tt.string ? this.parseExprAtom() : this.unexpected()\n      } else {\n        // check for keywords used as local names\n        for (var i = 0; i < node.specifiers.length; i++) {\n          if (this$1.keywords.test(node.specifiers[i].local.name) || this$1.reservedWords.test(node.specifiers[i].local.name)) {\n            this$1.unexpected(node.specifiers[i].local.start)\n          }\n        }\n\n        node.source = null\n      }\n      this.semicolon()\n    }\n    return this.finishNode(node, \"ExportNamedDeclaration\")\n  }\n\n  pp$1.shouldParseExportStatement = function() {\n    return this.type.keyword || this.isLet()\n  }\n\n  // Parses a comma-separated list of module exports.\n\n  pp$1.parseExportSpecifiers = function() {\n    var this$1 = this;\n\n    var nodes = [], first = true\n    // export { x, y as z } [from '...']\n    this.expect(tt.braceL)\n    while (!this.eat(tt.braceR)) {\n      if (!first) {\n        this$1.expect(tt.comma)\n        if (this$1.afterTrailingComma(tt.braceR)) break\n      } else first = false\n\n      var node = this$1.startNode()\n      node.local = this$1.parseIdent(this$1.type === tt._default)\n      node.exported = this$1.eatContextual(\"as\") ? this$1.parseIdent(true) : node.local\n      nodes.push(this$1.finishNode(node, \"ExportSpecifier\"))\n    }\n    return nodes\n  }\n\n  // Parses import declaration.\n\n  pp$1.parseImport = function(node) {\n    this.next()\n    // import '...'\n    if (this.type === tt.string) {\n      node.specifiers = empty\n      node.source = this.parseExprAtom()\n    } else {\n      node.specifiers = this.parseImportSpecifiers()\n      this.expectContextual(\"from\")\n      node.source = this.type === tt.string ? this.parseExprAtom() : this.unexpected()\n    }\n    this.semicolon()\n    return this.finishNode(node, \"ImportDeclaration\")\n  }\n\n  // Parses a comma-separated list of module imports.\n\n  pp$1.parseImportSpecifiers = function() {\n    var this$1 = this;\n\n    var nodes = [], first = true\n    if (this.type === tt.name) {\n      // import defaultObj, { x, y as z } from '...'\n      var node = this.startNode()\n      node.local = this.parseIdent()\n      this.checkLVal(node.local, true)\n      nodes.push(this.finishNode(node, \"ImportDefaultSpecifier\"))\n      if (!this.eat(tt.comma)) return nodes\n    }\n    if (this.type === tt.star) {\n      var node$1 = this.startNode()\n      this.next()\n      this.expectContextual(\"as\")\n      node$1.local = this.parseIdent()\n      this.checkLVal(node$1.local, true)\n      nodes.push(this.finishNode(node$1, \"ImportNamespaceSpecifier\"))\n      return nodes\n    }\n    this.expect(tt.braceL)\n    while (!this.eat(tt.braceR)) {\n      if (!first) {\n        this$1.expect(tt.comma)\n        if (this$1.afterTrailingComma(tt.braceR)) break\n      } else first = false\n\n      var node$2 = this$1.startNode()\n      node$2.imported = this$1.parseIdent(true)\n      if (this$1.eatContextual(\"as\")) {\n        node$2.local = this$1.parseIdent()\n      } else {\n        node$2.local = node$2.imported\n        if (this$1.isKeyword(node$2.local.name)) this$1.unexpected(node$2.local.start)\n        if (this$1.reservedWordsStrict.test(node$2.local.name)) this$1.raise(node$2.local.start, \"The keyword '\" + node$2.local.name + \"' is reserved\")\n      }\n      this$1.checkLVal(node$2.local, true)\n      nodes.push(this$1.finishNode(node$2, \"ImportSpecifier\"))\n    }\n    return nodes\n  }\n\n  var pp$2 = Parser.prototype\n\n  // Convert existing expression atom to assignable pattern\n  // if possible.\n\n  pp$2.toAssignable = function(node, isBinding) {\n    var this$1 = this;\n\n    if (this.options.ecmaVersion >= 6 && node) {\n      switch (node.type) {\n      case \"Identifier\":\n      case \"ObjectPattern\":\n      case \"ArrayPattern\":\n        break\n\n      case \"ObjectExpression\":\n        node.type = \"ObjectPattern\"\n        for (var i = 0; i < node.properties.length; i++) {\n          var prop = node.properties[i]\n          if (prop.kind !== \"init\") this$1.raise(prop.key.start, \"Object pattern can't contain getter or setter\")\n          this$1.toAssignable(prop.value, isBinding)\n        }\n        break\n\n      case \"ArrayExpression\":\n        node.type = \"ArrayPattern\"\n        this.toAssignableList(node.elements, isBinding)\n        break\n\n      case \"AssignmentExpression\":\n        if (node.operator === \"=\") {\n          node.type = \"AssignmentPattern\"\n          delete node.operator\n          // falls through to AssignmentPattern\n        } else {\n          this.raise(node.left.end, \"Only '=' operator can be used for specifying default value.\")\n          break\n        }\n\n      case \"AssignmentPattern\":\n        if (node.right.type === \"YieldExpression\")\n          this.raise(node.right.start, \"Yield expression cannot be a default value\")\n        break\n\n      case \"ParenthesizedExpression\":\n        node.expression = this.toAssignable(node.expression, isBinding)\n        break\n\n      case \"MemberExpression\":\n        if (!isBinding) break\n\n      default:\n        this.raise(node.start, \"Assigning to rvalue\")\n      }\n    }\n    return node\n  }\n\n  // Convert list of expression atoms to binding list.\n\n  pp$2.toAssignableList = function(exprList, isBinding) {\n    var this$1 = this;\n\n    var end = exprList.length\n    if (end) {\n      var last = exprList[end - 1]\n      if (last && last.type == \"RestElement\") {\n        --end\n      } else if (last && last.type == \"SpreadElement\") {\n        last.type = \"RestElement\"\n        var arg = last.argument\n        this.toAssignable(arg, isBinding)\n        if (arg.type !== \"Identifier\" && arg.type !== \"MemberExpression\" && arg.type !== \"ArrayPattern\")\n          this.unexpected(arg.start)\n        --end\n      }\n\n      if (isBinding && last && last.type === \"RestElement\" && last.argument.type !== \"Identifier\")\n        this.unexpected(last.argument.start)\n    }\n    for (var i = 0; i < end; i++) {\n      var elt = exprList[i]\n      if (elt) this$1.toAssignable(elt, isBinding)\n    }\n    return exprList\n  }\n\n  // Parses spread element.\n\n  pp$2.parseSpread = function(refDestructuringErrors) {\n    var node = this.startNode()\n    this.next()\n    node.argument = this.parseMaybeAssign(false, refDestructuringErrors)\n    return this.finishNode(node, \"SpreadElement\")\n  }\n\n  pp$2.parseRest = function(allowNonIdent) {\n    var node = this.startNode()\n    this.next()\n\n    // RestElement inside of a function parameter must be an identifier\n    if (allowNonIdent) node.argument = this.type === tt.name ? this.parseIdent() : this.unexpected()\n    else node.argument = this.type === tt.name || this.type === tt.bracketL ? this.parseBindingAtom() : this.unexpected()\n\n    return this.finishNode(node, \"RestElement\")\n  }\n\n  // Parses lvalue (assignable) atom.\n\n  pp$2.parseBindingAtom = function() {\n    if (this.options.ecmaVersion < 6) return this.parseIdent()\n    switch (this.type) {\n    case tt.name:\n      return this.parseIdent()\n\n    case tt.bracketL:\n      var node = this.startNode()\n      this.next()\n      node.elements = this.parseBindingList(tt.bracketR, true, true)\n      return this.finishNode(node, \"ArrayPattern\")\n\n    case tt.braceL:\n      return this.parseObj(true)\n\n    default:\n      this.unexpected()\n    }\n  }\n\n  pp$2.parseBindingList = function(close, allowEmpty, allowTrailingComma, allowNonIdent) {\n    var this$1 = this;\n\n    var elts = [], first = true\n    while (!this.eat(close)) {\n      if (first) first = false\n      else this$1.expect(tt.comma)\n      if (allowEmpty && this$1.type === tt.comma) {\n        elts.push(null)\n      } else if (allowTrailingComma && this$1.afterTrailingComma(close)) {\n        break\n      } else if (this$1.type === tt.ellipsis) {\n        var rest = this$1.parseRest(allowNonIdent)\n        this$1.parseBindingListItem(rest)\n        elts.push(rest)\n        if (this$1.type === tt.comma) this$1.raise(this$1.start, \"Comma is not permitted after the rest element\")\n        this$1.expect(close)\n        break\n      } else {\n        var elem = this$1.parseMaybeDefault(this$1.start, this$1.startLoc)\n        this$1.parseBindingListItem(elem)\n        elts.push(elem)\n      }\n    }\n    return elts\n  }\n\n  pp$2.parseBindingListItem = function(param) {\n    return param\n  }\n\n  // Parses assignment pattern around given atom if possible.\n\n  pp$2.parseMaybeDefault = function(startPos, startLoc, left) {\n    left = left || this.parseBindingAtom()\n    if (this.options.ecmaVersion < 6 || !this.eat(tt.eq)) return left\n    var node = this.startNodeAt(startPos, startLoc)\n    node.left = left\n    node.right = this.parseMaybeAssign()\n    return this.finishNode(node, \"AssignmentPattern\")\n  }\n\n  // Verify that a node is an lval  something that can be assigned\n  // to.\n\n  pp$2.checkLVal = function(expr, isBinding, checkClashes) {\n    var this$1 = this;\n\n    switch (expr.type) {\n    case \"Identifier\":\n      if (this.strict && this.reservedWordsStrictBind.test(expr.name))\n        this.raiseRecoverable(expr.start, (isBinding ? \"Binding \" : \"Assigning to \") + expr.name + \" in strict mode\")\n      if (checkClashes) {\n        if (has(checkClashes, expr.name))\n          this.raiseRecoverable(expr.start, \"Argument name clash\")\n        checkClashes[expr.name] = true\n      }\n      break\n\n    case \"MemberExpression\":\n      if (isBinding) this.raiseRecoverable(expr.start, (isBinding ? \"Binding\" : \"Assigning to\") + \" member expression\")\n      break\n\n    case \"ObjectPattern\":\n      for (var i = 0; i < expr.properties.length; i++)\n        this$1.checkLVal(expr.properties[i].value, isBinding, checkClashes)\n      break\n\n    case \"ArrayPattern\":\n      for (var i$1 = 0; i$1 < expr.elements.length; i$1++) {\n        var elem = expr.elements[i$1]\n        if (elem) this$1.checkLVal(elem, isBinding, checkClashes)\n      }\n      break\n\n    case \"AssignmentPattern\":\n      this.checkLVal(expr.left, isBinding, checkClashes)\n      break\n\n    case \"RestElement\":\n      this.checkLVal(expr.argument, isBinding, checkClashes)\n      break\n\n    case \"ParenthesizedExpression\":\n      this.checkLVal(expr.expression, isBinding, checkClashes)\n      break\n\n    default:\n      this.raise(expr.start, (isBinding ? \"Binding\" : \"Assigning to\") + \" rvalue\")\n    }\n  }\n\n  var pp$3 = Parser.prototype\n\n  // Check if property name clashes with already added.\n  // Object/class getters and setters are not allowed to clash \n  // either with each other or with an init property  and in\n  // strict mode, init properties are also not allowed to be repeated.\n\n  pp$3.checkPropClash = function(prop, propHash) {\n    if (this.options.ecmaVersion >= 6 && (prop.computed || prop.method || prop.shorthand))\n      return\n    var key = prop.key;\n    var name\n    switch (key.type) {\n    case \"Identifier\": name = key.name; break\n    case \"Literal\": name = String(key.value); break\n    default: return\n    }\n    var kind = prop.kind;\n    if (this.options.ecmaVersion >= 6) {\n      if (name === \"__proto__\" && kind === \"init\") {\n        if (propHash.proto) this.raiseRecoverable(key.start, \"Redefinition of __proto__ property\")\n        propHash.proto = true\n      }\n      return\n    }\n    name = \"$\" + name\n    var other = propHash[name]\n    if (other) {\n      var isGetSet = kind !== \"init\"\n      if ((this.strict || isGetSet) && other[kind] || !(isGetSet ^ other.init))\n        this.raiseRecoverable(key.start, \"Redefinition of property\")\n    } else {\n      other = propHash[name] = {\n        init: false,\n        get: false,\n        set: false\n      }\n    }\n    other[kind] = true\n  }\n\n  // ### Expression parsing\n\n  // These nest, from the most general expression type at the top to\n  // 'atomic', nondivisible expression types at the bottom. Most of\n  // the functions will simply let the function(s) below them parse,\n  // and, *if* the syntactic construct they handle is present, wrap\n  // the AST node that the inner parser gave them in another node.\n\n  // Parse a full expression. The optional arguments are used to\n  // forbid the `in` operator (in for loops initalization expressions)\n  // and provide reference for storing '=' operator inside shorthand\n  // property assignment in contexts where both object expression\n  // and object pattern might appear (so it's possible to raise\n  // delayed syntax error at correct position).\n\n  pp$3.parseExpression = function(noIn, refDestructuringErrors) {\n    var this$1 = this;\n\n    var startPos = this.start, startLoc = this.startLoc\n    var expr = this.parseMaybeAssign(noIn, refDestructuringErrors)\n    if (this.type === tt.comma) {\n      var node = this.startNodeAt(startPos, startLoc)\n      node.expressions = [expr]\n      while (this.eat(tt.comma)) node.expressions.push(this$1.parseMaybeAssign(noIn, refDestructuringErrors))\n      return this.finishNode(node, \"SequenceExpression\")\n    }\n    return expr\n  }\n\n  // Parse an assignment expression. This includes applications of\n  // operators like `+=`.\n\n  pp$3.parseMaybeAssign = function(noIn, refDestructuringErrors, afterLeftParse) {\n    if (this.inGenerator && this.isContextual(\"yield\")) return this.parseYield()\n\n    var ownDestructuringErrors = false\n    if (!refDestructuringErrors) {\n      refDestructuringErrors = new DestructuringErrors\n      ownDestructuringErrors = true\n    }\n    var startPos = this.start, startLoc = this.startLoc\n    if (this.type == tt.parenL || this.type == tt.name)\n      this.potentialArrowAt = this.start\n    var left = this.parseMaybeConditional(noIn, refDestructuringErrors)\n    if (afterLeftParse) left = afterLeftParse.call(this, left, startPos, startLoc)\n    if (this.type.isAssign) {\n      this.checkPatternErrors(refDestructuringErrors, true)\n      if (!ownDestructuringErrors) DestructuringErrors.call(refDestructuringErrors)\n      var node = this.startNodeAt(startPos, startLoc)\n      node.operator = this.value\n      node.left = this.type === tt.eq ? this.toAssignable(left) : left\n      refDestructuringErrors.shorthandAssign = 0 // reset because shorthand default was used correctly\n      this.checkLVal(left)\n      this.next()\n      node.right = this.parseMaybeAssign(noIn)\n      return this.finishNode(node, \"AssignmentExpression\")\n    } else {\n      if (ownDestructuringErrors) this.checkExpressionErrors(refDestructuringErrors, true)\n    }\n    return left\n  }\n\n  // Parse a ternary conditional (`?:`) operator.\n\n  pp$3.parseMaybeConditional = function(noIn, refDestructuringErrors) {\n    var startPos = this.start, startLoc = this.startLoc\n    var expr = this.parseExprOps(noIn, refDestructuringErrors)\n    if (this.checkExpressionErrors(refDestructuringErrors)) return expr\n    if (this.eat(tt.question)) {\n      var node = this.startNodeAt(startPos, startLoc)\n      node.test = expr\n      node.consequent = this.parseMaybeAssign()\n      this.expect(tt.colon)\n      node.alternate = this.parseMaybeAssign(noIn)\n      return this.finishNode(node, \"ConditionalExpression\")\n    }\n    return expr\n  }\n\n  // Start the precedence parser.\n\n  pp$3.parseExprOps = function(noIn, refDestructuringErrors) {\n    var startPos = this.start, startLoc = this.startLoc\n    var expr = this.parseMaybeUnary(refDestructuringErrors, false)\n    if (this.checkExpressionErrors(refDestructuringErrors)) return expr\n    return this.parseExprOp(expr, startPos, startLoc, -1, noIn)\n  }\n\n  // Parse binary operators with the operator precedence parsing\n  // algorithm. `left` is the left-hand side of the operator.\n  // `minPrec` provides context that allows the function to stop and\n  // defer further parser to one of its callers when it encounters an\n  // operator that has a lower precedence than the set it is parsing.\n\n  pp$3.parseExprOp = function(left, leftStartPos, leftStartLoc, minPrec, noIn) {\n    var prec = this.type.binop\n    if (prec != null && (!noIn || this.type !== tt._in)) {\n      if (prec > minPrec) {\n        var logical = this.type === tt.logicalOR || this.type === tt.logicalAND\n        var op = this.value\n        this.next()\n        var startPos = this.start, startLoc = this.startLoc\n        var right = this.parseExprOp(this.parseMaybeUnary(null, false), startPos, startLoc, prec, noIn)\n        var node = this.buildBinary(leftStartPos, leftStartLoc, left, right, op, logical)\n        return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec, noIn)\n      }\n    }\n    return left\n  }\n\n  pp$3.buildBinary = function(startPos, startLoc, left, right, op, logical) {\n    var node = this.startNodeAt(startPos, startLoc)\n    node.left = left\n    node.operator = op\n    node.right = right\n    return this.finishNode(node, logical ? \"LogicalExpression\" : \"BinaryExpression\")\n  }\n\n  // Parse unary operators, both prefix and postfix.\n\n  pp$3.parseMaybeUnary = function(refDestructuringErrors, sawUnary) {\n    var this$1 = this;\n\n    var startPos = this.start, startLoc = this.startLoc, expr\n    if (this.type.prefix) {\n      var node = this.startNode(), update = this.type === tt.incDec\n      node.operator = this.value\n      node.prefix = true\n      this.next()\n      node.argument = this.parseMaybeUnary(null, true)\n      this.checkExpressionErrors(refDestructuringErrors, true)\n      if (update) this.checkLVal(node.argument)\n      else if (this.strict && node.operator === \"delete\" &&\n               node.argument.type === \"Identifier\")\n        this.raiseRecoverable(node.start, \"Deleting local variable in strict mode\")\n      else sawUnary = true\n      expr = this.finishNode(node, update ? \"UpdateExpression\" : \"UnaryExpression\")\n    } else {\n      expr = this.parseExprSubscripts(refDestructuringErrors)\n      if (this.checkExpressionErrors(refDestructuringErrors)) return expr\n      while (this.type.postfix && !this.canInsertSemicolon()) {\n        var node$1 = this$1.startNodeAt(startPos, startLoc)\n        node$1.operator = this$1.value\n        node$1.prefix = false\n        node$1.argument = expr\n        this$1.checkLVal(expr)\n        this$1.next()\n        expr = this$1.finishNode(node$1, \"UpdateExpression\")\n      }\n    }\n\n    if (!sawUnary && this.eat(tt.starstar))\n      return this.buildBinary(startPos, startLoc, expr, this.parseMaybeUnary(null, false), \"**\", false)\n    else\n      return expr\n  }\n\n  // Parse call, dot, and `[]`-subscript expressions.\n\n  pp$3.parseExprSubscripts = function(refDestructuringErrors) {\n    var startPos = this.start, startLoc = this.startLoc\n    var expr = this.parseExprAtom(refDestructuringErrors)\n    var skipArrowSubscripts = expr.type === \"ArrowFunctionExpression\" && this.input.slice(this.lastTokStart, this.lastTokEnd) !== \")\"\n    if (this.checkExpressionErrors(refDestructuringErrors) || skipArrowSubscripts) return expr\n    return this.parseSubscripts(expr, startPos, startLoc)\n  }\n\n  pp$3.parseSubscripts = function(base, startPos, startLoc, noCalls) {\n    var this$1 = this;\n\n    for (;;) {\n      if (this$1.eat(tt.dot)) {\n        var node = this$1.startNodeAt(startPos, startLoc)\n        node.object = base\n        node.property = this$1.parseIdent(true)\n        node.computed = false\n        base = this$1.finishNode(node, \"MemberExpression\")\n      } else if (this$1.eat(tt.bracketL)) {\n        var node$1 = this$1.startNodeAt(startPos, startLoc)\n        node$1.object = base\n        node$1.property = this$1.parseExpression()\n        node$1.computed = true\n        this$1.expect(tt.bracketR)\n        base = this$1.finishNode(node$1, \"MemberExpression\")\n      } else if (!noCalls && this$1.eat(tt.parenL)) {\n        var node$2 = this$1.startNodeAt(startPos, startLoc)\n        node$2.callee = base\n        node$2.arguments = this$1.parseExprList(tt.parenR, false)\n        base = this$1.finishNode(node$2, \"CallExpression\")\n      } else if (this$1.type === tt.backQuote) {\n        var node$3 = this$1.startNodeAt(startPos, startLoc)\n        node$3.tag = base\n        node$3.quasi = this$1.parseTemplate()\n        base = this$1.finishNode(node$3, \"TaggedTemplateExpression\")\n      } else {\n        return base\n      }\n    }\n  }\n\n  // Parse an atomic expression  either a single token that is an\n  // expression, an expression started by a keyword like `function` or\n  // `new`, or an expression wrapped in punctuation like `()`, `[]`,\n  // or `{}`.\n\n  pp$3.parseExprAtom = function(refDestructuringErrors) {\n    var node, canBeArrow = this.potentialArrowAt == this.start\n    switch (this.type) {\n    case tt._super:\n      if (!this.inFunction)\n        this.raise(this.start, \"'super' outside of function or class\")\n\n    case tt._this:\n      var type = this.type === tt._this ? \"ThisExpression\" : \"Super\"\n      node = this.startNode()\n      this.next()\n      return this.finishNode(node, type)\n\n    case tt.name:\n      var startPos = this.start, startLoc = this.startLoc\n      var id = this.parseIdent(this.type !== tt.name)\n      if (canBeArrow && !this.canInsertSemicolon() && this.eat(tt.arrow))\n        return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id])\n      return id\n\n    case tt.regexp:\n      var value = this.value\n      node = this.parseLiteral(value.value)\n      node.regex = {pattern: value.pattern, flags: value.flags}\n      return node\n\n    case tt.num: case tt.string:\n      return this.parseLiteral(this.value)\n\n    case tt._null: case tt._true: case tt._false:\n      node = this.startNode()\n      node.value = this.type === tt._null ? null : this.type === tt._true\n      node.raw = this.type.keyword\n      this.next()\n      return this.finishNode(node, \"Literal\")\n\n    case tt.parenL:\n      return this.parseParenAndDistinguishExpression(canBeArrow)\n\n    case tt.bracketL:\n      node = this.startNode()\n      this.next()\n      node.elements = this.parseExprList(tt.bracketR, true, true, refDestructuringErrors)\n      return this.finishNode(node, \"ArrayExpression\")\n\n    case tt.braceL:\n      return this.parseObj(false, refDestructuringErrors)\n\n    case tt._function:\n      node = this.startNode()\n      this.next()\n      return this.parseFunction(node, false)\n\n    case tt._class:\n      return this.parseClass(this.startNode(), false)\n\n    case tt._new:\n      return this.parseNew()\n\n    case tt.backQuote:\n      return this.parseTemplate()\n\n    default:\n      this.unexpected()\n    }\n  }\n\n  pp$3.parseLiteral = function(value) {\n    var node = this.startNode()\n    node.value = value\n    node.raw = this.input.slice(this.start, this.end)\n    this.next()\n    return this.finishNode(node, \"Literal\")\n  }\n\n  pp$3.parseParenExpression = function() {\n    this.expect(tt.parenL)\n    var val = this.parseExpression()\n    this.expect(tt.parenR)\n    return val\n  }\n\n  pp$3.parseParenAndDistinguishExpression = function(canBeArrow) {\n    var this$1 = this;\n\n    var startPos = this.start, startLoc = this.startLoc, val\n    if (this.options.ecmaVersion >= 6) {\n      this.next()\n\n      var innerStartPos = this.start, innerStartLoc = this.startLoc\n      var exprList = [], first = true\n      var refDestructuringErrors = new DestructuringErrors, spreadStart, innerParenStart\n      while (this.type !== tt.parenR) {\n        first ? first = false : this$1.expect(tt.comma)\n        if (this$1.type === tt.ellipsis) {\n          spreadStart = this$1.start\n          exprList.push(this$1.parseParenItem(this$1.parseRest()))\n          break\n        } else {\n          if (this$1.type === tt.parenL && !innerParenStart) {\n            innerParenStart = this$1.start\n          }\n          exprList.push(this$1.parseMaybeAssign(false, refDestructuringErrors, this$1.parseParenItem))\n        }\n      }\n      var innerEndPos = this.start, innerEndLoc = this.startLoc\n      this.expect(tt.parenR)\n\n      if (canBeArrow && !this.canInsertSemicolon() && this.eat(tt.arrow)) {\n        this.checkPatternErrors(refDestructuringErrors, true)\n        if (innerParenStart) this.unexpected(innerParenStart)\n        return this.parseParenArrowList(startPos, startLoc, exprList)\n      }\n\n      if (!exprList.length) this.unexpected(this.lastTokStart)\n      if (spreadStart) this.unexpected(spreadStart)\n      this.checkExpressionErrors(refDestructuringErrors, true)\n\n      if (exprList.length > 1) {\n        val = this.startNodeAt(innerStartPos, innerStartLoc)\n        val.expressions = exprList\n        this.finishNodeAt(val, \"SequenceExpression\", innerEndPos, innerEndLoc)\n      } else {\n        val = exprList[0]\n      }\n    } else {\n      val = this.parseParenExpression()\n    }\n\n    if (this.options.preserveParens) {\n      var par = this.startNodeAt(startPos, startLoc)\n      par.expression = val\n      return this.finishNode(par, \"ParenthesizedExpression\")\n    } else {\n      return val\n    }\n  }\n\n  pp$3.parseParenItem = function(item) {\n    return item\n  }\n\n  pp$3.parseParenArrowList = function(startPos, startLoc, exprList) {\n    return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList)\n  }\n\n  // New's precedence is slightly tricky. It must allow its argument to\n  // be a `[]` or dot subscript expression, but not a call  at least,\n  // not without wrapping it in parentheses. Thus, it uses the noCalls\n  // argument to parseSubscripts to prevent it from consuming the\n  // argument list.\n\n  var empty$1 = []\n\n  pp$3.parseNew = function() {\n    var node = this.startNode()\n    var meta = this.parseIdent(true)\n    if (this.options.ecmaVersion >= 6 && this.eat(tt.dot)) {\n      node.meta = meta\n      node.property = this.parseIdent(true)\n      if (node.property.name !== \"target\")\n        this.raiseRecoverable(node.property.start, \"The only valid meta property for new is new.target\")\n      if (!this.inFunction)\n        this.raiseRecoverable(node.start, \"new.target can only be used in functions\")\n      return this.finishNode(node, \"MetaProperty\")\n    }\n    var startPos = this.start, startLoc = this.startLoc\n    node.callee = this.parseSubscripts(this.parseExprAtom(), startPos, startLoc, true)\n    if (this.eat(tt.parenL)) node.arguments = this.parseExprList(tt.parenR, false)\n    else node.arguments = empty$1\n    return this.finishNode(node, \"NewExpression\")\n  }\n\n  // Parse template expression.\n\n  pp$3.parseTemplateElement = function() {\n    var elem = this.startNode()\n    elem.value = {\n      raw: this.input.slice(this.start, this.end).replace(/\\r\\n?/g, '\\n'),\n      cooked: this.value\n    }\n    this.next()\n    elem.tail = this.type === tt.backQuote\n    return this.finishNode(elem, \"TemplateElement\")\n  }\n\n  pp$3.parseTemplate = function() {\n    var this$1 = this;\n\n    var node = this.startNode()\n    this.next()\n    node.expressions = []\n    var curElt = this.parseTemplateElement()\n    node.quasis = [curElt]\n    while (!curElt.tail) {\n      this$1.expect(tt.dollarBraceL)\n      node.expressions.push(this$1.parseExpression())\n      this$1.expect(tt.braceR)\n      node.quasis.push(curElt = this$1.parseTemplateElement())\n    }\n    this.next()\n    return this.finishNode(node, \"TemplateLiteral\")\n  }\n\n  // Parse an object literal or binding pattern.\n\n  pp$3.parseObj = function(isPattern, refDestructuringErrors) {\n    var this$1 = this;\n\n    var node = this.startNode(), first = true, propHash = {}\n    node.properties = []\n    this.next()\n    while (!this.eat(tt.braceR)) {\n      if (!first) {\n        this$1.expect(tt.comma)\n        if (this$1.afterTrailingComma(tt.braceR)) break\n      } else first = false\n\n      var prop = this$1.startNode(), isGenerator, startPos, startLoc\n      if (this$1.options.ecmaVersion >= 6) {\n        prop.method = false\n        prop.shorthand = false\n        if (isPattern || refDestructuringErrors) {\n          startPos = this$1.start\n          startLoc = this$1.startLoc\n        }\n        if (!isPattern)\n          isGenerator = this$1.eat(tt.star)\n      }\n      this$1.parsePropertyName(prop)\n      this$1.parsePropertyValue(prop, isPattern, isGenerator, startPos, startLoc, refDestructuringErrors)\n      this$1.checkPropClash(prop, propHash)\n      node.properties.push(this$1.finishNode(prop, \"Property\"))\n    }\n    return this.finishNode(node, isPattern ? \"ObjectPattern\" : \"ObjectExpression\")\n  }\n\n  pp$3.parsePropertyValue = function(prop, isPattern, isGenerator, startPos, startLoc, refDestructuringErrors) {\n    if (this.eat(tt.colon)) {\n      prop.value = isPattern ? this.parseMaybeDefault(this.start, this.startLoc) : this.parseMaybeAssign(false, refDestructuringErrors)\n      prop.kind = \"init\"\n    } else if (this.options.ecmaVersion >= 6 && this.type === tt.parenL) {\n      if (isPattern) this.unexpected()\n      prop.kind = \"init\"\n      prop.method = true\n      prop.value = this.parseMethod(isGenerator)\n    } else if (this.options.ecmaVersion >= 5 && !prop.computed && prop.key.type === \"Identifier\" &&\n               (prop.key.name === \"get\" || prop.key.name === \"set\") &&\n               (this.type != tt.comma && this.type != tt.braceR)) {\n      if (isGenerator || isPattern) this.unexpected()\n      prop.kind = prop.key.name\n      this.parsePropertyName(prop)\n      prop.value = this.parseMethod(false)\n      var paramCount = prop.kind === \"get\" ? 0 : 1\n      if (prop.value.params.length !== paramCount) {\n        var start = prop.value.start\n        if (prop.kind === \"get\")\n          this.raiseRecoverable(start, \"getter should have no params\")\n        else\n          this.raiseRecoverable(start, \"setter should have exactly one param\")\n      }\n      if (prop.kind === \"set\" && prop.value.params[0].type === \"RestElement\")\n        this.raiseRecoverable(prop.value.params[0].start, \"Setter cannot use rest params\")\n    } else if (this.options.ecmaVersion >= 6 && !prop.computed && prop.key.type === \"Identifier\") {\n      if (this.keywords.test(prop.key.name) ||\n          (this.strict ? this.reservedWordsStrictBind : this.reservedWords).test(prop.key.name) ||\n          (this.inGenerator && prop.key.name == \"yield\"))\n        this.raiseRecoverable(prop.key.start, \"'\" + prop.key.name + \"' can not be used as shorthand property\")\n      prop.kind = \"init\"\n      if (isPattern) {\n        prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key)\n      } else if (this.type === tt.eq && refDestructuringErrors) {\n        if (!refDestructuringErrors.shorthandAssign)\n          refDestructuringErrors.shorthandAssign = this.start\n        prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key)\n      } else {\n        prop.value = prop.key\n      }\n      prop.shorthand = true\n    } else this.unexpected()\n  }\n\n  pp$3.parsePropertyName = function(prop) {\n    if (this.options.ecmaVersion >= 6) {\n      if (this.eat(tt.bracketL)) {\n        prop.computed = true\n        prop.key = this.parseMaybeAssign()\n        this.expect(tt.bracketR)\n        return prop.key\n      } else {\n        prop.computed = false\n      }\n    }\n    return prop.key = this.type === tt.num || this.type === tt.string ? this.parseExprAtom() : this.parseIdent(true)\n  }\n\n  // Initialize empty function node.\n\n  pp$3.initFunction = function(node) {\n    node.id = null\n    if (this.options.ecmaVersion >= 6) {\n      node.generator = false\n      node.expression = false\n    }\n  }\n\n  // Parse object or class method.\n\n  pp$3.parseMethod = function(isGenerator) {\n    var node = this.startNode(), oldInGen = this.inGenerator\n    this.inGenerator = isGenerator\n    this.initFunction(node)\n    this.expect(tt.parenL)\n    node.params = this.parseBindingList(tt.parenR, false, false)\n    if (this.options.ecmaVersion >= 6)\n      node.generator = isGenerator\n    this.parseFunctionBody(node, false)\n    this.inGenerator = oldInGen\n    return this.finishNode(node, \"FunctionExpression\")\n  }\n\n  // Parse arrow function expression with given parameters.\n\n  pp$3.parseArrowExpression = function(node, params) {\n    var oldInGen = this.inGenerator\n    this.inGenerator = false\n    this.initFunction(node)\n    node.params = this.toAssignableList(params, true)\n    this.parseFunctionBody(node, true)\n    this.inGenerator = oldInGen\n    return this.finishNode(node, \"ArrowFunctionExpression\")\n  }\n\n  // Parse function body and check parameters.\n\n  pp$3.parseFunctionBody = function(node, isArrowFunction) {\n    var isExpression = isArrowFunction && this.type !== tt.braceL\n\n    if (isExpression) {\n      node.body = this.parseMaybeAssign()\n      node.expression = true\n    } else {\n      // Start a new scope with regard to labels and the `inFunction`\n      // flag (restore them to their old value afterwards).\n      var oldInFunc = this.inFunction, oldLabels = this.labels\n      this.inFunction = true; this.labels = []\n      node.body = this.parseBlock(true)\n      node.expression = false\n      this.inFunction = oldInFunc; this.labels = oldLabels\n    }\n\n    // If this is a strict mode function, verify that argument names\n    // are not repeated, and it does not try to bind the words `eval`\n    // or `arguments`.\n    var useStrict = (!isExpression && node.body.body.length && this.isUseStrict(node.body.body[0])) ? node.body.body[0] : null;\n    if (this.strict || useStrict) {\n      var oldStrict = this.strict\n      this.strict = true\n      if (node.id)\n        this.checkLVal(node.id, true)\n      this.checkParams(node, useStrict)\n      this.strict = oldStrict\n    } else if (isArrowFunction) {\n      this.checkParams(node, useStrict)\n    }\n  }\n\n  // Checks function params for various disallowed patterns such as using \"eval\"\n  // or \"arguments\" and duplicate parameters.\n\n  pp$3.checkParams = function(node, useStrict) {\n      var this$1 = this;\n\n      var nameHash = {}\n      for (var i = 0; i < node.params.length; i++) {\n        if (useStrict && this$1.options.ecmaVersion >= 7 && node.params[i].type !== \"Identifier\")\n          this$1.raiseRecoverable(useStrict.start, \"Illegal 'use strict' directive in function with non-simple parameter list\");\n        this$1.checkLVal(node.params[i], true, nameHash)\n      }\n  }\n\n  // Parses a comma-separated list of expressions, and returns them as\n  // an array. `close` is the token type that ends the list, and\n  // `allowEmpty` can be turned on to allow subsequent commas with\n  // nothing in between them to be parsed as `null` (which is needed\n  // for array literals).\n\n  pp$3.parseExprList = function(close, allowTrailingComma, allowEmpty, refDestructuringErrors) {\n    var this$1 = this;\n\n    var elts = [], first = true\n    while (!this.eat(close)) {\n      if (!first) {\n        this$1.expect(tt.comma)\n        if (allowTrailingComma && this$1.afterTrailingComma(close)) break\n      } else first = false\n\n      var elt\n      if (allowEmpty && this$1.type === tt.comma)\n        elt = null\n      else if (this$1.type === tt.ellipsis) {\n        elt = this$1.parseSpread(refDestructuringErrors)\n        if (this$1.type === tt.comma && refDestructuringErrors && !refDestructuringErrors.trailingComma) {\n          refDestructuringErrors.trailingComma = this$1.lastTokStart\n        }\n      } else\n        elt = this$1.parseMaybeAssign(false, refDestructuringErrors)\n      elts.push(elt)\n    }\n    return elts\n  }\n\n  // Parse the next token as an identifier. If `liberal` is true (used\n  // when parsing properties), it will also convert keywords into\n  // identifiers.\n\n  pp$3.parseIdent = function(liberal) {\n    var node = this.startNode()\n    if (liberal && this.options.allowReserved == \"never\") liberal = false\n    if (this.type === tt.name) {\n      if (!liberal && (this.strict ? this.reservedWordsStrict : this.reservedWords).test(this.value) &&\n          (this.options.ecmaVersion >= 6 ||\n           this.input.slice(this.start, this.end).indexOf(\"\\\\\") == -1))\n        this.raiseRecoverable(this.start, \"The keyword '\" + this.value + \"' is reserved\")\n      if (!liberal && this.inGenerator && this.value === \"yield\")\n        this.raiseRecoverable(this.start, \"Can not use 'yield' as identifier inside a generator\")\n      node.name = this.value\n    } else if (liberal && this.type.keyword) {\n      node.name = this.type.keyword\n    } else {\n      this.unexpected()\n    }\n    this.next()\n    return this.finishNode(node, \"Identifier\")\n  }\n\n  // Parses yield expression inside generator.\n\n  pp$3.parseYield = function() {\n    var node = this.startNode()\n    this.next()\n    if (this.type == tt.semi || this.canInsertSemicolon() || (this.type != tt.star && !this.type.startsExpr)) {\n      node.delegate = false\n      node.argument = null\n    } else {\n      node.delegate = this.eat(tt.star)\n      node.argument = this.parseMaybeAssign()\n    }\n    return this.finishNode(node, \"YieldExpression\")\n  }\n\n  var pp$4 = Parser.prototype\n\n  // This function is used to raise exceptions on parse errors. It\n  // takes an offset integer (into the current `input`) to indicate\n  // the location of the error, attaches the position to the end\n  // of the error message, and then raises a `SyntaxError` with that\n  // message.\n\n  pp$4.raise = function(pos, message) {\n    var loc = getLineInfo(this.input, pos)\n    message += \" (\" + loc.line + \":\" + loc.column + \")\"\n    var err = new SyntaxError(message)\n    err.pos = pos; err.loc = loc; err.raisedAt = this.pos\n    throw err\n  }\n\n  pp$4.raiseRecoverable = pp$4.raise\n\n  pp$4.curPosition = function() {\n    if (this.options.locations) {\n      return new Position(this.curLine, this.pos - this.lineStart)\n    }\n  }\n\n  var Node = function Node(parser, pos, loc) {\n    this.type = \"\"\n    this.start = pos\n    this.end = 0\n    if (parser.options.locations)\n      this.loc = new SourceLocation(parser, loc)\n    if (parser.options.directSourceFile)\n      this.sourceFile = parser.options.directSourceFile\n    if (parser.options.ranges)\n      this.range = [pos, 0]\n  };\n\n  // Start an AST node, attaching a start offset.\n\n  var pp$5 = Parser.prototype\n\n  pp$5.startNode = function() {\n    return new Node(this, this.start, this.startLoc)\n  }\n\n  pp$5.startNodeAt = function(pos, loc) {\n    return new Node(this, pos, loc)\n  }\n\n  // Finish an AST node, adding `type` and `end` properties.\n\n  function finishNodeAt(node, type, pos, loc) {\n    node.type = type\n    node.end = pos\n    if (this.options.locations)\n      node.loc.end = loc\n    if (this.options.ranges)\n      node.range[1] = pos\n    return node\n  }\n\n  pp$5.finishNode = function(node, type) {\n    return finishNodeAt.call(this, node, type, this.lastTokEnd, this.lastTokEndLoc)\n  }\n\n  // Finish node at given position\n\n  pp$5.finishNodeAt = function(node, type, pos, loc) {\n    return finishNodeAt.call(this, node, type, pos, loc)\n  }\n\n  var TokContext = function TokContext(token, isExpr, preserveSpace, override) {\n    this.token = token\n    this.isExpr = !!isExpr\n    this.preserveSpace = !!preserveSpace\n    this.override = override\n  };\n\n  var types = {\n    b_stat: new TokContext(\"{\", false),\n    b_expr: new TokContext(\"{\", true),\n    b_tmpl: new TokContext(\"${\", true),\n    p_stat: new TokContext(\"(\", false),\n    p_expr: new TokContext(\"(\", true),\n    q_tmpl: new TokContext(\"`\", true, true, function (p) { return p.readTmplToken(); }),\n    f_expr: new TokContext(\"function\", true)\n  }\n\n  var pp$6 = Parser.prototype\n\n  pp$6.initialContext = function() {\n    return [types.b_stat]\n  }\n\n  pp$6.braceIsBlock = function(prevType) {\n    if (prevType === tt.colon) {\n      var parent = this.curContext()\n      if (parent === types.b_stat || parent === types.b_expr)\n        return !parent.isExpr\n    }\n    if (prevType === tt._return)\n      return lineBreak.test(this.input.slice(this.lastTokEnd, this.start))\n    if (prevType === tt._else || prevType === tt.semi || prevType === tt.eof || prevType === tt.parenR)\n      return true\n    if (prevType == tt.braceL)\n      return this.curContext() === types.b_stat\n    return !this.exprAllowed\n  }\n\n  pp$6.updateContext = function(prevType) {\n    var update, type = this.type\n    if (type.keyword && prevType == tt.dot)\n      this.exprAllowed = false\n    else if (update = type.updateContext)\n      update.call(this, prevType)\n    else\n      this.exprAllowed = type.beforeExpr\n  }\n\n  // Token-specific context update code\n\n  tt.parenR.updateContext = tt.braceR.updateContext = function() {\n    if (this.context.length == 1) {\n      this.exprAllowed = true\n      return\n    }\n    var out = this.context.pop()\n    if (out === types.b_stat && this.curContext() === types.f_expr) {\n      this.context.pop()\n      this.exprAllowed = false\n    } else if (out === types.b_tmpl) {\n      this.exprAllowed = true\n    } else {\n      this.exprAllowed = !out.isExpr\n    }\n  }\n\n  tt.braceL.updateContext = function(prevType) {\n    this.context.push(this.braceIsBlock(prevType) ? types.b_stat : types.b_expr)\n    this.exprAllowed = true\n  }\n\n  tt.dollarBraceL.updateContext = function() {\n    this.context.push(types.b_tmpl)\n    this.exprAllowed = true\n  }\n\n  tt.parenL.updateContext = function(prevType) {\n    var statementParens = prevType === tt._if || prevType === tt._for || prevType === tt._with || prevType === tt._while\n    this.context.push(statementParens ? types.p_stat : types.p_expr)\n    this.exprAllowed = true\n  }\n\n  tt.incDec.updateContext = function() {\n    // tokExprAllowed stays unchanged\n  }\n\n  tt._function.updateContext = function(prevType) {\n    if (prevType.beforeExpr && prevType !== tt.semi && prevType !== tt._else &&\n        !((prevType === tt.colon || prevType === tt.braceL) && this.curContext() === types.b_stat))\n      this.context.push(types.f_expr)\n    this.exprAllowed = false\n  }\n\n  tt.backQuote.updateContext = function() {\n    if (this.curContext() === types.q_tmpl)\n      this.context.pop()\n    else\n      this.context.push(types.q_tmpl)\n    this.exprAllowed = false\n  }\n\n  // Object type used to represent tokens. Note that normally, tokens\n  // simply exist as properties on the parser object. This is only\n  // used for the onToken callback and the external tokenizer.\n\n  var Token = function Token(p) {\n    this.type = p.type\n    this.value = p.value\n    this.start = p.start\n    this.end = p.end\n    if (p.options.locations)\n      this.loc = new SourceLocation(p, p.startLoc, p.endLoc)\n    if (p.options.ranges)\n      this.range = [p.start, p.end]\n  };\n\n  // ## Tokenizer\n\n  var pp$7 = Parser.prototype\n\n  // Are we running under Rhino?\n  var isRhino = typeof Packages == \"object\" && Object.prototype.toString.call(Packages) == \"[object JavaPackage]\"\n\n  // Move to the next token\n\n  pp$7.next = function() {\n    if (this.options.onToken)\n      this.options.onToken(new Token(this))\n\n    this.lastTokEnd = this.end\n    this.lastTokStart = this.start\n    this.lastTokEndLoc = this.endLoc\n    this.lastTokStartLoc = this.startLoc\n    this.nextToken()\n  }\n\n  pp$7.getToken = function() {\n    this.next()\n    return new Token(this)\n  }\n\n  // If we're in an ES6 environment, make parsers iterable\n  if (typeof Symbol !== \"undefined\")\n    pp$7[Symbol.iterator] = function () {\n      var self = this\n      return {next: function () {\n        var token = self.getToken()\n        return {\n          done: token.type === tt.eof,\n          value: token\n        }\n      }}\n    }\n\n  // Toggle strict mode. Re-reads the next number or string to please\n  // pedantic tests (`\"use strict\"; 010;` should fail).\n\n  pp$7.setStrict = function(strict) {\n    var this$1 = this;\n\n    this.strict = strict\n    if (this.type !== tt.num && this.type !== tt.string) return\n    this.pos = this.start\n    if (this.options.locations) {\n      while (this.pos < this.lineStart) {\n        this$1.lineStart = this$1.input.lastIndexOf(\"\\n\", this$1.lineStart - 2) + 1\n        --this$1.curLine\n      }\n    }\n    this.nextToken()\n  }\n\n  pp$7.curContext = function() {\n    return this.context[this.context.length - 1]\n  }\n\n  // Read a single token, updating the parser object's token-related\n  // properties.\n\n  pp$7.nextToken = function() {\n    var curContext = this.curContext()\n    if (!curContext || !curContext.preserveSpace) this.skipSpace()\n\n    this.start = this.pos\n    if (this.options.locations) this.startLoc = this.curPosition()\n    if (this.pos >= this.input.length) return this.finishToken(tt.eof)\n\n    if (curContext.override) return curContext.override(this)\n    else this.readToken(this.fullCharCodeAtPos())\n  }\n\n  pp$7.readToken = function(code) {\n    // Identifier or keyword. '\\uXXXX' sequences are allowed in\n    // identifiers, so '\\' also dispatches to that.\n    if (isIdentifierStart(code, this.options.ecmaVersion >= 6) || code === 92 /* '\\' */)\n      return this.readWord()\n\n    return this.getTokenFromCode(code)\n  }\n\n  pp$7.fullCharCodeAtPos = function() {\n    var code = this.input.charCodeAt(this.pos)\n    if (code <= 0xd7ff || code >= 0xe000) return code\n    var next = this.input.charCodeAt(this.pos + 1)\n    return (code << 10) + next - 0x35fdc00\n  }\n\n  pp$7.skipBlockComment = function() {\n    var this$1 = this;\n\n    var startLoc = this.options.onComment && this.curPosition()\n    var start = this.pos, end = this.input.indexOf(\"*/\", this.pos += 2)\n    if (end === -1) this.raise(this.pos - 2, \"Unterminated comment\")\n    this.pos = end + 2\n    if (this.options.locations) {\n      lineBreakG.lastIndex = start\n      var match\n      while ((match = lineBreakG.exec(this.input)) && match.index < this.pos) {\n        ++this$1.curLine\n        this$1.lineStart = match.index + match[0].length\n      }\n    }\n    if (this.options.onComment)\n      this.options.onComment(true, this.input.slice(start + 2, end), start, this.pos,\n                             startLoc, this.curPosition())\n  }\n\n  pp$7.skipLineComment = function(startSkip) {\n    var this$1 = this;\n\n    var start = this.pos\n    var startLoc = this.options.onComment && this.curPosition()\n    var ch = this.input.charCodeAt(this.pos+=startSkip)\n    while (this.pos < this.input.length && ch !== 10 && ch !== 13 && ch !== 8232 && ch !== 8233) {\n      ++this$1.pos\n      ch = this$1.input.charCodeAt(this$1.pos)\n    }\n    if (this.options.onComment)\n      this.options.onComment(false, this.input.slice(start + startSkip, this.pos), start, this.pos,\n                             startLoc, this.curPosition())\n  }\n\n  // Called at the start of the parse and after every token. Skips\n  // whitespace and comments, and.\n\n  pp$7.skipSpace = function() {\n    var this$1 = this;\n\n    loop: while (this.pos < this.input.length) {\n      var ch = this$1.input.charCodeAt(this$1.pos)\n      switch (ch) {\n        case 32: case 160: // ' '\n          ++this$1.pos\n          break\n        case 13:\n          if (this$1.input.charCodeAt(this$1.pos + 1) === 10) {\n            ++this$1.pos\n          }\n        case 10: case 8232: case 8233:\n          ++this$1.pos\n          if (this$1.options.locations) {\n            ++this$1.curLine\n            this$1.lineStart = this$1.pos\n          }\n          break\n        case 47: // '/'\n          switch (this$1.input.charCodeAt(this$1.pos + 1)) {\n            case 42: // '*'\n              this$1.skipBlockComment()\n              break\n            case 47:\n              this$1.skipLineComment(2)\n              break\n            default:\n              break loop\n          }\n          break\n        default:\n          if (ch > 8 && ch < 14 || ch >= 5760 && nonASCIIwhitespace.test(String.fromCharCode(ch))) {\n            ++this$1.pos\n          } else {\n            break loop\n          }\n      }\n    }\n  }\n\n  // Called at the end of every token. Sets `end`, `val`, and\n  // maintains `context` and `exprAllowed`, and skips the space after\n  // the token, so that the next one's `start` will point at the\n  // right position.\n\n  pp$7.finishToken = function(type, val) {\n    this.end = this.pos\n    if (this.options.locations) this.endLoc = this.curPosition()\n    var prevType = this.type\n    this.type = type\n    this.value = val\n\n    this.updateContext(prevType)\n  }\n\n  // ### Token reading\n\n  // This is the function that is called to fetch the next token. It\n  // is somewhat obscure, because it works in character codes rather\n  // than characters, and because operator parsing has been inlined\n  // into it.\n  //\n  // All in the name of speed.\n  //\n  pp$7.readToken_dot = function() {\n    var next = this.input.charCodeAt(this.pos + 1)\n    if (next >= 48 && next <= 57) return this.readNumber(true)\n    var next2 = this.input.charCodeAt(this.pos + 2)\n    if (this.options.ecmaVersion >= 6 && next === 46 && next2 === 46) { // 46 = dot '.'\n      this.pos += 3\n      return this.finishToken(tt.ellipsis)\n    } else {\n      ++this.pos\n      return this.finishToken(tt.dot)\n    }\n  }\n\n  pp$7.readToken_slash = function() { // '/'\n    var next = this.input.charCodeAt(this.pos + 1)\n    if (this.exprAllowed) {++this.pos; return this.readRegexp()}\n    if (next === 61) return this.finishOp(tt.assign, 2)\n    return this.finishOp(tt.slash, 1)\n  }\n\n  pp$7.readToken_mult_modulo_exp = function(code) { // '%*'\n    var next = this.input.charCodeAt(this.pos + 1)\n    var size = 1\n    var tokentype = code === 42 ? tt.star : tt.modulo\n\n    // exponentiation operator ** and **=\n    if (this.options.ecmaVersion >= 7 && next === 42) {\n      ++size\n      tokentype = tt.starstar\n      next = this.input.charCodeAt(this.pos + 2)\n    }\n\n    if (next === 61) return this.finishOp(tt.assign, size + 1)\n    return this.finishOp(tokentype, size)\n  }\n\n  pp$7.readToken_pipe_amp = function(code) { // '|&'\n    var next = this.input.charCodeAt(this.pos + 1)\n    if (next === code) return this.finishOp(code === 124 ? tt.logicalOR : tt.logicalAND, 2)\n    if (next === 61) return this.finishOp(tt.assign, 2)\n    return this.finishOp(code === 124 ? tt.bitwiseOR : tt.bitwiseAND, 1)\n  }\n\n  pp$7.readToken_caret = function() { // '^'\n    var next = this.input.charCodeAt(this.pos + 1)\n    if (next === 61) return this.finishOp(tt.assign, 2)\n    return this.finishOp(tt.bitwiseXOR, 1)\n  }\n\n  pp$7.readToken_plus_min = function(code) { // '+-'\n    var next = this.input.charCodeAt(this.pos + 1)\n    if (next === code) {\n      if (next == 45 && this.input.charCodeAt(this.pos + 2) == 62 &&\n          lineBreak.test(this.input.slice(this.lastTokEnd, this.pos))) {\n        // A `-->` line comment\n        this.skipLineComment(3)\n        this.skipSpace()\n        return this.nextToken()\n      }\n      return this.finishOp(tt.incDec, 2)\n    }\n    if (next === 61) return this.finishOp(tt.assign, 2)\n    return this.finishOp(tt.plusMin, 1)\n  }\n\n  pp$7.readToken_lt_gt = function(code) { // '<>'\n    var next = this.input.charCodeAt(this.pos + 1)\n    var size = 1\n    if (next === code) {\n      size = code === 62 && this.input.charCodeAt(this.pos + 2) === 62 ? 3 : 2\n      if (this.input.charCodeAt(this.pos + size) === 61) return this.finishOp(tt.assign, size + 1)\n      return this.finishOp(tt.bitShift, size)\n    }\n    if (next == 33 && code == 60 && this.input.charCodeAt(this.pos + 2) == 45 &&\n        this.input.charCodeAt(this.pos + 3) == 45) {\n      if (this.inModule) this.unexpected()\n      // `<!--`, an XML-style comment that should be interpreted as a line comment\n      this.skipLineComment(4)\n      this.skipSpace()\n      return this.nextToken()\n    }\n    if (next === 61) size = 2\n    return this.finishOp(tt.relational, size)\n  }\n\n  pp$7.readToken_eq_excl = function(code) { // '=!'\n    var next = this.input.charCodeAt(this.pos + 1)\n    if (next === 61) return this.finishOp(tt.equality, this.input.charCodeAt(this.pos + 2) === 61 ? 3 : 2)\n    if (code === 61 && next === 62 && this.options.ecmaVersion >= 6) { // '=>'\n      this.pos += 2\n      return this.finishToken(tt.arrow)\n    }\n    return this.finishOp(code === 61 ? tt.eq : tt.prefix, 1)\n  }\n\n  pp$7.getTokenFromCode = function(code) {\n    switch (code) {\n      // The interpretation of a dot depends on whether it is followed\n      // by a digit or another two dots.\n    case 46: // '.'\n      return this.readToken_dot()\n\n      // Punctuation tokens.\n    case 40: ++this.pos; return this.finishToken(tt.parenL)\n    case 41: ++this.pos; return this.finishToken(tt.parenR)\n    case 59: ++this.pos; return this.finishToken(tt.semi)\n    case 44: ++this.pos; return this.finishToken(tt.comma)\n    case 91: ++this.pos; return this.finishToken(tt.bracketL)\n    case 93: ++this.pos; return this.finishToken(tt.bracketR)\n    case 123: ++this.pos; return this.finishToken(tt.braceL)\n    case 125: ++this.pos; return this.finishToken(tt.braceR)\n    case 58: ++this.pos; return this.finishToken(tt.colon)\n    case 63: ++this.pos; return this.finishToken(tt.question)\n\n    case 96: // '`'\n      if (this.options.ecmaVersion < 6) break\n      ++this.pos\n      return this.finishToken(tt.backQuote)\n\n    case 48: // '0'\n      var next = this.input.charCodeAt(this.pos + 1)\n      if (next === 120 || next === 88) return this.readRadixNumber(16) // '0x', '0X' - hex number\n      if (this.options.ecmaVersion >= 6) {\n        if (next === 111 || next === 79) return this.readRadixNumber(8) // '0o', '0O' - octal number\n        if (next === 98 || next === 66) return this.readRadixNumber(2) // '0b', '0B' - binary number\n      }\n      // Anything else beginning with a digit is an integer, octal\n      // number, or float.\n    case 49: case 50: case 51: case 52: case 53: case 54: case 55: case 56: case 57: // 1-9\n      return this.readNumber(false)\n\n      // Quotes produce strings.\n    case 34: case 39: // '\"', \"'\"\n      return this.readString(code)\n\n      // Operators are parsed inline in tiny state machines. '=' (61) is\n      // often referred to. `finishOp` simply skips the amount of\n      // characters it is given as second argument, and returns a token\n      // of the type given by its first argument.\n\n    case 47: // '/'\n      return this.readToken_slash()\n\n    case 37: case 42: // '%*'\n      return this.readToken_mult_modulo_exp(code)\n\n    case 124: case 38: // '|&'\n      return this.readToken_pipe_amp(code)\n\n    case 94: // '^'\n      return this.readToken_caret()\n\n    case 43: case 45: // '+-'\n      return this.readToken_plus_min(code)\n\n    case 60: case 62: // '<>'\n      return this.readToken_lt_gt(code)\n\n    case 61: case 33: // '=!'\n      return this.readToken_eq_excl(code)\n\n    case 126: // '~'\n      return this.finishOp(tt.prefix, 1)\n    }\n\n    this.raise(this.pos, \"Unexpected character '\" + codePointToString(code) + \"'\")\n  }\n\n  pp$7.finishOp = function(type, size) {\n    var str = this.input.slice(this.pos, this.pos + size)\n    this.pos += size\n    return this.finishToken(type, str)\n  }\n\n  // Parse a regular expression. Some context-awareness is necessary,\n  // since a '/' inside a '[]' set does not end the expression.\n\n  function tryCreateRegexp(src, flags, throwErrorAt, parser) {\n    try {\n      return new RegExp(src, flags)\n    } catch (e) {\n      if (throwErrorAt !== undefined) {\n        if (e instanceof SyntaxError) parser.raise(throwErrorAt, \"Error parsing regular expression: \" + e.message)\n        throw e\n      }\n    }\n  }\n\n  var regexpUnicodeSupport = !!tryCreateRegexp(\"\\uffff\", \"u\")\n\n  pp$7.readRegexp = function() {\n    var this$1 = this;\n\n    var escaped, inClass, start = this.pos\n    for (;;) {\n      if (this$1.pos >= this$1.input.length) this$1.raise(start, \"Unterminated regular expression\")\n      var ch = this$1.input.charAt(this$1.pos)\n      if (lineBreak.test(ch)) this$1.raise(start, \"Unterminated regular expression\")\n      if (!escaped) {\n        if (ch === \"[\") inClass = true\n        else if (ch === \"]\" && inClass) inClass = false\n        else if (ch === \"/\" && !inClass) break\n        escaped = ch === \"\\\\\"\n      } else escaped = false\n      ++this$1.pos\n    }\n    var content = this.input.slice(start, this.pos)\n    ++this.pos\n    // Need to use `readWord1` because '\\uXXXX' sequences are allowed\n    // here (don't ask).\n    var mods = this.readWord1()\n    var tmp = content, tmpFlags = \"\"\n    if (mods) {\n      var validFlags = /^[gim]*$/\n      if (this.options.ecmaVersion >= 6) validFlags = /^[gimuy]*$/\n      if (!validFlags.test(mods)) this.raise(start, \"Invalid regular expression flag\")\n      if (mods.indexOf(\"u\") >= 0) {\n        if (regexpUnicodeSupport) {\n          tmpFlags = \"u\"\n        } else {\n          // Replace each astral symbol and every Unicode escape sequence that\n          // possibly represents an astral symbol or a paired surrogate with a\n          // single ASCII symbol to avoid throwing on regular expressions that\n          // are only valid in combination with the `/u` flag.\n          // Note: replacing with the ASCII symbol `x` might cause false\n          // negatives in unlikely scenarios. For example, `[\\u{61}-b]` is a\n          // perfectly valid pattern that is equivalent to `[a-b]`, but it would\n          // be replaced by `[x-b]` which throws an error.\n          tmp = tmp.replace(/\\\\u\\{([0-9a-fA-F]+)\\}/g, function (_match, code, offset) {\n            code = Number(\"0x\" + code)\n            if (code > 0x10FFFF) this$1.raise(start + offset + 3, \"Code point out of bounds\")\n            return \"x\"\n          })\n          tmp = tmp.replace(/\\\\u([a-fA-F0-9]{4})|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g, \"x\")\n          tmpFlags = tmpFlags.replace(\"u\", \"\")\n        }\n      }\n    }\n    // Detect invalid regular expressions.\n    var value = null\n    // Rhino's regular expression parser is flaky and throws uncatchable exceptions,\n    // so don't do detection if we are running under Rhino\n    if (!isRhino) {\n      tryCreateRegexp(tmp, tmpFlags, start, this)\n      // Get a regular expression object for this pattern-flag pair, or `null` in\n      // case the current environment doesn't support the flags it uses.\n      value = tryCreateRegexp(content, mods)\n    }\n    return this.finishToken(tt.regexp, {pattern: content, flags: mods, value: value})\n  }\n\n  // Read an integer in the given radix. Return null if zero digits\n  // were read, the integer value otherwise. When `len` is given, this\n  // will return `null` unless the integer has exactly `len` digits.\n\n  pp$7.readInt = function(radix, len) {\n    var this$1 = this;\n\n    var start = this.pos, total = 0\n    for (var i = 0, e = len == null ? Infinity : len; i < e; ++i) {\n      var code = this$1.input.charCodeAt(this$1.pos), val\n      if (code >= 97) val = code - 97 + 10 // a\n      else if (code >= 65) val = code - 65 + 10 // A\n      else if (code >= 48 && code <= 57) val = code - 48 // 0-9\n      else val = Infinity\n      if (val >= radix) break\n      ++this$1.pos\n      total = total * radix + val\n    }\n    if (this.pos === start || len != null && this.pos - start !== len) return null\n\n    return total\n  }\n\n  pp$7.readRadixNumber = function(radix) {\n    this.pos += 2 // 0x\n    var val = this.readInt(radix)\n    if (val == null) this.raise(this.start + 2, \"Expected number in radix \" + radix)\n    if (isIdentifierStart(this.fullCharCodeAtPos())) this.raise(this.pos, \"Identifier directly after number\")\n    return this.finishToken(tt.num, val)\n  }\n\n  // Read an integer, octal integer, or floating-point number.\n\n  pp$7.readNumber = function(startsWithDot) {\n    var start = this.pos, isFloat = false, octal = this.input.charCodeAt(this.pos) === 48\n    if (!startsWithDot && this.readInt(10) === null) this.raise(start, \"Invalid number\")\n    var next = this.input.charCodeAt(this.pos)\n    if (next === 46) { // '.'\n      ++this.pos\n      this.readInt(10)\n      isFloat = true\n      next = this.input.charCodeAt(this.pos)\n    }\n    if (next === 69 || next === 101) { // 'eE'\n      next = this.input.charCodeAt(++this.pos)\n      if (next === 43 || next === 45) ++this.pos // '+-'\n      if (this.readInt(10) === null) this.raise(start, \"Invalid number\")\n      isFloat = true\n    }\n    if (isIdentifierStart(this.fullCharCodeAtPos())) this.raise(this.pos, \"Identifier directly after number\")\n\n    var str = this.input.slice(start, this.pos), val\n    if (isFloat) val = parseFloat(str)\n    else if (!octal || str.length === 1) val = parseInt(str, 10)\n    else if (/[89]/.test(str) || this.strict) this.raise(start, \"Invalid number\")\n    else val = parseInt(str, 8)\n    return this.finishToken(tt.num, val)\n  }\n\n  // Read a string value, interpreting backslash-escapes.\n\n  pp$7.readCodePoint = function() {\n    var ch = this.input.charCodeAt(this.pos), code\n\n    if (ch === 123) {\n      if (this.options.ecmaVersion < 6) this.unexpected()\n      var codePos = ++this.pos\n      code = this.readHexChar(this.input.indexOf('}', this.pos) - this.pos)\n      ++this.pos\n      if (code > 0x10FFFF) this.raise(codePos, \"Code point out of bounds\")\n    } else {\n      code = this.readHexChar(4)\n    }\n    return code\n  }\n\n  function codePointToString(code) {\n    // UTF-16 Decoding\n    if (code <= 0xFFFF) return String.fromCharCode(code)\n    code -= 0x10000\n    return String.fromCharCode((code >> 10) + 0xD800, (code & 1023) + 0xDC00)\n  }\n\n  pp$7.readString = function(quote) {\n    var this$1 = this;\n\n    var out = \"\", chunkStart = ++this.pos\n    for (;;) {\n      if (this$1.pos >= this$1.input.length) this$1.raise(this$1.start, \"Unterminated string constant\")\n      var ch = this$1.input.charCodeAt(this$1.pos)\n      if (ch === quote) break\n      if (ch === 92) { // '\\'\n        out += this$1.input.slice(chunkStart, this$1.pos)\n        out += this$1.readEscapedChar(false)\n        chunkStart = this$1.pos\n      } else {\n        if (isNewLine(ch)) this$1.raise(this$1.start, \"Unterminated string constant\")\n        ++this$1.pos\n      }\n    }\n    out += this.input.slice(chunkStart, this.pos++)\n    return this.finishToken(tt.string, out)\n  }\n\n  // Reads template string tokens.\n\n  pp$7.readTmplToken = function() {\n    var this$1 = this;\n\n    var out = \"\", chunkStart = this.pos\n    for (;;) {\n      if (this$1.pos >= this$1.input.length) this$1.raise(this$1.start, \"Unterminated template\")\n      var ch = this$1.input.charCodeAt(this$1.pos)\n      if (ch === 96 || ch === 36 && this$1.input.charCodeAt(this$1.pos + 1) === 123) { // '`', '${'\n        if (this$1.pos === this$1.start && this$1.type === tt.template) {\n          if (ch === 36) {\n            this$1.pos += 2\n            return this$1.finishToken(tt.dollarBraceL)\n          } else {\n            ++this$1.pos\n            return this$1.finishToken(tt.backQuote)\n          }\n        }\n        out += this$1.input.slice(chunkStart, this$1.pos)\n        return this$1.finishToken(tt.template, out)\n      }\n      if (ch === 92) { // '\\'\n        out += this$1.input.slice(chunkStart, this$1.pos)\n        out += this$1.readEscapedChar(true)\n        chunkStart = this$1.pos\n      } else if (isNewLine(ch)) {\n        out += this$1.input.slice(chunkStart, this$1.pos)\n        ++this$1.pos\n        switch (ch) {\n          case 13:\n            if (this$1.input.charCodeAt(this$1.pos) === 10) ++this$1.pos\n          case 10:\n            out += \"\\n\"\n            break\n          default:\n            out += String.fromCharCode(ch)\n            break\n        }\n        if (this$1.options.locations) {\n          ++this$1.curLine\n          this$1.lineStart = this$1.pos\n        }\n        chunkStart = this$1.pos\n      } else {\n        ++this$1.pos\n      }\n    }\n  }\n\n  // Used to read escaped characters\n\n  pp$7.readEscapedChar = function(inTemplate) {\n    var ch = this.input.charCodeAt(++this.pos)\n    ++this.pos\n    switch (ch) {\n    case 110: return \"\\n\" // 'n' -> '\\n'\n    case 114: return \"\\r\" // 'r' -> '\\r'\n    case 120: return String.fromCharCode(this.readHexChar(2)) // 'x'\n    case 117: return codePointToString(this.readCodePoint()) // 'u'\n    case 116: return \"\\t\" // 't' -> '\\t'\n    case 98: return \"\\b\" // 'b' -> '\\b'\n    case 118: return \"\\u000b\" // 'v' -> '\\u000b'\n    case 102: return \"\\f\" // 'f' -> '\\f'\n    case 13: if (this.input.charCodeAt(this.pos) === 10) ++this.pos // '\\r\\n'\n    case 10: // ' \\n'\n      if (this.options.locations) { this.lineStart = this.pos; ++this.curLine }\n      return \"\"\n    default:\n      if (ch >= 48 && ch <= 55) {\n        var octalStr = this.input.substr(this.pos - 1, 3).match(/^[0-7]+/)[0]\n        var octal = parseInt(octalStr, 8)\n        if (octal > 255) {\n          octalStr = octalStr.slice(0, -1)\n          octal = parseInt(octalStr, 8)\n        }\n        if (octalStr !== \"0\" && (this.strict || inTemplate)) {\n          this.raise(this.pos - 2, \"Octal literal in strict mode\")\n        }\n        this.pos += octalStr.length - 1\n        return String.fromCharCode(octal)\n      }\n      return String.fromCharCode(ch)\n    }\n  }\n\n  // Used to read character escape sequences ('\\x', '\\u', '\\U').\n\n  pp$7.readHexChar = function(len) {\n    var codePos = this.pos\n    var n = this.readInt(16, len)\n    if (n === null) this.raise(codePos, \"Bad character escape sequence\")\n    return n\n  }\n\n  // Read an identifier, and return it as a string. Sets `this.containsEsc`\n  // to whether the word contained a '\\u' escape.\n  //\n  // Incrementally adds only escaped chars, adding other chunks as-is\n  // as a micro-optimization.\n\n  pp$7.readWord1 = function() {\n    var this$1 = this;\n\n    this.containsEsc = false\n    var word = \"\", first = true, chunkStart = this.pos\n    var astral = this.options.ecmaVersion >= 6\n    while (this.pos < this.input.length) {\n      var ch = this$1.fullCharCodeAtPos()\n      if (isIdentifierChar(ch, astral)) {\n        this$1.pos += ch <= 0xffff ? 1 : 2\n      } else if (ch === 92) { // \"\\\"\n        this$1.containsEsc = true\n        word += this$1.input.slice(chunkStart, this$1.pos)\n        var escStart = this$1.pos\n        if (this$1.input.charCodeAt(++this$1.pos) != 117) // \"u\"\n          this$1.raise(this$1.pos, \"Expecting Unicode escape sequence \\\\uXXXX\")\n        ++this$1.pos\n        var esc = this$1.readCodePoint()\n        if (!(first ? isIdentifierStart : isIdentifierChar)(esc, astral))\n          this$1.raise(escStart, \"Invalid Unicode escape\")\n        word += codePointToString(esc)\n        chunkStart = this$1.pos\n      } else {\n        break\n      }\n      first = false\n    }\n    return word + this.input.slice(chunkStart, this.pos)\n  }\n\n  // Read an identifier or keyword token. Will check for reserved\n  // words when necessary.\n\n  pp$7.readWord = function() {\n    var word = this.readWord1()\n    var type = tt.name\n    if ((this.options.ecmaVersion >= 6 || !this.containsEsc) && this.keywords.test(word))\n      type = keywordTypes[word]\n    return this.finishToken(type, word)\n  }\n\n  var version = \"3.3.0\"\n\n  // The main exported interface (under `self.acorn` when in the\n  // browser) is a `parse` function that takes a code string and\n  // returns an abstract syntax tree as specified by [Mozilla parser\n  // API][api].\n  //\n  // [api]: https://developer.mozilla.org/en-US/docs/SpiderMonkey/Parser_API\n\n  function parse(input, options) {\n    return new Parser(options, input).parse()\n  }\n\n  // This function tries to parse a single expression at a given\n  // offset in a string. Useful for parsing mixed-language formats\n  // that embed JavaScript expressions.\n\n  function parseExpressionAt(input, pos, options) {\n    var p = new Parser(options, input, pos)\n    p.nextToken()\n    return p.parseExpression()\n  }\n\n  // Acorn is organized as a tokenizer and a recursive-descent parser.\n  // The `tokenizer` export provides an interface to the tokenizer.\n\n  function tokenizer(input, options) {\n    return new Parser(options, input)\n  }\n\n  exports.version = version;\n  exports.parse = parse;\n  exports.parseExpressionAt = parseExpressionAt;\n  exports.tokenizer = tokenizer;\n  exports.Parser = Parser;\n  exports.plugins = plugins;\n  exports.defaultOptions = defaultOptions;\n  exports.Position = Position;\n  exports.SourceLocation = SourceLocation;\n  exports.getLineInfo = getLineInfo;\n  exports.Node = Node;\n  exports.TokenType = TokenType;\n  exports.tokTypes = tt;\n  exports.TokContext = TokContext;\n  exports.tokContexts = types;\n  exports.isIdentifierChar = isIdentifierChar;\n  exports.isIdentifierStart = isIdentifierStart;\n  exports.Token = Token;\n  exports.isNewLine = isNewLine;\n  exports.lineBreak = lineBreak;\n  exports.lineBreakG = lineBreakG;\n\n  Object.defineProperty(exports, '__esModule', { value: true });\n\n}));","/home/travis/build/npmtest/node-npmtest-auto-install/auto-install/node_modules/acorn/dist/walk.js":"(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n  typeof define === 'function' && define.amd ? define(['exports'], factory) :\n  (factory((global.acorn = global.acorn || {}, global.acorn.walk = global.acorn.walk || {})));\n}(this, function (exports) { 'use strict';\n\n  // AST walker module for Mozilla Parser API compatible trees\n\n  // A simple walk is one where you simply specify callbacks to be\n  // called on specific nodes. The last two arguments are optional. A\n  // simple use would be\n  //\n  //     walk.simple(myTree, {\n  //         Expression: function(node) { ... }\n  //     });\n  //\n  // to do something with all expressions. All Parser API node types\n  // can be used to identify node types, as well as Expression,\n  // Statement, and ScopeBody, which denote categories of nodes.\n  //\n  // The base argument can be used to pass a custom (recursive)\n  // walker, and state can be used to give this walked an initial\n  // state.\n\n  function simple(node, visitors, base, state, override) {\n    if (!base) base = exports.base\n    ;(function c(node, st, override) {\n      var type = override || node.type, found = visitors[type]\n      base[type](node, st, c)\n      if (found) found(node, st)\n    })(node, state, override)\n  }\n\n  // An ancestor walk keeps an array of ancestor nodes (including the\n  // current node) and passes them to the callback as third parameter\n  // (and also as state parameter when no other state is present).\n  function ancestor(node, visitors, base, state) {\n    if (!base) base = exports.base\n    var ancestors = []\n    ;(function c(node, st, override) {\n      var type = override || node.type, found = visitors[type]\n      var isNew = node != ancestors[ancestors.length - 1]\n      if (isNew) ancestors.push(node)\n      base[type](node, st, c)\n      if (found) found(node, st || ancestors, ancestors)\n      if (isNew) ancestors.pop()\n    })(node, state)\n  }\n\n  // A recursive walk is one where your functions override the default\n  // walkers. They can modify and replace the state parameter that's\n  // threaded through the walk, and can opt how and whether to walk\n  // their child nodes (by calling their third argument on these\n  // nodes).\n  function recursive(node, state, funcs, base, override) {\n    var visitor = funcs ? exports.make(funcs, base) : base\n    ;(function c(node, st, override) {\n      visitor[override || node.type](node, st, c)\n    })(node, state, override)\n  }\n\n  function makeTest(test) {\n    if (typeof test == \"string\")\n      return function (type) { return type == test; }\n    else if (!test)\n      return function () { return true; }\n    else\n      return test\n  }\n\n  var Found = function Found(node, state) { this.node = node; this.state = state };\n\n  // Find a node with a given start, end, and type (all are optional,\n  // null can be used as wildcard). Returns a {node, state} object, or\n  // undefined when it doesn't find a matching node.\n  function findNodeAt(node, start, end, test, base, state) {\n    test = makeTest(test)\n    if (!base) base = exports.base\n    try {\n      ;(function c(node, st, override) {\n        var type = override || node.type\n        if ((start == null || node.start <= start) &&\n            (end == null || node.end >= end))\n          base[type](node, st, c)\n        if ((start == null || node.start == start) &&\n            (end == null || node.end == end) &&\n            test(type, node))\n          throw new Found(node, st)\n      })(node, state)\n    } catch (e) {\n      if (e instanceof Found) return e\n      throw e\n    }\n  }\n\n  // Find the innermost node of a given type that contains the given\n  // position. Interface similar to findNodeAt.\n  function findNodeAround(node, pos, test, base, state) {\n    test = makeTest(test)\n    if (!base) base = exports.base\n    try {\n      ;(function c(node, st, override) {\n        var type = override || node.type\n        if (node.start > pos || node.end < pos) return\n        base[type](node, st, c)\n        if (test(type, node)) throw new Found(node, st)\n      })(node, state)\n    } catch (e) {\n      if (e instanceof Found) return e\n      throw e\n    }\n  }\n\n  // Find the outermost matching node after a given position.\n  function findNodeAfter(node, pos, test, base, state) {\n    test = makeTest(test)\n    if (!base) base = exports.base\n    try {\n      ;(function c(node, st, override) {\n        if (node.end < pos) return\n        var type = override || node.type\n        if (node.start >= pos && test(type, node)) throw new Found(node, st)\n        base[type](node, st, c)\n      })(node, state)\n    } catch (e) {\n      if (e instanceof Found) return e\n      throw e\n    }\n  }\n\n  // Find the outermost matching node before a given position.\n  function findNodeBefore(node, pos, test, base, state) {\n    test = makeTest(test)\n    if (!base) base = exports.base\n    var max\n    ;(function c(node, st, override) {\n      if (node.start > pos) return\n      var type = override || node.type\n      if (node.end <= pos && (!max || max.node.end < node.end) && test(type, node))\n        max = new Found(node, st)\n      base[type](node, st, c)\n    })(node, state)\n    return max\n  }\n\n  // Fallback to an Object.create polyfill for older environments.\n  var create = Object.create || function(proto) {\n    function Ctor() {}\n    Ctor.prototype = proto\n    return new Ctor\n  }\n\n  // Used to create a custom walker. Will fill in all missing node\n  // type properties with the defaults.\n  function make(funcs, base) {\n    if (!base) base = exports.base\n    var visitor = create(base)\n    for (var type in funcs) visitor[type] = funcs[type]\n    return visitor\n  }\n\n  function skipThrough(node, st, c) { c(node, st) }\n  function ignore(_node, _st, _c) {}\n\n  // Node walkers.\n\n  var base = {}\n\n  base.Program = base.BlockStatement = function (node, st, c) {\n    for (var i = 0; i < node.body.length; ++i)\n      c(node.body[i], st, \"Statement\")\n  }\n  base.Statement = skipThrough\n  base.EmptyStatement = ignore\n  base.ExpressionStatement = base.ParenthesizedExpression =\n    function (node, st, c) { return c(node.expression, st, \"Expression\"); }\n  base.IfStatement = function (node, st, c) {\n    c(node.test, st, \"Expression\")\n    c(node.consequent, st, \"Statement\")\n    if (node.alternate) c(node.alternate, st, \"Statement\")\n  }\n  base.LabeledStatement = function (node, st, c) { return c(node.body, st, \"Statement\"); }\n  base.BreakStatement = base.ContinueStatement = ignore\n  base.WithStatement = function (node, st, c) {\n    c(node.object, st, \"Expression\")\n    c(node.body, st, \"Statement\")\n  }\n  base.SwitchStatement = function (node, st, c) {\n    c(node.discriminant, st, \"Expression\")\n    for (var i = 0; i < node.cases.length; ++i) {\n      var cs = node.cases[i]\n      if (cs.test) c(cs.test, st, \"Expression\")\n      for (var j = 0; j < cs.consequent.length; ++j)\n        c(cs.consequent[j], st, \"Statement\")\n    }\n  }\n  base.ReturnStatement = base.YieldExpression = function (node, st, c) {\n    if (node.argument) c(node.argument, st, \"Expression\")\n  }\n  base.ThrowStatement = base.SpreadElement =\n    function (node, st, c) { return c(node.argument, st, \"Expression\"); }\n  base.TryStatement = function (node, st, c) {\n    c(node.block, st, \"Statement\")\n    if (node.handler) c(node.handler, st)\n    if (node.finalizer) c(node.finalizer, st, \"Statement\")\n  }\n  base.CatchClause = function (node, st, c) {\n    c(node.param, st, \"Pattern\")\n    c(node.body, st, \"ScopeBody\")\n  }\n  base.WhileStatement = base.DoWhileStatement = function (node, st, c) {\n    c(node.test, st, \"Expression\")\n    c(node.body, st, \"Statement\")\n  }\n  base.ForStatement = function (node, st, c) {\n    if (node.init) c(node.init, st, \"ForInit\")\n    if (node.test) c(node.test, st, \"Expression\")\n    if (node.update) c(node.update, st, \"Expression\")\n    c(node.body, st, \"Statement\")\n  }\n  base.ForInStatement = base.ForOfStatement = function (node, st, c) {\n    c(node.left, st, \"ForInit\")\n    c(node.right, st, \"Expression\")\n    c(node.body, st, \"Statement\")\n  }\n  base.ForInit = function (node, st, c) {\n    if (node.type == \"VariableDeclaration\") c(node, st)\n    else c(node, st, \"Expression\")\n  }\n  base.DebuggerStatement = ignore\n\n  base.FunctionDeclaration = function (node, st, c) { return c(node, st, \"Function\"); }\n  base.VariableDeclaration = function (node, st, c) {\n    for (var i = 0; i < node.declarations.length; ++i)\n      c(node.declarations[i], st)\n  }\n  base.VariableDeclarator = function (node, st, c) {\n    c(node.id, st, \"Pattern\")\n    if (node.init) c(node.init, st, \"Expression\")\n  }\n\n  base.Function = function (node, st, c) {\n    if (node.id) c(node.id, st, \"Pattern\")\n    for (var i = 0; i < node.params.length; i++)\n      c(node.params[i], st, \"Pattern\")\n    c(node.body, st, node.expression ? \"ScopeExpression\" : \"ScopeBody\")\n  }\n  // FIXME drop these node types in next major version\n  // (They are awkward, and in ES6 every block can be a scope.)\n  base.ScopeBody = function (node, st, c) { return c(node, st, \"Statement\"); }\n  base.ScopeExpression = function (node, st, c) { return c(node, st, \"Expression\"); }\n\n  base.Pattern = function (node, st, c) {\n    if (node.type == \"Identifier\")\n      c(node, st, \"VariablePattern\")\n    else if (node.type == \"MemberExpression\")\n      c(node, st, \"MemberPattern\")\n    else\n      c(node, st)\n  }\n  base.VariablePattern = ignore\n  base.MemberPattern = skipThrough\n  base.RestElement = function (node, st, c) { return c(node.argument, st, \"Pattern\"); }\n  base.ArrayPattern =  function (node, st, c) {\n    for (var i = 0; i < node.elements.length; ++i) {\n      var elt = node.elements[i]\n      if (elt) c(elt, st, \"Pattern\")\n    }\n  }\n  base.ObjectPattern = function (node, st, c) {\n    for (var i = 0; i < node.properties.length; ++i)\n      c(node.properties[i].value, st, \"Pattern\")\n  }\n\n  base.Expression = skipThrough\n  base.ThisExpression = base.Super = base.MetaProperty = ignore\n  base.ArrayExpression = function (node, st, c) {\n    for (var i = 0; i < node.elements.length; ++i) {\n      var elt = node.elements[i]\n      if (elt) c(elt, st, \"Expression\")\n    }\n  }\n  base.ObjectExpression = function (node, st, c) {\n    for (var i = 0; i < node.properties.length; ++i)\n      c(node.properties[i], st)\n  }\n  base.FunctionExpression = base.ArrowFunctionExpression = base.FunctionDeclaration\n  base.SequenceExpression = base.TemplateLiteral = function (node, st, c) {\n    for (var i = 0; i < node.expressions.length; ++i)\n      c(node.expressions[i], st, \"Expression\")\n  }\n  base.UnaryExpression = base.UpdateExpression = function (node, st, c) {\n    c(node.argument, st, \"Expression\")\n  }\n  base.BinaryExpression = base.LogicalExpression = function (node, st, c) {\n    c(node.left, st, \"Expression\")\n    c(node.right, st, \"Expression\")\n  }\n  base.AssignmentExpression = base.AssignmentPattern = function (node, st, c) {\n    c(node.left, st, \"Pattern\")\n    c(node.right, st, \"Expression\")\n  }\n  base.ConditionalExpression = function (node, st, c) {\n    c(node.test, st, \"Expression\")\n    c(node.consequent, st, \"Expression\")\n    c(node.alternate, st, \"Expression\")\n  }\n  base.NewExpression = base.CallExpression = function (node, st, c) {\n    c(node.callee, st, \"Expression\")\n    if (node.arguments) for (var i = 0; i < node.arguments.length; ++i)\n      c(node.arguments[i], st, \"Expression\")\n  }\n  base.MemberExpression = function (node, st, c) {\n    c(node.object, st, \"Expression\")\n    if (node.computed) c(node.property, st, \"Expression\")\n  }\n  base.ExportNamedDeclaration = base.ExportDefaultDeclaration = function (node, st, c) {\n    if (node.declaration)\n      c(node.declaration, st, node.type == \"ExportNamedDeclaration\" || node.declaration.id ? \"Statement\" : \"Expression\")\n    if (node.source) c(node.source, st, \"Expression\")\n  }\n  base.ExportAllDeclaration = function (node, st, c) {\n    c(node.source, st, \"Expression\")\n  }\n  base.ImportDeclaration = function (node, st, c) {\n    for (var i = 0; i < node.specifiers.length; i++)\n      c(node.specifiers[i], st)\n    c(node.source, st, \"Expression\")\n  }\n  base.ImportSpecifier = base.ImportDefaultSpecifier = base.ImportNamespaceSpecifier = base.Identifier = base.Literal = ignore\n\n  base.TaggedTemplateExpression = function (node, st, c) {\n    c(node.tag, st, \"Expression\")\n    c(node.quasi, st)\n  }\n  base.ClassDeclaration = base.ClassExpression = function (node, st, c) { return c(node, st, \"Class\"); }\n  base.Class = function (node, st, c) {\n    if (node.id) c(node.id, st, \"Pattern\")\n    if (node.superClass) c(node.superClass, st, \"Expression\")\n    for (var i = 0; i < node.body.body.length; i++)\n      c(node.body.body[i], st)\n  }\n  base.MethodDefinition = base.Property = function (node, st, c) {\n    if (node.computed) c(node.key, st, \"Expression\")\n    c(node.value, st, \"Expression\")\n  }\n\n  exports.simple = simple;\n  exports.ancestor = ancestor;\n  exports.recursive = recursive;\n  exports.findNodeAt = findNodeAt;\n  exports.findNodeAround = findNodeAround;\n  exports.findNodeAfter = findNodeAfter;\n  exports.findNodeBefore = findNodeBefore;\n  exports.make = make;\n  exports.base = base;\n\n  Object.defineProperty(exports, '__esModule', { value: true });\n\n}));","/home/travis/build/npmtest/node-npmtest-auto-install/auto-install/node_modules/detective-es6/index.js":"var Walker = require('node-source-walk');\n\n/**\n * Extracts the dependencies of the supplied es6 module\n *\n * @param  {String|Object} src - File's content or AST\n * @return {String[]}\n */\nmodule.exports = function(src) {\n  var walker = new Walker();\n\n  var dependencies = [];\n\n  if (!src) { throw new Error('src not given'); }\n\n  walker.walk(src, function(node) {\n    switch (node.type) {\n      case 'ImportDeclaration':\n        if (node.source && node.source.value) {\n          dependencies.push(node.source.value);\n        }\n        break;\n      case 'ExportNamedDeclaration':\n      case 'ExportAllDeclaration':\n        if (node.source && node.source.value) {\n          dependencies.push(node.source.value);\n        }\n        break;\n      default:\n        return;\n    }\n  });\n\n  return dependencies;\n};\n","/home/travis/build/npmtest/node-npmtest-auto-install/auto-install/node_modules/yargs/index.js":"// classic singleton yargs API, to use yargs\n// without running as a singleton do:\n// require('yargs/yargs')(process.argv.slice(2))\nconst yargs = require('./yargs')\n\nArgv(process.argv.slice(2))\n\nmodule.exports = Argv\n\nfunction Argv (processArgs, cwd) {\n  const argv = yargs(processArgs, cwd, require)\n  singletonify(argv)\n  return argv\n}\n\n/*  Hack an instance of Argv with process.argv into Argv\n    so people can do\n    require('yargs')(['--beeble=1','-z','zizzle']).argv\n    to parse a list of args and\n    require('yargs').argv\n    to get a parsed version of process.argv.\n*/\nfunction singletonify (inst) {\n  Object.keys(inst).forEach(function (key) {\n    if (key === 'argv') {\n      Argv.__defineGetter__(key, inst.__lookupGetter__(key))\n    } else {\n      Argv[key] = typeof inst[key] === 'function' ? inst[key].bind(inst) : inst[key]\n    }\n  })\n}\n","/home/travis/build/npmtest/node-npmtest-auto-install/auto-install/node_modules/yargs/yargs.js":"const assign = require('./lib/assign')\nconst Command = require('./lib/command')\nconst Completion = require('./lib/completion')\nconst Parser = require('yargs-parser')\nconst path = require('path')\nconst Usage = require('./lib/usage')\nconst Validation = require('./lib/validation')\nconst Y18n = require('y18n')\nconst objFilter = require('./lib/obj-filter')\nconst setBlocking = require('set-blocking')\n\nvar exports = module.exports = Yargs\nfunction Yargs (processArgs, cwd, parentRequire) {\n  processArgs = processArgs || [] // handle calling yargs().\n\n  const self = {}\n  var command = null\n  var completion = null\n  var groups = {}\n  var output = ''\n  var preservedGroups = {}\n  var usage = null\n  var validation = null\n\n  const y18n = Y18n({\n    directory: path.resolve(__dirname, './locales'),\n    updateFiles: false\n  })\n\n  if (!cwd) cwd = process.cwd()\n\n  self.$0 = process.argv\n    .slice(0, 2)\n    .map(function (x, i) {\n      // ignore the node bin, specify this in your\n      // bin file with #!/usr/bin/env node\n      if (i === 0 && /\\b(node|iojs)(\\.exe)?$/.test(x)) return\n      var b = rebase(cwd, x)\n      return x.match(/^(\\/|([a-zA-Z]:)?\\\\)/) && b.length < x.length ? b : x\n    })\n    .join(' ').trim()\n\n  if (process.env._ !== undefined && process.argv[1] === process.env._) {\n    self.$0 = process.env._.replace(\n      path.dirname(process.execPath) + '/', ''\n    )\n  }\n\n  // use context object to keep track of resets, subcommand execution, etc\n  // submodules should modify and check the state of context as necessary\n  const context = { resets: -1, commands: [], files: [] }\n  self.getContext = function () {\n    return context\n  }\n\n  // puts yargs back into an initial state. any keys\n  // that have been set to \"global\" will not be reset\n  // by this action.\n  var options\n  self.resetOptions = self.reset = function (aliases) {\n    context.resets++\n    aliases = aliases || {}\n    options = options || {}\n    // put yargs back into an initial state, this\n    // logic is used to build a nested command\n    // hierarchy.\n    var tmpOptions = {}\n    tmpOptions.global = options.global ? options.global : []\n    tmpOptions.configObjects = options.configObjects ? options.configObjects : []\n\n    // if a key has been set as a global, we\n    // do not want to reset it or its aliases.\n    var globalLookup = {}\n    tmpOptions.global.forEach(function (g) {\n      globalLookup[g] = true\n      ;(aliases[g] || []).forEach(function (a) {\n        globalLookup[a] = true\n      })\n    })\n\n    // preserve groups containing global keys\n    preservedGroups = Object.keys(groups).reduce(function (acc, groupName) {\n      var keys = groups[groupName].filter(function (key) {\n        return key in globalLookup\n      })\n      if (keys.length > 0) {\n        acc[groupName] = keys\n      }\n      return acc\n    }, {})\n    // groups can now be reset\n    groups = {}\n\n    var arrayOptions = [\n      'array', 'boolean', 'string', 'requiresArg', 'skipValidation',\n      'count', 'normalize', 'number'\n    ]\n\n    var objectOptions = [\n      'narg', 'key', 'alias', 'default', 'defaultDescription',\n      'config', 'choices', 'demanded', 'coerce'\n    ]\n\n    arrayOptions.forEach(function (k) {\n      tmpOptions[k] = (options[k] || []).filter(function (k) {\n        return globalLookup[k]\n      })\n    })\n\n    objectOptions.forEach(function (k) {\n      tmpOptions[k] = objFilter(options[k], function (k, v) {\n        return globalLookup[k]\n      })\n    })\n\n    tmpOptions.envPrefix = options.envPrefix\n    options = tmpOptions\n\n    // if this is the first time being executed, create\n    // instances of all our helpers -- otherwise just reset.\n    usage = usage ? usage.reset(globalLookup) : Usage(self, y18n)\n    validation = validation ? validation.reset(globalLookup) : Validation(self, usage, y18n)\n    command = command ? command.reset() : Command(self, usage, validation)\n    if (!completion) completion = Completion(self, usage, command)\n\n    strict = false\n    completionCommand = null\n    output = ''\n    exitError = null\n    hasOutput = false\n    self.parsed = false\n\n    return self\n  }\n  self.resetOptions()\n\n  // temporary hack: allow \"freezing\" of reset-able state for parse(msg, cb)\n  var frozen\n  function freeze () {\n    frozen = {}\n    frozen.options = options\n    frozen.configObjects = options.configObjects.slice(0)\n    frozen.exitProcess = exitProcess\n    frozen.groups = groups\n    usage.freeze()\n    validation.freeze()\n    command.freeze()\n    frozen.strict = strict\n    frozen.completionCommand = completionCommand\n    frozen.output = output\n    frozen.exitError = exitError\n    frozen.hasOutput = hasOutput\n    frozen.parsed = self.parsed\n  }\n  function unfreeze () {\n    options = frozen.options\n    options.configObjects = frozen.configObjects\n    exitProcess = frozen.exitProcess\n    groups = frozen.groups\n    output = frozen.output\n    exitError = frozen.exitError\n    hasOutput = frozen.hasOutput\n    self.parsed = frozen.parsed\n    usage.unfreeze()\n    validation.unfreeze()\n    command.unfreeze()\n    strict = frozen.strict\n    completionCommand = frozen.completionCommand\n    parseFn = null\n    parseContext = null\n    frozen = undefined\n  }\n\n  self.boolean = function (bools) {\n    options.boolean.push.apply(options.boolean, [].concat(bools))\n    return self\n  }\n\n  self.array = function (arrays) {\n    options.array.push.apply(options.array, [].concat(arrays))\n    return self\n  }\n\n  self.nargs = function (key, n) {\n    if (typeof key === 'object') {\n      Object.keys(key).forEach(function (k) {\n        self.nargs(k, key[k])\n      })\n    } else {\n      options.narg[key] = n\n    }\n    return self\n  }\n\n  self.number = function (numbers) {\n    options.number.push.apply(options.number, [].concat(numbers))\n    return self\n  }\n\n  self.choices = function (key, values) {\n    if (typeof key === 'object') {\n      Object.keys(key).forEach(function (k) {\n        self.choices(k, key[k])\n      })\n    } else {\n      options.choices[key] = (options.choices[key] || []).concat(values)\n    }\n    return self\n  }\n\n  self.normalize = function (strings) {\n    options.normalize.push.apply(options.normalize, [].concat(strings))\n    return self\n  }\n\n  self.config = function (key, msg, parseFn) {\n    // allow to pass a configuration object\n    if (typeof key === 'object') {\n      options.configObjects = (options.configObjects || []).concat(key)\n      return self\n    }\n\n    // allow to provide a parsing function\n    if (typeof msg === 'function') {\n      parseFn = msg\n      msg = null\n    }\n\n    key = key || 'config'\n    self.describe(key, msg || usage.deferY18nLookup('Path to JSON config file'))\n    ;(Array.isArray(key) ? key : [key]).forEach(function (k) {\n      options.config[k] = parseFn || true\n    })\n    return self\n  }\n\n  self.example = function (cmd, description) {\n    usage.example(cmd, description)\n    return self\n  }\n\n  self.command = function (cmd, description, builder, handler) {\n    command.addHandler(cmd, description, builder, handler)\n    return self\n  }\n\n  self.commandDir = function (dir, opts) {\n    const req = parentRequire || require\n    command.addDirectory(dir, self.getContext(), req, require('get-caller-file')(), opts)\n    return self\n  }\n\n  self.string = function (strings) {\n    options.string.push.apply(options.string, [].concat(strings))\n    return self\n  }\n\n  // The 'defaults' alias is deprecated. It will be removed in the next major version.\n  self.default = self.defaults = function (key, value, defaultDescription) {\n    if (typeof key === 'object') {\n      Object.keys(key).forEach(function (k) {\n        self.default(k, key[k])\n      })\n    } else {\n      if (defaultDescription) options.defaultDescription[key] = defaultDescription\n      if (typeof value === 'function') {\n        if (!options.defaultDescription[key]) options.defaultDescription[key] = usage.functionDescription(value)\n        value = value.call()\n      }\n      options.default[key] = value\n    }\n    return self\n  }\n\n  self.alias = function (x, y) {\n    if (typeof x === 'object') {\n      Object.keys(x).forEach(function (key) {\n        self.alias(key, x[key])\n      })\n    } else {\n      options.alias[x] = (options.alias[x] || []).concat(y)\n    }\n    return self\n  }\n\n  self.coerce = function (key, fn) {\n    if (typeof key === 'object' && !Array.isArray(key)) {\n      Object.keys(key).forEach(function (k) {\n        self.coerce(k, key[k])\n      })\n    } else {\n      [].concat(key).forEach(function (k) {\n        options.coerce[k] = fn\n      })\n    }\n    return self\n  }\n\n  self.count = function (counts) {\n    options.count.push.apply(options.count, [].concat(counts))\n    return self\n  }\n\n  self.demand = self.required = self.require = function (keys, max, msg) {\n    // you can optionally provide a 'max' key,\n    // which will raise an exception if too many '_'\n    // options are provided.\n\n    if (Array.isArray(max)) {\n      max.forEach(function (key) {\n        self.demand(key, msg)\n      })\n      max = Infinity\n    } else if (typeof max !== 'number') {\n      msg = max\n      max = Infinity\n    }\n\n    if (typeof keys === 'number') {\n      if (!options.demanded._) options.demanded._ = { count: 0, msg: null, max: max }\n      options.demanded._.count = keys\n      options.demanded._.msg = msg\n    } else if (Array.isArray(keys)) {\n      keys.forEach(function (key) {\n        self.demand(key, msg)\n      })\n    } else {\n      if (typeof msg === 'string') {\n        options.demanded[keys] = { msg: msg }\n      } else if (msg === true || typeof msg === 'undefined') {\n        options.demanded[keys] = { msg: undefined }\n      }\n    }\n\n    return self\n  }\n\n  self.getDemanded = function () {\n    return options.demanded\n  }\n\n  self.requiresArg = function (requiresArgs) {\n    options.requiresArg.push.apply(options.requiresArg, [].concat(requiresArgs))\n    return self\n  }\n\n  self.skipValidation = function (skipValidations) {\n    options.skipValidation.push.apply(options.skipValidation, [].concat(skipValidations))\n    return self\n  }\n\n  self.implies = function (key, value) {\n    validation.implies(key, value)\n    return self\n  }\n\n  self.usage = function (msg, opts) {\n    if (!opts && typeof msg === 'object') {\n      opts = msg\n      msg = null\n    }\n\n    usage.usage(msg)\n\n    if (opts) self.options(opts)\n\n    return self\n  }\n\n  self.epilogue = self.epilog = function (msg) {\n    usage.epilog(msg)\n    return self\n  }\n\n  self.fail = function (f) {\n    usage.failFn(f)\n    return self\n  }\n\n  self.check = function (f) {\n    validation.check(f)\n    return self\n  }\n\n  self.describe = function (key, desc) {\n    options.key[key] = true\n    usage.describe(key, desc)\n    return self\n  }\n\n  self.global = function (globals) {\n    options.global.push.apply(options.global, [].concat(globals))\n    return self\n  }\n\n  self.pkgConf = function (key, path) {\n    var conf = null\n\n    var obj = pkgUp(path)\n\n    // If an object exists in the key, add it to options.configObjects\n    if (obj[key] && typeof obj[key] === 'object') {\n      conf = obj[key]\n      options.configObjects = (options.configObjects || []).concat(conf)\n    }\n\n    return self\n  }\n\n  var pkgs = {}\n  function pkgUp (path) {\n    var npath = path || '*'\n    if (pkgs[npath]) return pkgs[npath]\n    const readPkgUp = require('read-pkg-up')\n\n    var obj = {}\n    try {\n      obj = readPkgUp.sync({\n        cwd: path || require('require-main-filename')(parentRequire || require)\n      })\n    } catch (noop) {}\n\n    pkgs[npath] = obj.pkg || {}\n    return pkgs[npath]\n  }\n\n  var parseFn = null\n  var parseContext = null\n  self.parse = function (args, shortCircuit, _parseFn) {\n    // a context object can optionally be provided, this allows\n    // additional information to be passed to a command handler.\n    if (typeof shortCircuit === 'object') {\n      parseContext = shortCircuit\n      shortCircuit = _parseFn\n    }\n\n    // by providing a function as a second argument to\n    // parse you can capture output that would otherwise\n    // default to printing to stdout/stderr.\n    if (typeof shortCircuit === 'function') {\n      parseFn = shortCircuit\n      shortCircuit = null\n    }\n    // completion short-circuits the parsing process,\n    // skipping validation, etc.\n    if (!shortCircuit) processArgs = args\n\n    if (parseFn) {\n      freeze()\n      exitProcess = false\n    }\n\n    var parsed = parseArgs(args, shortCircuit)\n    if (parseFn) {\n      parseFn(exitError, parsed, output)\n      unfreeze()\n    }\n\n    return parsed\n  }\n\n  self._hasParseCallback = function () {\n    return !!parseFn\n  }\n\n  self.option = self.options = function (key, opt) {\n    if (typeof key === 'object') {\n      Object.keys(key).forEach(function (k) {\n        self.options(k, key[k])\n      })\n    } else {\n      if (typeof opt !== 'object') {\n        opt = {}\n      }\n\n      options.key[key] = true // track manually set keys.\n\n      if (opt.alias) self.alias(key, opt.alias)\n\n      var demand = opt.demand || opt.required || opt.require\n\n      if (demand) {\n        self.demand(key, demand)\n      }\n\n      if ('config' in opt) {\n        self.config(key, opt.configParser)\n      }\n\n      if ('default' in opt) {\n        self.default(key, opt.default)\n      }\n\n      if ('nargs' in opt) {\n        self.nargs(key, opt.nargs)\n      }\n\n      if ('normalize' in opt) {\n        self.normalize(key)\n      }\n\n      if ('choices' in opt) {\n        self.choices(key, opt.choices)\n      }\n\n      if ('coerce' in opt) {\n        self.coerce(key, opt.coerce)\n      }\n\n      if ('group' in opt) {\n        self.group(key, opt.group)\n      }\n\n      if (opt.global) {\n        self.global(key)\n      }\n\n      if (opt.boolean || opt.type === 'boolean') {\n        self.boolean(key)\n        if (opt.alias) self.boolean(opt.alias)\n      }\n\n      if (opt.array || opt.type === 'array') {\n        self.array(key)\n        if (opt.alias) self.array(opt.alias)\n      }\n\n      if (opt.number || opt.type === 'number') {\n        self.number(key)\n        if (opt.alias) self.number(opt.alias)\n      }\n\n      if (opt.string || opt.type === 'string') {\n        self.string(key)\n        if (opt.alias) self.string(opt.alias)\n      }\n\n      if (opt.count || opt.type === 'count') {\n        self.count(key)\n      }\n\n      if (opt.defaultDescription) {\n        options.defaultDescription[key] = opt.defaultDescription\n      }\n\n      if (opt.skipValidation) {\n        self.skipValidation(key)\n      }\n\n      var desc = opt.describe || opt.description || opt.desc\n      if (desc) {\n        self.describe(key, desc)\n      }\n\n      if (opt.requiresArg) {\n        self.requiresArg(key)\n      }\n    }\n\n    return self\n  }\n  self.getOptions = function () {\n    return options\n  }\n\n  self.group = function (opts, groupName) {\n    var existing = preservedGroups[groupName] || groups[groupName]\n    if (preservedGroups[groupName]) {\n      // the preserved group will be moved to the set of explicitly declared\n      // groups\n      delete preservedGroups[groupName]\n    }\n\n    var seen = {}\n    groups[groupName] = (existing || []).concat(opts).filter(function (key) {\n      if (seen[key]) return false\n      return (seen[key] = true)\n    })\n    return self\n  }\n  self.getGroups = function () {\n    // combine explicit and preserved groups. explicit groups should be first\n    return assign(groups, preservedGroups)\n  }\n\n  // as long as options.envPrefix is not undefined,\n  // parser will apply env vars matching prefix to argv\n  self.env = function (prefix) {\n    if (prefix === false) options.envPrefix = undefined\n    else options.envPrefix = prefix || ''\n    return self\n  }\n\n  self.wrap = function (cols) {\n    usage.wrap(cols)\n    return self\n  }\n\n  var strict = false\n  self.strict = function () {\n    strict = true\n    return self\n  }\n  self.getStrict = function () {\n    return strict\n  }\n\n  self.showHelp = function (level) {\n    if (!self.parsed) parseArgs(processArgs) // run parser, if it has not already been executed.\n    usage.showHelp(level)\n    return self\n  }\n\n  var versionOpt = null\n  self.version = function (opt, msg, ver) {\n    if (arguments.length === 0) {\n      ver = guessVersion()\n      opt = 'version'\n    } else if (arguments.length === 1) {\n      ver = opt\n      opt = 'version'\n    } else if (arguments.length === 2) {\n      ver = msg\n    }\n\n    versionOpt = opt\n    msg = msg || usage.deferY18nLookup('Show version number')\n\n    usage.version(ver || undefined)\n    self.boolean(versionOpt)\n    self.global(versionOpt)\n    self.describe(versionOpt, msg)\n    return self\n  }\n\n  function guessVersion () {\n    var obj = pkgUp()\n\n    return obj.version || 'unknown'\n  }\n\n  var helpOpt = null\n  var useHelpOptAsCommand = false // a call to .help() will enable this\n  self.addHelpOpt = self.help = function (opt, msg, addImplicitCmd) {\n    // argument shuffle\n    if (arguments.length === 0) {\n      useHelpOptAsCommand = true\n    } else if (arguments.length === 1) {\n      if (typeof opt === 'boolean') {\n        useHelpOptAsCommand = opt\n        opt = null\n      } else {\n        useHelpOptAsCommand = true\n      }\n    } else if (arguments.length === 2) {\n      if (typeof msg === 'boolean') {\n        useHelpOptAsCommand = msg\n        msg = null\n      } else {\n        useHelpOptAsCommand = true\n      }\n    } else {\n      useHelpOptAsCommand = Boolean(addImplicitCmd)\n    }\n    // use arguments, fallback to defaults for opt and msg\n    helpOpt = opt || 'help'\n    self.boolean(helpOpt)\n    self.global(helpOpt)\n    self.describe(helpOpt, msg || usage.deferY18nLookup('Show help'))\n    return self\n  }\n\n  self.showHelpOnFail = function (enabled, message) {\n    usage.showHelpOnFail(enabled, message)\n    return self\n  }\n\n  var exitProcess = true\n  self.exitProcess = function (enabled) {\n    if (typeof enabled !== 'boolean') {\n      enabled = true\n    }\n    exitProcess = enabled\n    return self\n  }\n  self.getExitProcess = function () {\n    return exitProcess\n  }\n\n  var completionCommand = null\n  self.completion = function (cmd, desc, fn) {\n    // a function to execute when generating\n    // completions can be provided as the second\n    // or third argument to completion.\n    if (typeof desc === 'function') {\n      fn = desc\n      desc = null\n    }\n\n    // register the completion command.\n    completionCommand = cmd || 'completion'\n    if (!desc && desc !== false) {\n      desc = 'generate bash completion script'\n    }\n    self.command(completionCommand, desc)\n\n    // a function can be provided\n    if (fn) completion.registerFunction(fn)\n\n    return self\n  }\n\n  self.showCompletionScript = function ($0) {\n    $0 = $0 || self.$0\n    _logger.log(completion.generateCompletionScript($0))\n    return self\n  }\n\n  self.getCompletion = function (args, done) {\n    completion.getCompletion(args, done)\n  }\n\n  self.locale = function (locale) {\n    if (arguments.length === 0) {\n      guessLocale()\n      return y18n.getLocale()\n    }\n    detectLocale = false\n    y18n.setLocale(locale)\n    return self\n  }\n\n  self.updateStrings = self.updateLocale = function (obj) {\n    detectLocale = false\n    y18n.updateLocale(obj)\n    return self\n  }\n\n  var detectLocale = true\n  self.detectLocale = function (detect) {\n    detectLocale = detect\n    return self\n  }\n  self.getDetectLocale = function () {\n    return detectLocale\n  }\n\n  var hasOutput = false\n  var exitError = null\n  // maybe exit, always capture\n  // context about why we wanted to exit.\n  self.exit = function (code, err) {\n    hasOutput = true\n    exitError = err\n    if (exitProcess) process.exit(code)\n  }\n\n  // we use a custom logger that buffers output,\n  // so that we can print to non-CLIs, e.g., chat-bots.\n  var _logger = {\n    log: function () {\n      var args = Array.prototype.slice.call(arguments)\n      if (!self._hasParseCallback()) console.log.apply(console, args)\n      hasOutput = true\n      if (output.length) output += '\\n'\n      output += args.join(' ')\n    },\n    error: function () {\n      var args = Array.prototype.slice.call(arguments)\n      if (!self._hasParseCallback()) console.error.apply(console, args)\n      hasOutput = true\n      if (output.length) output += '\\n'\n      output += args.join(' ')\n    }\n  }\n  self._getLoggerInstance = function () {\n    return _logger\n  }\n  // has yargs output an error our help\n  // message in the current execution context.\n  self._hasOutput = function () {\n    return hasOutput\n  }\n\n  var recommendCommands\n  self.recommendCommands = function () {\n    recommendCommands = true\n    return self\n  }\n\n  self.getUsageInstance = function () {\n    return usage\n  }\n\n  self.getValidationInstance = function () {\n    return validation\n  }\n\n  self.getCommandInstance = function () {\n    return command\n  }\n\n  self.terminalWidth = function () {\n    return require('window-size').width\n  }\n\n  Object.defineProperty(self, 'argv', {\n    get: function () {\n      var args = null\n\n      try {\n        args = parseArgs(processArgs)\n      } catch (err) {\n        usage.fail(err.message, err)\n      }\n\n      return args\n    },\n    enumerable: true\n  })\n\n  function parseArgs (args, shortCircuit) {\n    options.__ = y18n.__\n    options.configuration = pkgUp(cwd)['yargs'] || {}\n    const parsed = Parser.detailed(args, options)\n    var argv = parsed.argv\n    if (parseContext) argv = assign(parseContext, argv)\n    var aliases = parsed.aliases\n\n    argv.$0 = self.$0\n    self.parsed = parsed\n\n    guessLocale() // guess locale lazily, so that it can be turned off in chain.\n\n    // while building up the argv object, there\n    // are two passes through the parser. If completion\n    // is being performed short-circuit on the first pass.\n    if (shortCircuit) {\n      return argv\n    }\n\n    if (argv._.length) {\n      // check for helpOpt in argv._ before running commands\n      // assumes helpOpt must be valid if useHelpOptAsCommand is true\n      if (useHelpOptAsCommand) {\n        // consider any multi-char helpOpt alias as a valid help command\n        // unless all helpOpt aliases are single-char\n        // note that parsed.aliases is a normalized bidirectional map :)\n        var helpCmds = [helpOpt].concat(aliases[helpOpt])\n        var multiCharHelpCmds = helpCmds.filter(function (k) {\n          return k.length > 1\n        })\n        if (multiCharHelpCmds.length) helpCmds = multiCharHelpCmds\n        // look for and strip any helpCmds from argv._\n        argv._ = argv._.filter(function (cmd) {\n          if (~helpCmds.indexOf(cmd)) {\n            argv[helpOpt] = true\n            return false\n          }\n          return true\n        })\n      }\n\n      // if there's a handler associated with a\n      // command defer processing to it.\n      var handlerKeys = command.getCommands()\n      if (handlerKeys.length) {\n        var firstUnknownCommand\n        for (var i = 0, cmd; (cmd = argv._[i]) !== undefined; i++) {\n          if (~handlerKeys.indexOf(cmd) && cmd !== completionCommand) {\n            setPlaceholderKeys(argv)\n            return command.runCommand(cmd, self, parsed)\n          } else if (!firstUnknownCommand && cmd !== completionCommand) {\n            firstUnknownCommand = cmd\n          }\n        }\n\n        // recommend a command if recommendCommands() has\n        // been enabled, and no commands were found to execute\n        if (recommendCommands && firstUnknownCommand) {\n          validation.recommendCommands(firstUnknownCommand, handlerKeys)\n        }\n      }\n\n      // generate a completion script for adding to ~/.bashrc.\n      if (completionCommand && ~argv._.indexOf(completionCommand) && !argv[completion.completionKey]) {\n        if (exitProcess) setBlocking(true)\n        self.showCompletionScript()\n        self.exit(0)\n      }\n    }\n\n    // we must run completions first, a user might\n    // want to complete the --help or --version option.\n    if (completion.completionKey in argv) {\n      if (exitProcess) setBlocking(true)\n\n      // we allow for asynchronous completions,\n      // e.g., loading in a list of commands from an API.\n      var completionArgs = args.slice(args.indexOf('--' + completion.completionKey) + 1)\n      completion.getCompletion(completionArgs, function (completions) {\n        ;(completions || []).forEach(function (completion) {\n          _logger.log(completion)\n        })\n\n        self.exit(0)\n      })\n      return setPlaceholderKeys(argv)\n    }\n\n    var skipValidation = false\n\n    // Handle 'help' and 'version' options\n    Object.keys(argv).forEach(function (key) {\n      if (key === helpOpt && argv[key]) {\n        if (exitProcess) setBlocking(true)\n\n        skipValidation = true\n        self.showHelp('log')\n        self.exit(0)\n      } else if (key === versionOpt && argv[key]) {\n        if (exitProcess) setBlocking(true)\n\n        skipValidation = true\n        usage.showVersion()\n        self.exit(0)\n      }\n    })\n\n    // Check if any of the options to skip validation were provided\n    if (!skipValidation && options.skipValidation.length > 0) {\n      skipValidation = Object.keys(argv).some(function (key) {\n        return options.skipValidation.indexOf(key) >= 0 && argv[key] === true\n      })\n    }\n\n    // If the help or version options where used and exitProcess is false,\n    // or if explicitly skipped, we won't run validations\n    if (!skipValidation) {\n      if (parsed.error) throw parsed.error\n\n      // if we're executed via bash completion, don't\n      // bother with validation.\n      if (!argv[completion.completionKey]) {\n        validation.nonOptionCount(argv)\n        validation.missingArgumentValue(argv)\n        validation.requiredArguments(argv)\n        if (strict) validation.unknownArguments(argv, aliases)\n        validation.customChecks(argv, aliases)\n        validation.limitedChoices(argv)\n        validation.implications(argv)\n      }\n    }\n\n    return setPlaceholderKeys(argv)\n  }\n\n  function guessLocale () {\n    if (!detectLocale) return\n\n    try {\n      const osLocale = require('os-locale')\n      self.locale(osLocale.sync({ spawn: false }))\n    } catch (err) {\n      // if we explode looking up locale just noop\n      // we'll keep using the default language 'en'.\n    }\n  }\n\n  function setPlaceholderKeys (argv) {\n    Object.keys(options.key).forEach(function (key) {\n      // don't set placeholder keys for dot\n      // notation options 'foo.bar'.\n      if (~key.indexOf('.')) return\n      if (typeof argv[key] === 'undefined') argv[key] = undefined\n    })\n    return argv\n  }\n\n  return self\n}\n\n// rebase an absolute path to a relative one with respect to a base directory\n// exported for tests\nexports.rebase = rebase\nfunction rebase (base, dir) {\n  return path.relative(base, dir)\n}\n","/home/travis/build/npmtest/node-npmtest-auto-install/auto-install/node_modules/yargs/lib/assign.js":"// lazy Object.assign logic that only works for merging\n// two objects; eventually we should replace this with Object.assign.\nmodule.exports = function assign (defaults, configuration) {\n  var o = {}\n  configuration = configuration || {}\n\n  Object.keys(defaults).forEach(function (k) {\n    o[k] = defaults[k]\n  })\n  Object.keys(configuration).forEach(function (k) {\n    o[k] = configuration[k]\n  })\n\n  return o\n}\n","/home/travis/build/npmtest/node-npmtest-auto-install/auto-install/node_modules/yargs/lib/command.js":"const path = require('path')\nconst inspect = require('util').inspect\nconst camelCase = require('camelcase')\n\n// handles parsing positional arguments,\n// and populating argv with said positional\n// arguments.\nmodule.exports = function (yargs, usage, validation) {\n  const self = {}\n\n  var handlers = {}\n  var aliasMap = {}\n  self.addHandler = function (cmd, description, builder, handler) {\n    var aliases = []\n    if (Array.isArray(cmd)) {\n      aliases = cmd.slice(1)\n      cmd = cmd[0]\n    } else if (typeof cmd === 'object') {\n      var command = (Array.isArray(cmd.command) || typeof cmd.command === 'string') ? cmd.command : moduleName(cmd)\n      if (cmd.aliases) command = [].concat(command).concat(cmd.aliases)\n      self.addHandler(command, extractDesc(cmd), cmd.builder, cmd.handler)\n      return\n    }\n\n    // allow a module to be provided instead of separate builder and handler\n    if (typeof builder === 'object' && builder.builder && typeof builder.handler === 'function') {\n      self.addHandler([cmd].concat(aliases), description, builder.builder, builder.handler)\n      return\n    }\n\n    var parsedCommand = parseCommand(cmd)\n    aliases = aliases.map(function (alias) {\n      alias = parseCommand(alias).cmd // remove positional args\n      aliasMap[alias] = parsedCommand.cmd\n      return alias\n    })\n\n    if (description !== false) {\n      usage.command(cmd, description, aliases)\n    }\n\n    handlers[parsedCommand.cmd] = {\n      original: cmd,\n      handler: handler,\n      builder: builder || {},\n      demanded: parsedCommand.demanded,\n      optional: parsedCommand.optional\n    }\n  }\n\n  self.addDirectory = function (dir, context, req, callerFile, opts) {\n    opts = opts || {}\n    // disable recursion to support nested directories of subcommands\n    if (typeof opts.recurse !== 'boolean') opts.recurse = false\n    // exclude 'json', 'coffee' from require-directory defaults\n    if (!Array.isArray(opts.extensions)) opts.extensions = ['js']\n    // allow consumer to define their own visitor function\n    const parentVisit = typeof opts.visit === 'function' ? opts.visit : function (o) { return o }\n    // call addHandler via visitor function\n    opts.visit = function (obj, joined, filename) {\n      const visited = parentVisit(obj, joined, filename)\n      // allow consumer to skip modules with their own visitor\n      if (visited) {\n        // check for cyclic reference\n        // each command file path should only be seen once per execution\n        if (~context.files.indexOf(joined)) return visited\n        // keep track of visited files in context.files\n        context.files.push(joined)\n        self.addHandler(visited)\n      }\n      return visited\n    }\n    require('require-directory')({ require: req, filename: callerFile }, dir, opts)\n  }\n\n  // lookup module object from require()d command and derive name\n  // if module was not require()d and no name given, throw error\n  function moduleName (obj) {\n    const mod = require('which-module')(obj)\n    if (!mod) throw new Error('No command name given for module: ' + inspect(obj))\n    return commandFromFilename(mod.filename)\n  }\n\n  // derive command name from filename\n  function commandFromFilename (filename) {\n    return path.basename(filename, path.extname(filename))\n  }\n\n  function extractDesc (obj) {\n    for (var keys = ['describe', 'description', 'desc'], i = 0, l = keys.length, test; i < l; i++) {\n      test = obj[keys[i]]\n      if (typeof test === 'string' || typeof test === 'boolean') return test\n    }\n    return false\n  }\n\n  function parseCommand (cmd) {\n    var extraSpacesStrippedCommand = cmd.replace(/\\s{2,}/g, ' ')\n    var splitCommand = extraSpacesStrippedCommand.split(/\\s/)\n    var bregex = /\\.*[\\][<>]/g\n    var parsedCommand = {\n      cmd: (splitCommand.shift()).replace(bregex, ''),\n      demanded: [],\n      optional: []\n    }\n    splitCommand.forEach(function (cmd, i) {\n      var variadic = false\n      if (/\\.+[\\]>]/.test(cmd) && i === splitCommand.length - 1) variadic = true\n      if (/^\\[/.test(cmd)) {\n        parsedCommand.optional.push({\n          cmd: cmd.replace(bregex, ''),\n          variadic: variadic\n        })\n      } else {\n        parsedCommand.demanded.push({\n          cmd: cmd.replace(bregex, ''),\n          variadic: variadic\n        })\n      }\n    })\n    return parsedCommand\n  }\n\n  self.getCommands = function () {\n    return Object.keys(handlers).concat(Object.keys(aliasMap))\n  }\n\n  self.getCommandHandlers = function () {\n    return handlers\n  }\n\n  self.runCommand = function (command, yargs, parsed) {\n    var argv = parsed.argv\n    var commandHandler = handlers[command] || handlers[aliasMap[command]]\n    var innerArgv = argv\n    var currentContext = yargs.getContext()\n    var numFiles = currentContext.files.length\n    var parentCommands = currentContext.commands.slice()\n    currentContext.commands.push(command)\n    if (typeof commandHandler.builder === 'function') {\n      // a function can be provided, which builds\n      // up a yargs chain and possibly returns it.\n      innerArgv = commandHandler.builder(yargs.reset(parsed.aliases))\n      // if the builder function did not yet parse argv with reset yargs\n      // and did not explicitly set a usage() string, then apply the\n      // original command string as usage() for consistent behavior with\n      // options object below\n      if (yargs.parsed === false) {\n        if (typeof yargs.getUsageInstance().getUsage() === 'undefined') {\n          yargs.usage('$0 ' + (parentCommands.length ? parentCommands.join(' ') + ' ' : '') + commandHandler.original)\n        }\n        innerArgv = innerArgv ? innerArgv.argv : yargs.argv\n      } else {\n        innerArgv = yargs.parsed.argv\n      }\n    } else if (typeof commandHandler.builder === 'object') {\n      // as a short hand, an object can instead be provided, specifying\n      // the options that a command takes.\n      innerArgv = yargs.reset(parsed.aliases)\n      innerArgv.usage('$0 ' + (parentCommands.length ? parentCommands.join(' ') + ' ' : '') + commandHandler.original)\n      Object.keys(commandHandler.builder).forEach(function (key) {\n        innerArgv.option(key, commandHandler.builder[key])\n      })\n      innerArgv = innerArgv.argv\n    }\n    if (!yargs._hasOutput()) populatePositional(commandHandler, innerArgv, currentContext, yargs)\n\n    if (commandHandler.handler && !yargs._hasOutput()) {\n      commandHandler.handler(innerArgv)\n    }\n    currentContext.commands.pop()\n    numFiles = currentContext.files.length - numFiles\n    if (numFiles > 0) currentContext.files.splice(numFiles * -1, numFiles)\n    return innerArgv\n  }\n\n  function populatePositional (commandHandler, argv, context, yargs) {\n    argv._ = argv._.slice(context.commands.length) // nuke the current commands\n    var demanded = commandHandler.demanded.slice(0)\n    var optional = commandHandler.optional.slice(0)\n\n    validation.positionalCount(demanded.length, argv._.length)\n\n    while (demanded.length) {\n      var demand = demanded.shift()\n      if (demand.variadic) argv[demand.cmd] = []\n      if (!argv._.length) break\n      if (demand.variadic) argv[demand.cmd] = argv._.splice(0)\n      else argv[demand.cmd] = argv._.shift()\n      postProcessPositional(yargs, argv, demand.cmd)\n      addCamelCaseExpansions(argv, demand.cmd)\n    }\n\n    while (optional.length) {\n      var maybe = optional.shift()\n      if (maybe.variadic) argv[maybe.cmd] = []\n      if (!argv._.length) break\n      if (maybe.variadic) argv[maybe.cmd] = argv._.splice(0)\n      else argv[maybe.cmd] = argv._.shift()\n      postProcessPositional(yargs, argv, maybe.cmd)\n      addCamelCaseExpansions(argv, maybe.cmd)\n    }\n\n    argv._ = context.commands.concat(argv._)\n  }\n\n  // TODO move positional arg logic to yargs-parser and remove this duplication\n  function postProcessPositional (yargs, argv, key) {\n    var coerce = yargs.getOptions().coerce[key]\n    if (typeof coerce === 'function') {\n      try {\n        argv[key] = coerce(argv[key])\n      } catch (err) {\n        yargs.getUsageInstance().fail(err.message, err)\n      }\n    }\n  }\n\n  function addCamelCaseExpansions (argv, option) {\n    if (/-/.test(option)) {\n      const cc = camelCase(option)\n      if (typeof argv[option] === 'object') argv[cc] = argv[option].slice(0)\n      else argv[cc] = argv[option]\n    }\n  }\n\n  self.reset = function () {\n    handlers = {}\n    aliasMap = {}\n    return self\n  }\n\n  // used by yargs.parse() to freeze\n  // the state of commands such that\n  // we can apply .parse() multiple times\n  // with the same yargs instance.\n  var frozen\n  self.freeze = function () {\n    frozen = {}\n    frozen.handlers = handlers\n    frozen.aliasMap = aliasMap\n  }\n  self.unfreeze = function () {\n    handlers = frozen.handlers\n    aliasMap = frozen.aliasMap\n    frozen = undefined\n  }\n\n  return self\n}\n","/home/travis/build/npmtest/node-npmtest-auto-install/auto-install/node_modules/yargs/lib/completion.js":"const fs = require('fs')\nconst path = require('path')\n\n// add bash completions to your\n//  yargs-powered applications.\nmodule.exports = function (yargs, usage, command) {\n  const self = {\n    completionKey: 'get-yargs-completions'\n  }\n\n  // get a list of completion commands.\n  // 'args' is the array of strings from the line to be completed\n  self.getCompletion = function (args, done) {\n    const completions = []\n    const current = args.length ? args[args.length - 1] : ''\n    const argv = yargs.parse(args, true)\n    const aliases = yargs.parsed.aliases\n\n    // a custom completion function can be provided\n    // to completion().\n    if (completionFunction) {\n      if (completionFunction.length < 3) {\n        var result = completionFunction(current, argv)\n\n        // promise based completion function.\n        if (typeof result.then === 'function') {\n          return result.then(function (list) {\n            process.nextTick(function () { done(list) })\n          }).catch(function (err) {\n            process.nextTick(function () { throw err })\n          })\n        }\n\n        // synchronous completion function.\n        return done(result)\n      } else {\n        // asynchronous completion function\n        return completionFunction(current, argv, function (completions) {\n          done(completions)\n        })\n      }\n    }\n\n    var handlers = command.getCommandHandlers()\n    for (var i = 0, ii = args.length; i < ii; ++i) {\n      if (handlers[args[i]] && handlers[args[i]].builder) {\n        return handlers[args[i]].builder(yargs.reset()).argv\n      }\n    }\n\n    if (!current.match(/^-/)) {\n      usage.getCommands().forEach(function (command) {\n        if (args.indexOf(command[0]) === -1) {\n          completions.push(command[0])\n        }\n      })\n    }\n\n    if (current.match(/^-/)) {\n      Object.keys(yargs.getOptions().key).forEach(function (key) {\n        // If the key and its aliases aren't in 'args', add the key to 'completions'\n        var keyAndAliases = [key].concat(aliases[key] || [])\n        var notInArgs = keyAndAliases.every(function (val) {\n          return args.indexOf('--' + val) === -1\n        })\n        if (notInArgs) {\n          completions.push('--' + key)\n        }\n      })\n    }\n\n    done(completions)\n  }\n\n  // generate the completion script to add to your .bashrc.\n  self.generateCompletionScript = function ($0) {\n    var script = fs.readFileSync(\n      path.resolve(__dirname, '../completion.sh.hbs'),\n      'utf-8'\n    )\n    var name = path.basename($0)\n\n    // add ./to applications not yet installed as bin.\n    if ($0.match(/\\.js$/)) $0 = './' + $0\n\n    script = script.replace(/{{app_name}}/g, name)\n    return script.replace(/{{app_path}}/g, $0)\n  }\n\n  // register a function to perform your own custom\n  // completions., this function can be either\n  // synchrnous or asynchronous.\n  var completionFunction = null\n  self.registerFunction = function (fn) {\n    completionFunction = fn\n  }\n\n  return self\n}\n","/home/travis/build/npmtest/node-npmtest-auto-install/auto-install/node_modules/yargs-parser/index.js":"var camelCase = require('camelcase')\nvar path = require('path')\nvar tokenizeArgString = require('./lib/tokenize-arg-string')\nvar util = require('util')\n\nfunction parse (args, opts) {\n  if (!opts) opts = {}\n  // allow a string argument to be passed in rather\n  // than an argv array.\n  args = tokenizeArgString(args)\n  // aliases might have transitive relationships, normalize this.\n  var aliases = combineAliases(opts.alias || {})\n  var configuration = assign({\n    'short-option-groups': true,\n    'camel-case-expansion': true,\n    'dot-notation': true,\n    'parse-numbers': true,\n    'boolean-negation': true,\n    'duplicate-arguments-array': true,\n    'flatten-duplicate-arrays': true\n  }, opts.configuration)\n  var defaults = opts.default || {}\n  var configObjects = opts.configObjects || []\n  var envPrefix = opts.envPrefix\n  var newAliases = {}\n  // allow a i18n handler to be passed in, default to a fake one (util.format).\n  var __ = opts.__ || function (str) {\n    return util.format.apply(util, Array.prototype.slice.call(arguments))\n  }\n  var error = null\n  var flags = {\n    aliases: {},\n    arrays: {},\n    bools: {},\n    strings: {},\n    numbers: {},\n    counts: {},\n    normalize: {},\n    configs: {},\n    defaulted: {},\n    nargs: {},\n    coercions: {}\n  }\n  var negative = /^-[0-9]+(\\.[0-9]+)?/\n\n  ;[].concat(opts.array).filter(Boolean).forEach(function (key) {\n    flags.arrays[key] = true\n  })\n\n  ;[].concat(opts.boolean).filter(Boolean).forEach(function (key) {\n    flags.bools[key] = true\n  })\n\n  ;[].concat(opts.string).filter(Boolean).forEach(function (key) {\n    flags.strings[key] = true\n  })\n\n  ;[].concat(opts.number).filter(Boolean).forEach(function (key) {\n    flags.numbers[key] = true\n  })\n\n  ;[].concat(opts.count).filter(Boolean).forEach(function (key) {\n    flags.counts[key] = true\n  })\n\n  ;[].concat(opts.normalize).filter(Boolean).forEach(function (key) {\n    flags.normalize[key] = true\n  })\n\n  Object.keys(opts.narg || {}).forEach(function (k) {\n    flags.nargs[k] = opts.narg[k]\n  })\n\n  Object.keys(opts.coerce || {}).forEach(function (k) {\n    flags.coercions[k] = opts.coerce[k]\n  })\n\n  if (Array.isArray(opts.config) || typeof opts.config === 'string') {\n    ;[].concat(opts.config).filter(Boolean).forEach(function (key) {\n      flags.configs[key] = true\n    })\n  } else {\n    Object.keys(opts.config || {}).forEach(function (k) {\n      flags.configs[k] = opts.config[k]\n    })\n  }\n\n  // create a lookup table that takes into account all\n  // combinations of aliases: {f: ['foo'], foo: ['f']}\n  extendAliases(opts.key, aliases, opts.default, flags.arrays)\n\n  // apply default values to all aliases.\n  Object.keys(defaults).forEach(function (key) {\n    (flags.aliases[key] || []).forEach(function (alias) {\n      defaults[alias] = defaults[key]\n    })\n  })\n\n  var argv = { _: [] }\n\n  Object.keys(flags.bools).forEach(function (key) {\n    setArg(key, !(key in defaults) ? false : defaults[key])\n    setDefaulted(key)\n  })\n\n  var notFlags = []\n  if (args.indexOf('--') !== -1) {\n    notFlags = args.slice(args.indexOf('--') + 1)\n    args = args.slice(0, args.indexOf('--'))\n  }\n\n  for (var i = 0; i < args.length; i++) {\n    var arg = args[i]\n    var broken\n    var key\n    var letters\n    var m\n    var next\n    var value\n\n    // -- seperated by =\n    if (arg.match(/^--.+=/) || (\n      !configuration['short-option-groups'] && arg.match(/^-.+=/)\n    )) {\n      // Using [\\s\\S] instead of . because js doesn't support the\n      // 'dotall' regex modifier. See:\n      // http://stackoverflow.com/a/1068308/13216\n      m = arg.match(/^--?([^=]+)=([\\s\\S]*)$/)\n\n      // nargs format = '--f=monkey washing cat'\n      if (checkAllAliases(m[1], flags.nargs)) {\n        args.splice(i + 1, 0, m[2])\n        i = eatNargs(i, m[1], args)\n      // arrays format = '--f=a b c'\n      } else if (checkAllAliases(m[1], flags.arrays) && args.length > i + 1) {\n        args.splice(i + 1, 0, m[2])\n        i = eatArray(i, m[1], args)\n      } else {\n        setArg(m[1], m[2])\n      }\n    } else if (arg.match(/^--no-.+/) && configuration['boolean-negation']) {\n      key = arg.match(/^--no-(.+)/)[1]\n      setArg(key, false)\n\n    // -- seperated by space.\n    } else if (arg.match(/^--.+/) || (\n      !configuration['short-option-groups'] && arg.match(/^-.+/)\n    )) {\n      key = arg.match(/^--?(.+)/)[1]\n\n      // nargs format = '--foo a b c'\n      if (checkAllAliases(key, flags.nargs)) {\n        i = eatNargs(i, key, args)\n      // array format = '--foo a b c'\n      } else if (checkAllAliases(key, flags.arrays) && args.length > i + 1) {\n        i = eatArray(i, key, args)\n      } else {\n        next = args[i + 1]\n\n        if (next !== undefined && (!next.match(/^-/) ||\n          next.match(negative)) &&\n          !checkAllAliases(key, flags.bools) &&\n          !checkAllAliases(key, flags.counts)) {\n          setArg(key, next)\n          i++\n        } else if (/^(true|false)$/.test(next)) {\n          setArg(key, next)\n          i++\n        } else {\n          setArg(key, defaultForType(guessType(key, flags)))\n        }\n      }\n\n    // dot-notation flag seperated by '='.\n    } else if (arg.match(/^-.\\..+=/)) {\n      m = arg.match(/^-([^=]+)=([\\s\\S]*)$/)\n      setArg(m[1], m[2])\n\n    // dot-notation flag seperated by space.\n    } else if (arg.match(/^-.\\..+/)) {\n      next = args[i + 1]\n      key = arg.match(/^-(.\\..+)/)[1]\n\n      if (next !== undefined && !next.match(/^-/) &&\n        !checkAllAliases(key, flags.bools) &&\n        !checkAllAliases(key, flags.counts)) {\n        setArg(key, next)\n        i++\n      } else {\n        setArg(key, defaultForType(guessType(key, flags)))\n      }\n    } else if (arg.match(/^-[^-]+/) && !arg.match(negative)) {\n      letters = arg.slice(1, -1).split('')\n      broken = false\n\n      for (var j = 0; j < letters.length; j++) {\n        next = arg.slice(j + 2)\n\n        if (letters[j + 1] && letters[j + 1] === '=') {\n          value = arg.slice(j + 3)\n          key = letters[j]\n\n          // nargs format = '-f=monkey washing cat'\n          if (checkAllAliases(key, flags.nargs)) {\n            args.splice(i + 1, 0, value)\n            i = eatNargs(i, key, args)\n          // array format = '-f=a b c'\n          } else if (checkAllAliases(key, flags.arrays) && args.length > i + 1) {\n            args.splice(i + 1, 0, value)\n            i = eatArray(i, key, args)\n          } else {\n            setArg(key, value)\n          }\n\n          broken = true\n          break\n        }\n\n        if (next === '-') {\n          setArg(letters[j], next)\n          continue\n        }\n\n        // current letter is an alphabetic character and next value is a number\n        if (/[A-Za-z]/.test(letters[j]) &&\n          /^-?\\d+(\\.\\d*)?(e-?\\d+)?$/.test(next)) {\n          setArg(letters[j], next)\n          broken = true\n          break\n        }\n\n        if (letters[j + 1] && letters[j + 1].match(/\\W/)) {\n          setArg(letters[j], next)\n          broken = true\n          break\n        } else {\n          setArg(letters[j], defaultForType(guessType(letters[j], flags)))\n        }\n      }\n\n      key = arg.slice(-1)[0]\n\n      if (!broken && key !== '-') {\n        // nargs format = '-f a b c'\n        if (checkAllAliases(key, flags.nargs)) {\n          i = eatNargs(i, key, args)\n        // array format = '-f a b c'\n        } else if (checkAllAliases(key, flags.arrays) && args.length > i + 1) {\n          i = eatArray(i, key, args)\n        } else {\n          next = args[i + 1]\n\n          if (next !== undefined && (!/^(-|--)[^-]/.test(next) ||\n            next.match(negative)) &&\n            !checkAllAliases(key, flags.bools) &&\n            !checkAllAliases(key, flags.counts)) {\n            setArg(key, next)\n            i++\n          } else if (/^(true|false)$/.test(next)) {\n            setArg(key, next)\n            i++\n          } else {\n            setArg(key, defaultForType(guessType(key, flags)))\n          }\n        }\n      }\n    } else {\n      argv._.push(\n        flags.strings['_'] || !isNumber(arg) ? arg : Number(arg)\n      )\n    }\n  }\n\n  // order of precedence:\n  // 1. command line arg\n  // 2. value from config file\n  // 3. value from config objects\n  // 4. value from env var\n  // 5. configured default value\n  applyEnvVars(argv, true) // special case: check env vars that point to config file\n  setConfig(argv)\n  setConfigObjects()\n  applyEnvVars(argv, false)\n  applyDefaultsAndAliases(argv, flags.aliases, defaults)\n  applyCoercions(argv)\n\n  // for any counts either not in args or without an explicit default, set to 0\n  Object.keys(flags.counts).forEach(function (key) {\n    if (!hasKey(argv, key.split('.'))) setArg(key, 0)\n  })\n\n  notFlags.forEach(function (key) {\n    argv._.push(key)\n  })\n\n  // how many arguments should we consume, based\n  // on the nargs option?\n  function eatNargs (i, key, args) {\n    var toEat = checkAllAliases(key, flags.nargs)\n\n    if (args.length - (i + 1) < toEat) error = Error(__('Not enough arguments following: %s', key))\n\n    for (var ii = i + 1; ii < (toEat + i + 1); ii++) {\n      setArg(key, args[ii])\n    }\n\n    return (i + toEat)\n  }\n\n  // if an option is an array, eat all non-hyphenated arguments\n  // following it... YUM!\n  // e.g., --foo apple banana cat becomes [\"apple\", \"banana\", \"cat\"]\n  function eatArray (i, key, args) {\n    var start = i + 1\n    var argsToSet = []\n    var multipleArrayFlag = i > 0\n    for (var ii = i + 1; ii < args.length; ii++) {\n      if (/^-/.test(args[ii]) && !negative.test(args[ii])) {\n        if (ii === start) {\n          setArg(key, defaultForType('array'))\n        }\n        multipleArrayFlag = true\n        break\n      }\n      i = ii\n      argsToSet.push(args[ii])\n    }\n    if (multipleArrayFlag) {\n      setArg(key, argsToSet.map(function (arg) {\n        return processValue(key, arg)\n      }))\n    } else {\n      argsToSet.forEach(function (arg) {\n        setArg(key, arg)\n      })\n    }\n\n    return i\n  }\n\n  function setArg (key, val) {\n    unsetDefaulted(key)\n\n    if (/-/.test(key) && !(flags.aliases[key] && flags.aliases[key].length) && configuration['camel-case-expansion']) {\n      var c = camelCase(key)\n      flags.aliases[key] = [c]\n      newAliases[c] = true\n    }\n\n    var value = processValue(key, val)\n\n    var splitKey = key.split('.')\n    setKey(argv, splitKey, value)\n\n    // handle populating aliases of the full key\n    if (flags.aliases[key]) {\n      flags.aliases[key].forEach(function (x) {\n        x = x.split('.')\n        setKey(argv, x, value)\n      })\n    }\n\n    // handle populating aliases of the first element of the dot-notation key\n    if (splitKey.length > 1 && configuration['dot-notation']) {\n      ;(flags.aliases[splitKey[0]] || []).forEach(function (x) {\n        x = x.split('.')\n\n        // expand alias with nested objects in key\n        var a = [].concat(splitKey)\n        a.shift() // nuke the old key.\n        x = x.concat(a)\n\n        setKey(argv, x, value)\n      })\n    }\n\n    // Set normalize getter and setter when key is in 'normalize' but isn't an array\n    if (checkAllAliases(key, flags.normalize) && !checkAllAliases(key, flags.arrays)) {\n      var keys = [key].concat(flags.aliases[key] || [])\n      keys.forEach(function (key) {\n        argv.__defineSetter__(key, function (v) {\n          val = path.normalize(v)\n        })\n\n        argv.__defineGetter__(key, function () {\n          return typeof val === 'string' ? path.normalize(val) : val\n        })\n      })\n    }\n  }\n\n  function processValue (key, val) {\n    // handle parsing boolean arguments --foo=true --bar false.\n    if (checkAllAliases(key, flags.bools) || checkAllAliases(key, flags.counts)) {\n      if (typeof val === 'string') val = val === 'true'\n    }\n\n    var value = val\n    if (!checkAllAliases(key, flags.strings) && !checkAllAliases(key, flags.coercions)) {\n      if (isNumber(val)) value = Number(val)\n      if (!isUndefined(val) && !isNumber(val) && checkAllAliases(key, flags.numbers)) value = NaN\n    }\n\n    // increment a count given as arg (either no value or value parsed as boolean)\n    if (checkAllAliases(key, flags.counts) && (isUndefined(value) || typeof value === 'boolean')) {\n      value = increment\n    }\n\n    // Set normalized value when key is in 'normalize' and in 'arrays'\n    if (checkAllAliases(key, flags.normalize) && checkAllAliases(key, flags.arrays)) {\n      if (Array.isArray(val)) value = val.map(path.normalize)\n      else value = path.normalize(val)\n    }\n    return value\n  }\n\n  // set args from config.json file, this should be\n  // applied last so that defaults can be applied.\n  function setConfig (argv) {\n    var configLookup = {}\n\n    // expand defaults/aliases, in-case any happen to reference\n    // the config.json file.\n    applyDefaultsAndAliases(configLookup, flags.aliases, defaults)\n\n    Object.keys(flags.configs).forEach(function (configKey) {\n      var configPath = argv[configKey] || configLookup[configKey]\n      if (configPath) {\n        try {\n          var config = null\n          var resolvedConfigPath = path.resolve(process.cwd(), configPath)\n\n          if (typeof flags.configs[configKey] === 'function') {\n            try {\n              config = flags.configs[configKey](resolvedConfigPath)\n            } catch (e) {\n              config = e\n            }\n            if (config instanceof Error) {\n              error = config\n              return\n            }\n          } else {\n            config = require(resolvedConfigPath)\n          }\n\n          setConfigObject(config)\n        } catch (ex) {\n          if (argv[configKey]) error = Error(__('Invalid JSON config file: %s', configPath))\n        }\n      }\n    })\n  }\n\n  // set args from config object.\n  // it recursively checks nested objects.\n  function setConfigObject (config, prev) {\n    Object.keys(config).forEach(function (key) {\n      var value = config[key]\n      var fullKey = prev ? prev + '.' + key : key\n\n      // if the value is an inner object and we have dot-notation\n      // enabled, treat inner objects in config the same as\n      // heavily nested dot notations (foo.bar.apple).\n      if (typeof value === 'object' && !Array.isArray(value) && configuration['dot-notation']) {\n        // if the value is an object but not an array, check nested object\n        setConfigObject(value, fullKey)\n      } else {\n        // setting arguments via CLI takes precedence over\n        // values within the config file.\n        if (!hasKey(argv, fullKey.split('.')) || (flags.defaulted[fullKey])) {\n          setArg(fullKey, value)\n        }\n      }\n    })\n  }\n\n  // set all config objects passed in opts\n  function setConfigObjects () {\n    if (typeof configObjects === 'undefined') return\n    configObjects.forEach(function (configObject) {\n      setConfigObject(configObject)\n    })\n  }\n\n  function applyEnvVars (argv, configOnly) {\n    if (typeof envPrefix === 'undefined') return\n\n    var prefix = typeof envPrefix === 'string' ? envPrefix : ''\n    Object.keys(process.env).forEach(function (envVar) {\n      if (prefix === '' || envVar.lastIndexOf(prefix, 0) === 0) {\n        // get array of nested keys and convert them to camel case\n        var keys = envVar.split('__').map(function (key, i) {\n          if (i === 0) {\n            key = key.substring(prefix.length)\n          }\n          return camelCase(key)\n        })\n\n        if (((configOnly && flags.configs[keys.join('.')]) || !configOnly) && (!hasKey(argv, keys) || flags.defaulted[keys.join('.')])) {\n          setArg(keys.join('.'), process.env[envVar])\n        }\n      }\n    })\n  }\n\n  function applyCoercions (argv) {\n    var coerce\n    Object.keys(argv).forEach(function (key) {\n      coerce = checkAllAliases(key, flags.coercions)\n      if (typeof coerce === 'function') {\n        try {\n          argv[key] = coerce(argv[key])\n        } catch (err) {\n          error = err\n        }\n      }\n    })\n  }\n\n  function applyDefaultsAndAliases (obj, aliases, defaults) {\n    Object.keys(defaults).forEach(function (key) {\n      if (!hasKey(obj, key.split('.'))) {\n        setKey(obj, key.split('.'), defaults[key])\n\n        ;(aliases[key] || []).forEach(function (x) {\n          if (hasKey(obj, x.split('.'))) return\n          setKey(obj, x.split('.'), defaults[key])\n        })\n      }\n    })\n  }\n\n  function hasKey (obj, keys) {\n    var o = obj\n\n    if (!configuration['dot-notation']) keys = [keys.join('.')]\n\n    keys.slice(0, -1).forEach(function (key) {\n      o = (o[key] || {})\n    })\n\n    var key = keys[keys.length - 1]\n\n    if (typeof o !== 'object') return false\n    else return key in o\n  }\n\n  function setKey (obj, keys, value) {\n    var o = obj\n\n    if (!configuration['dot-notation']) keys = [keys.join('.')]\n\n    keys.slice(0, -1).forEach(function (key) {\n      if (o[key] === undefined) o[key] = {}\n      o = o[key]\n    })\n\n    var key = keys[keys.length - 1]\n\n    var isTypeArray = checkAllAliases(key, flags.arrays)\n    var isValueArray = Array.isArray(value)\n    var duplicate = configuration['duplicate-arguments-array']\n\n    if (value === increment) {\n      o[key] = increment(o[key])\n    } else if (Array.isArray(o[key])) {\n      if (duplicate && isTypeArray && isValueArray) {\n        o[key] = configuration['flatten-duplicate-arrays'] ? o[key].concat(value) : [o[key]].concat([value])\n      } else if (!duplicate && Boolean(isTypeArray) === Boolean(isValueArray)) {\n        o[key] = value\n      } else {\n        o[key] = o[key].concat([value])\n      }\n    } else if (o[key] === undefined && isTypeArray) {\n      o[key] = isValueArray ? value : [value]\n    } else if (duplicate && !(o[key] === undefined || checkAllAliases(key, flags.bools) || checkAllAliases(keys.join('.'), flags.bools) || checkAllAliases(key, flags.counts))) {\n      o[key] = [ o[key], value ]\n    } else {\n      o[key] = value\n    }\n  }\n\n  // extend the aliases list with inferred aliases.\n  function extendAliases () {\n    Array.prototype.slice.call(arguments).forEach(function (obj) {\n      Object.keys(obj || {}).forEach(function (key) {\n        // short-circuit if we've already added a key\n        // to the aliases array, for example it might\n        // exist in both 'opts.default' and 'opts.key'.\n        if (flags.aliases[key]) return\n\n        flags.aliases[key] = [].concat(aliases[key] || [])\n        // For \"--option-name\", also set argv.optionName\n        flags.aliases[key].concat(key).forEach(function (x) {\n          if (/-/.test(x) && configuration['camel-case-expansion']) {\n            var c = camelCase(x)\n            flags.aliases[key].push(c)\n            newAliases[c] = true\n          }\n        })\n        flags.aliases[key].forEach(function (x) {\n          flags.aliases[x] = [key].concat(flags.aliases[key].filter(function (y) {\n            return x !== y\n          }))\n        })\n      })\n    })\n  }\n\n  // check if a flag is set for any of a key's aliases.\n  function checkAllAliases (key, flag) {\n    var isSet = false\n    var toCheck = [].concat(flags.aliases[key] || [], key)\n\n    toCheck.forEach(function (key) {\n      if (flag[key]) isSet = flag[key]\n    })\n\n    return isSet\n  }\n\n  function setDefaulted (key) {\n    [].concat(flags.aliases[key] || [], key).forEach(function (k) {\n      flags.defaulted[k] = true\n    })\n  }\n\n  function unsetDefaulted (key) {\n    [].concat(flags.aliases[key] || [], key).forEach(function (k) {\n      delete flags.defaulted[k]\n    })\n  }\n\n  // return a default value, given the type of a flag.,\n  // e.g., key of type 'string' will default to '', rather than 'true'.\n  function defaultForType (type) {\n    var def = {\n      boolean: true,\n      string: '',\n      number: undefined,\n      array: []\n    }\n\n    return def[type]\n  }\n\n  // given a flag, enforce a default type.\n  function guessType (key, flags) {\n    var type = 'boolean'\n\n    if (checkAllAliases(key, flags.strings)) type = 'string'\n    else if (checkAllAliases(key, flags.numbers)) type = 'number'\n    else if (checkAllAliases(key, flags.arrays)) type = 'array'\n\n    return type\n  }\n\n  function isNumber (x) {\n    if (!configuration['parse-numbers']) return false\n    if (typeof x === 'number') return true\n    if (/^0x[0-9a-f]+$/i.test(x)) return true\n    return /^[-+]?(?:\\d+(?:\\.\\d*)?|\\.\\d+)(e[-+]?\\d+)?$/.test(x)\n  }\n\n  function isUndefined (num) {\n    return num === undefined\n  }\n\n  return {\n    argv: argv,\n    error: error,\n    aliases: flags.aliases,\n    newAliases: newAliases,\n    configuration: configuration\n  }\n}\n\n// if any aliases reference each other, we should\n// merge them together.\nfunction combineAliases (aliases) {\n  var aliasArrays = []\n  var change = true\n  var combined = {}\n\n  // turn alias lookup hash {key: ['alias1', 'alias2']} into\n  // a simple array ['key', 'alias1', 'alias2']\n  Object.keys(aliases).forEach(function (key) {\n    aliasArrays.push(\n      [].concat(aliases[key], key)\n    )\n  })\n\n  // combine arrays until zero changes are\n  // made in an iteration.\n  while (change) {\n    change = false\n    for (var i = 0; i < aliasArrays.length; i++) {\n      for (var ii = i + 1; ii < aliasArrays.length; ii++) {\n        var intersect = aliasArrays[i].filter(function (v) {\n          return aliasArrays[ii].indexOf(v) !== -1\n        })\n\n        if (intersect.length) {\n          aliasArrays[i] = aliasArrays[i].concat(aliasArrays[ii])\n          aliasArrays.splice(ii, 1)\n          change = true\n          break\n        }\n      }\n    }\n  }\n\n  // map arrays back to the hash-lookup (de-dupe while\n  // we're at it).\n  aliasArrays.forEach(function (aliasArray) {\n    aliasArray = aliasArray.filter(function (v, i, self) {\n      return self.indexOf(v) === i\n    })\n    combined[aliasArray.pop()] = aliasArray\n  })\n\n  return combined\n}\n\nfunction assign (defaults, configuration) {\n  var o = {}\n  configuration = configuration || {}\n\n  Object.keys(defaults).forEach(function (k) {\n    o[k] = defaults[k]\n  })\n  Object.keys(configuration).forEach(function (k) {\n    o[k] = configuration[k]\n  })\n\n  return o\n}\n\n// this function should only be called when a count is given as an arg\n// it is NOT called to set a default value\n// thus we can start the count at 1 instead of 0\nfunction increment (orig) {\n  return orig !== undefined ? orig + 1 : 1\n}\n\nfunction Parser (args, opts) {\n  var result = parse(args.slice(), opts)\n\n  return result.argv\n}\n\n// parse arguments and return detailed\n// meta information, aliases, etc.\nParser.detailed = function (args, opts) {\n  return parse(args.slice(), opts)\n}\n\nmodule.exports = Parser\n","/home/travis/build/npmtest/node-npmtest-auto-install/auto-install/node_modules/yargs-parser/lib/tokenize-arg-string.js":"// take an un-split argv string and tokenize it.\nmodule.exports = function (argString) {\n  if (Array.isArray(argString)) return argString\n\n  var i = 0\n  var c = null\n  var opening = null\n  var args = []\n\n  for (var ii = 0; ii < argString.length; ii++) {\n    c = argString.charAt(ii)\n\n    // split on spaces unless we're in quotes.\n    if (c === ' ' && !opening) {\n      i++\n      continue\n    }\n\n    // don't split the string if we're in matching\n    // opening or closing single and double quotes.\n    if (c === opening) {\n      opening = null\n      continue\n    } else if ((c === \"'\" || c === '\"') && !opening) {\n      opening = c\n      continue\n    }\n\n    if (!args[i]) args[i] = ''\n    args[i] += c\n  }\n\n  return args\n}\n","/home/travis/build/npmtest/node-npmtest-auto-install/auto-install/node_modules/yargs/lib/usage.js":"// this file handles outputting usage instructions,\n// failures, etc. keeps logging in one place.\nconst stringWidth = require('string-width')\nconst objFilter = require('./obj-filter')\nconst setBlocking = require('set-blocking')\n\nmodule.exports = function (yargs, y18n) {\n  const __ = y18n.__\n  const self = {}\n\n  // methods for ouputting/building failure message.\n  var fails = []\n  self.failFn = function (f) {\n    fails.push(f)\n  }\n\n  var failMessage = null\n  var showHelpOnFail = true\n  self.showHelpOnFail = function (enabled, message) {\n    if (typeof enabled === 'string') {\n      message = enabled\n      enabled = true\n    } else if (typeof enabled === 'undefined') {\n      enabled = true\n    }\n    failMessage = message\n    showHelpOnFail = enabled\n    return self\n  }\n\n  var failureOutput = false\n  self.fail = function (msg, err) {\n    const logger = yargs._getLoggerInstance()\n\n    if (fails.length) {\n      for (var i = fails.length - 1; i >= 0; --i) {\n        fails[i](msg, err)\n      }\n    } else {\n      if (yargs.getExitProcess()) setBlocking(true)\n\n      // don't output failure message more than once\n      if (!failureOutput) {\n        failureOutput = true\n        if (showHelpOnFail) yargs.showHelp('error')\n        if (msg) logger.error(msg)\n        if (failMessage) {\n          if (msg) logger.error('')\n          logger.error(failMessage)\n        }\n      }\n\n      err = err || new Error(msg)\n      if (yargs.getExitProcess()) {\n        return yargs.exit(1)\n      } else if (yargs._hasParseCallback()) {\n        return yargs.exit(1, err)\n      } else {\n        throw err\n      }\n    }\n  }\n\n  // methods for ouputting/building help (usage) message.\n  var usage\n  self.usage = function (msg) {\n    usage = msg\n  }\n  self.getUsage = function () {\n    return usage\n  }\n\n  var examples = []\n  self.example = function (cmd, description) {\n    examples.push([cmd, description || ''])\n  }\n\n  var commands = []\n  self.command = function (cmd, description, aliases) {\n    commands.push([cmd, description || '', aliases])\n  }\n  self.getCommands = function () {\n    return commands\n  }\n\n  var descriptions = {}\n  self.describe = function (key, desc) {\n    if (typeof key === 'object') {\n      Object.keys(key).forEach(function (k) {\n        self.describe(k, key[k])\n      })\n    } else {\n      descriptions[key] = desc\n    }\n  }\n  self.getDescriptions = function () {\n    return descriptions\n  }\n\n  var epilog\n  self.epilog = function (msg) {\n    epilog = msg\n  }\n\n  var wrapSet = false\n  var wrap\n  self.wrap = function (cols) {\n    wrapSet = true\n    wrap = cols\n  }\n\n  function getWrap () {\n    // lazily call windowWidth() because it's very expensive,\n    // and only needs to be called if the user wants to show usage/help\n    if (!wrapSet) {\n      wrap = windowWidth()\n      wrapSet = true\n    }\n    return wrap\n  }\n\n  var deferY18nLookupPrefix = '__yargsString__:'\n  self.deferY18nLookup = function (str) {\n    return deferY18nLookupPrefix + str\n  }\n\n  var defaultGroup = 'Options:'\n  self.help = function () {\n    normalizeAliases()\n\n    var demanded = yargs.getDemanded()\n    var groups = yargs.getGroups()\n    var options = yargs.getOptions()\n    var keys = Object.keys(\n      Object.keys(descriptions)\n      .concat(Object.keys(demanded))\n      .concat(Object.keys(options.default))\n      .reduce(function (acc, key) {\n        if (key !== '_') acc[key] = true\n        return acc\n      }, {})\n    )\n    var theWrap = getWrap()\n    var ui = require('cliui')({\n      width: theWrap,\n      wrap: !!theWrap\n    })\n\n    // the usage string.\n    if (usage) {\n      var u = usage.replace(/\\$0/g, yargs.$0)\n      ui.div(u + '\\n')\n    }\n\n    // your application's commands, i.e., non-option\n    // arguments populated in '_'.\n    if (commands.length) {\n      ui.div(__('Commands:'))\n\n      commands.forEach(function (command) {\n        ui.span(\n          {text: command[0], padding: [0, 2, 0, 2], width: maxWidth(commands, theWrap) + 4},\n          {text: command[1]}\n        )\n        if (command[2] && command[2].length) {\n          ui.div({text: '[' + __('aliases:') + ' ' + command[2].join(', ') + ']', padding: [0, 0, 0, 2], align: 'right'})\n        } else {\n          ui.div()\n        }\n      })\n\n      ui.div()\n    }\n\n    // perform some cleanup on the keys array, making it\n    // only include top-level keys not their aliases.\n    var aliasKeys = (Object.keys(options.alias) || [])\n      .concat(Object.keys(yargs.parsed.newAliases) || [])\n\n    keys = keys.filter(function (key) {\n      return !yargs.parsed.newAliases[key] && aliasKeys.every(function (alias) {\n        return (options.alias[alias] || []).indexOf(key) === -1\n      })\n    })\n\n    // populate 'Options:' group with any keys that have not\n    // explicitly had a group set.\n    if (!groups[defaultGroup]) groups[defaultGroup] = []\n    addUngroupedKeys(keys, options.alias, groups)\n\n    // display 'Options:' table along with any custom tables:\n    Object.keys(groups).forEach(function (groupName) {\n      if (!groups[groupName].length) return\n\n      ui.div(__(groupName))\n\n      // if we've grouped the key 'f', but 'f' aliases 'foobar',\n      // normalizedKeys should contain only 'foobar'.\n      var normalizedKeys = groups[groupName].map(function (key) {\n        if (~aliasKeys.indexOf(key)) return key\n        for (var i = 0, aliasKey; (aliasKey = aliasKeys[i]) !== undefined; i++) {\n          if (~(options.alias[aliasKey] || []).indexOf(key)) return aliasKey\n        }\n        return key\n      })\n\n      // actually generate the switches string --foo, -f, --bar.\n      var switches = normalizedKeys.reduce(function (acc, key) {\n        acc[key] = [ key ].concat(options.alias[key] || [])\n          .map(function (sw) {\n            return (sw.length > 1 ? '--' : '-') + sw\n          })\n          .join(', ')\n\n        return acc\n      }, {})\n\n      normalizedKeys.forEach(function (key) {\n        var kswitch = switches[key]\n        var desc = descriptions[key] || ''\n        var type = null\n\n        if (~desc.lastIndexOf(deferY18nLookupPrefix)) desc = __(desc.substring(deferY18nLookupPrefix.length))\n\n        if (~options.boolean.indexOf(key)) type = '[' + __('boolean') + ']'\n        if (~options.count.indexOf(key)) type = '[' + __('count') + ']'\n        if (~options.string.indexOf(key)) type = '[' + __('string') + ']'\n        if (~options.normalize.indexOf(key)) type = '[' + __('string') + ']'\n        if (~options.array.indexOf(key)) type = '[' + __('array') + ']'\n        if (~options.number.indexOf(key)) type = '[' + __('number') + ']'\n\n        var extra = [\n          type,\n          demanded[key] ? '[' + __('required') + ']' : null,\n          options.choices && options.choices[key] ? '[' + __('choices:') + ' ' +\n            self.stringifiedValues(options.choices[key]) + ']' : null,\n          defaultString(options.default[key], options.defaultDescription[key])\n        ].filter(Boolean).join(' ')\n\n        ui.span(\n          {text: kswitch, padding: [0, 2, 0, 2], width: maxWidth(switches, theWrap) + 4},\n          desc\n        )\n\n        if (extra) ui.div({text: extra, padding: [0, 0, 0, 2], align: 'right'})\n        else ui.div()\n      })\n\n      ui.div()\n    })\n\n    // describe some common use-cases for your application.\n    if (examples.length) {\n      ui.div(__('Examples:'))\n\n      examples.forEach(function (example) {\n        example[0] = example[0].replace(/\\$0/g, yargs.$0)\n      })\n\n      examples.forEach(function (example) {\n        ui.div(\n          {text: example[0], padding: [0, 2, 0, 2], width: maxWidth(examples, theWrap) + 4},\n          example[1]\n        )\n      })\n\n      ui.div()\n    }\n\n    // the usage string.\n    if (epilog) {\n      var e = epilog.replace(/\\$0/g, yargs.$0)\n      ui.div(e + '\\n')\n    }\n\n    return ui.toString()\n  }\n\n  // return the maximum width of a string\n  // in the left-hand column of a table.\n  function maxWidth (table, theWrap) {\n    var width = 0\n\n    // table might be of the form [leftColumn],\n    // or {key: leftColumn}\n    if (!Array.isArray(table)) {\n      table = Object.keys(table).map(function (key) {\n        return [table[key]]\n      })\n    }\n\n    table.forEach(function (v) {\n      width = Math.max(stringWidth(v[0]), width)\n    })\n\n    // if we've enabled 'wrap' we should limit\n    // the max-width of the left-column.\n    if (theWrap) width = Math.min(width, parseInt(theWrap * 0.5, 10))\n\n    return width\n  }\n\n  // make sure any options set for aliases,\n  // are copied to the keys being aliased.\n  function normalizeAliases () {\n    var demanded = yargs.getDemanded()\n    var options = yargs.getOptions()\n\n    ;(Object.keys(options.alias) || []).forEach(function (key) {\n      options.alias[key].forEach(function (alias) {\n        // copy descriptions.\n        if (descriptions[alias]) self.describe(key, descriptions[alias])\n        // copy demanded.\n        if (demanded[alias]) yargs.demand(key, demanded[alias].msg)\n        // type messages.\n        if (~options.boolean.indexOf(alias)) yargs.boolean(key)\n        if (~options.count.indexOf(alias)) yargs.count(key)\n        if (~options.string.indexOf(alias)) yargs.string(key)\n        if (~options.normalize.indexOf(alias)) yargs.normalize(key)\n        if (~options.array.indexOf(alias)) yargs.array(key)\n        if (~options.number.indexOf(alias)) yargs.number(key)\n      })\n    })\n  }\n\n  // given a set of keys, place any keys that are\n  // ungrouped under the 'Options:' grouping.\n  function addUngroupedKeys (keys, aliases, groups) {\n    var groupedKeys = []\n    var toCheck = null\n    Object.keys(groups).forEach(function (group) {\n      groupedKeys = groupedKeys.concat(groups[group])\n    })\n\n    keys.forEach(function (key) {\n      toCheck = [key].concat(aliases[key])\n      if (!toCheck.some(function (k) {\n        return groupedKeys.indexOf(k) !== -1\n      })) {\n        groups[defaultGroup].push(key)\n      }\n    })\n    return groupedKeys\n  }\n\n  self.showHelp = function (level) {\n    const logger = yargs._getLoggerInstance()\n    if (!level) level = 'error'\n    var emit = typeof level === 'function' ? level : logger[level]\n    emit(self.help())\n  }\n\n  self.functionDescription = function (fn) {\n    var description = fn.name ? require('decamelize')(fn.name, '-') : __('generated-value')\n    return ['(', description, ')'].join('')\n  }\n\n  self.stringifiedValues = function (values, separator) {\n    var string = ''\n    var sep = separator || ', '\n    var array = [].concat(values)\n\n    if (!values || !array.length) return string\n\n    array.forEach(function (value) {\n      if (string.length) string += sep\n      string += JSON.stringify(value)\n    })\n\n    return string\n  }\n\n  // format the default-value-string displayed in\n  // the right-hand column.\n  function defaultString (value, defaultDescription) {\n    var string = '[' + __('default:') + ' '\n\n    if (value === undefined && !defaultDescription) return null\n\n    if (defaultDescription) {\n      string += defaultDescription\n    } else {\n      switch (typeof value) {\n        case 'string':\n          string += JSON.stringify(value)\n          break\n        case 'object':\n          string += JSON.stringify(value)\n          break\n        default:\n          string += value\n      }\n    }\n\n    return string + ']'\n  }\n\n  // guess the width of the console window, max-width 80.\n  function windowWidth () {\n    const wsize = require('window-size')\n    return wsize.width ? Math.min(80, wsize.width) : null\n  }\n\n  // logic for displaying application version.\n  var version = null\n  self.version = function (ver) {\n    version = ver\n  }\n\n  self.showVersion = function () {\n    const logger = yargs._getLoggerInstance()\n    if (typeof version === 'function') logger.log(version())\n    else logger.log(version)\n  }\n\n  self.reset = function (globalLookup) {\n    // do not reset wrap here\n    // do not reset fails here\n    failMessage = null\n    failureOutput = false\n    usage = undefined\n    epilog = undefined\n    examples = []\n    commands = []\n    descriptions = objFilter(descriptions, function (k, v) {\n      return globalLookup[k]\n    })\n    return self\n  }\n\n  var frozen\n  self.freeze = function () {\n    frozen = {}\n    frozen.failMessage = failMessage\n    frozen.failureOutput = failureOutput\n    frozen.usage = usage\n    frozen.epilog = epilog\n    frozen.examples = examples\n    frozen.commands = commands\n    frozen.descriptions = descriptions\n  }\n  self.unfreeze = function () {\n    failMessage = frozen.failMessage\n    failureOutput = frozen.failureOutput\n    usage = frozen.usage\n    epilog = frozen.epilog\n    examples = frozen.examples\n    commands = frozen.commands\n    descriptions = frozen.descriptions\n    frozen = undefined\n  }\n\n  return self\n}\n","/home/travis/build/npmtest/node-npmtest-auto-install/auto-install/node_modules/yargs/lib/obj-filter.js":"module.exports = function (original, filter) {\n  const obj = {}\n  filter = filter || function (k, v) { return true }\n  Object.keys(original || {}).forEach(function (key) {\n    if (filter(key, original[key])) {\n      obj[key] = original[key]\n    }\n  })\n  return obj\n}\n","/home/travis/build/npmtest/node-npmtest-auto-install/auto-install/node_modules/yargs/lib/validation.js":"const objFilter = require('./obj-filter')\n\n// validation-type-stuff, missing params,\n// bad implications, custom checks.\nmodule.exports = function (yargs, usage, y18n) {\n  const __ = y18n.__\n  const __n = y18n.__n\n  const self = {}\n\n  // validate appropriate # of non-option\n  // arguments were provided, i.e., '_'.\n  self.nonOptionCount = function (argv) {\n    const demanded = yargs.getDemanded()\n    // don't count currently executing commands\n    const _s = argv._.length - yargs.getContext().commands.length\n\n    if (demanded._ && (_s < demanded._.count || _s > demanded._.max)) {\n      if (demanded._.msg !== undefined) {\n        usage.fail(demanded._.msg)\n      } else if (_s < demanded._.count) {\n        usage.fail(\n          __('Not enough non-option arguments: got %s, need at least %s', _s, demanded._.count)\n        )\n      } else {\n        usage.fail(\n          __('Too many non-option arguments: got %s, maximum of %s', _s, demanded._.max)\n        )\n      }\n    }\n  }\n\n  // validate the appropriate # of <required>\n  // positional arguments were provided:\n  self.positionalCount = function (required, observed) {\n    if (observed < required) {\n      usage.fail(\n        __('Not enough non-option arguments: got %s, need at least %s', observed, required)\n      )\n    }\n  }\n\n  // make sure that any args that require an\n  // value (--foo=bar), have a value.\n  self.missingArgumentValue = function (argv) {\n    const defaultValues = [true, false, '']\n    const options = yargs.getOptions()\n\n    if (options.requiresArg.length > 0) {\n      const missingRequiredArgs = []\n\n      options.requiresArg.forEach(function (key) {\n        const value = argv[key]\n\n        // if a value is explicitly requested,\n        // flag argument as missing if it does not\n        // look like foo=bar was entered.\n        if (~defaultValues.indexOf(value) ||\n          (Array.isArray(value) && !value.length)) {\n          missingRequiredArgs.push(key)\n        }\n      })\n\n      if (missingRequiredArgs.length > 0) {\n        usage.fail(__n(\n          'Missing argument value: %s',\n          'Missing argument values: %s',\n          missingRequiredArgs.length,\n          missingRequiredArgs.join(', ')\n        ))\n      }\n    }\n  }\n\n  // make sure all the required arguments are present.\n  self.requiredArguments = function (argv) {\n    const demanded = yargs.getDemanded()\n    var missing = null\n\n    Object.keys(demanded).forEach(function (key) {\n      if (!argv.hasOwnProperty(key)) {\n        missing = missing || {}\n        missing[key] = demanded[key]\n      }\n    })\n\n    if (missing) {\n      const customMsgs = []\n      Object.keys(missing).forEach(function (key) {\n        const msg = missing[key].msg\n        if (msg && customMsgs.indexOf(msg) < 0) {\n          customMsgs.push(msg)\n        }\n      })\n\n      const customMsg = customMsgs.length ? '\\n' + customMsgs.join('\\n') : ''\n\n      usage.fail(__n(\n        'Missing required argument: %s',\n        'Missing required arguments: %s',\n        Object.keys(missing).length,\n        Object.keys(missing).join(', ') + customMsg\n      ))\n    }\n  }\n\n  // check for unknown arguments (strict-mode).\n  self.unknownArguments = function (argv, aliases) {\n    const aliasLookup = {}\n    const descriptions = usage.getDescriptions()\n    const demanded = yargs.getDemanded()\n    const commandKeys = yargs.getCommandInstance().getCommands()\n    const unknown = []\n    const currentContext = yargs.getContext()\n\n    Object.keys(aliases).forEach(function (key) {\n      aliases[key].forEach(function (alias) {\n        aliasLookup[alias] = key\n      })\n    })\n\n    Object.keys(argv).forEach(function (key) {\n      if (key !== '$0' && key !== '_' &&\n        !descriptions.hasOwnProperty(key) &&\n        !demanded.hasOwnProperty(key) &&\n        !aliasLookup.hasOwnProperty(key)) {\n        unknown.push(key)\n      }\n    })\n\n    if (commandKeys.length > 0) {\n      argv._.slice(currentContext.commands.length).forEach(function (key) {\n        if (commandKeys.indexOf(key) === -1) {\n          unknown.push(key)\n        }\n      })\n    }\n\n    if (unknown.length > 0) {\n      usage.fail(__n(\n        'Unknown argument: %s',\n        'Unknown arguments: %s',\n        unknown.length,\n        unknown.join(', ')\n      ))\n    }\n  }\n\n  // validate arguments limited to enumerated choices\n  self.limitedChoices = function (argv) {\n    const options = yargs.getOptions()\n    const invalid = {}\n\n    if (!Object.keys(options.choices).length) return\n\n    Object.keys(argv).forEach(function (key) {\n      if (key !== '$0' && key !== '_' &&\n        options.choices.hasOwnProperty(key)) {\n        [].concat(argv[key]).forEach(function (value) {\n          // TODO case-insensitive configurability\n          if (options.choices[key].indexOf(value) === -1) {\n            invalid[key] = (invalid[key] || []).concat(value)\n          }\n        })\n      }\n    })\n\n    const invalidKeys = Object.keys(invalid)\n\n    if (!invalidKeys.length) return\n\n    var msg = __('Invalid values:')\n    invalidKeys.forEach(function (key) {\n      msg += '\\n  ' + __(\n        'Argument: %s, Given: %s, Choices: %s',\n        key,\n        usage.stringifiedValues(invalid[key]),\n        usage.stringifiedValues(options.choices[key])\n      )\n    })\n    usage.fail(msg)\n  }\n\n  // custom checks, added using the `check` option on yargs.\n  var checks = []\n  self.check = function (f) {\n    checks.push(f)\n  }\n\n  self.customChecks = function (argv, aliases) {\n    for (var i = 0, f; (f = checks[i]) !== undefined; i++) {\n      var result = null\n      try {\n        result = f(argv, aliases)\n      } catch (err) {\n        usage.fail(err.message ? err.message : err, err)\n        continue\n      }\n\n      if (!result) {\n        usage.fail(__('Argument check failed: %s', f.toString()))\n      } else if (typeof result === 'string' || result instanceof Error) {\n        usage.fail(result.toString(), result)\n      }\n    }\n  }\n\n  // check implications, argument foo implies => argument bar.\n  var implied = {}\n  self.implies = function (key, value) {\n    if (typeof key === 'object') {\n      Object.keys(key).forEach(function (k) {\n        self.implies(k, key[k])\n      })\n    } else {\n      implied[key] = value\n    }\n  }\n  self.getImplied = function () {\n    return implied\n  }\n\n  self.implications = function (argv) {\n    const implyFail = []\n\n    Object.keys(implied).forEach(function (key) {\n      var booleanNegation\n      if (yargs.getOptions().configuration['boolean-negation'] === false) {\n        booleanNegation = false\n      } else {\n        booleanNegation = true\n      }\n      var num\n      const origKey = key\n      var value = implied[key]\n\n      // convert string '1' to number 1\n      num = Number(key)\n      key = isNaN(num) ? key : num\n\n      if (typeof key === 'number') {\n        // check length of argv._\n        key = argv._.length >= key\n      } else if (key.match(/^--no-.+/) && booleanNegation) {\n        // check if key doesn't exist\n        key = key.match(/^--no-(.+)/)[1]\n        key = !argv[key]\n      } else {\n        // check if key exists\n        key = argv[key]\n      }\n\n      num = Number(value)\n      value = isNaN(num) ? value : num\n\n      if (typeof value === 'number') {\n        value = argv._.length >= value\n      } else if (value.match(/^--no-.+/) && booleanNegation) {\n        value = value.match(/^--no-(.+)/)[1]\n        value = !argv[value]\n      } else {\n        value = argv[value]\n      }\n\n      if (key && !value) {\n        implyFail.push(origKey)\n      }\n    })\n\n    if (implyFail.length) {\n      var msg = __('Implications failed:') + '\\n'\n\n      implyFail.forEach(function (key) {\n        msg += ('  ' + key + ' -> ' + implied[key])\n      })\n\n      usage.fail(msg)\n    }\n  }\n\n  self.recommendCommands = function (cmd, potentialCommands) {\n    const distance = require('./levenshtein')\n    const threshold = 3 // if it takes more than three edits, let's move on.\n    potentialCommands = potentialCommands.sort(function (a, b) { return b.length - a.length })\n\n    var recommended = null\n    var bestDistance = Infinity\n    for (var i = 0, candidate; (candidate = potentialCommands[i]) !== undefined; i++) {\n      var d = distance(cmd, candidate)\n      if (d <= threshold && d < bestDistance) {\n        bestDistance = d\n        recommended = candidate\n      }\n    }\n    if (recommended) usage.fail(__('Did you mean %s?', recommended))\n  }\n\n  self.reset = function (globalLookup) {\n    implied = objFilter(implied, function (k, v) {\n      return globalLookup[k]\n    })\n    checks = []\n    return self\n  }\n\n  var frozen\n  self.freeze = function () {\n    frozen = {}\n    frozen.implied = implied\n    frozen.checks = checks\n  }\n  self.unfreeze = function () {\n    implied = frozen.implied\n    checks = frozen.checks\n    frozen = undefined\n  }\n\n  return self\n}\n","/home/travis/build/npmtest/node-npmtest-auto-install/auto-install/node_modules/package-json/index.js":"'use strict';\nvar url = require('url');\nvar got = require('got');\nvar registryUrl = require('registry-url');\nvar registryAuthToken = require('registry-auth-token');\nvar semver = require('semver');\n\nmodule.exports = function (name, version) {\n\tvar scope = name.split('/')[0];\n\tvar regUrl = registryUrl(scope);\n\tvar pkgUrl = url.resolve(regUrl, encodeURIComponent(name).replace(/^%40/, '@'));\n\tvar authInfo = registryAuthToken(regUrl);\n\tvar headers = {};\n\n\tif (authInfo) {\n\t\theaders.authorization = authInfo.type + ' ' + authInfo.token;\n\t}\n\n\treturn got(pkgUrl, {\n\t\tjson: true,\n\t\theaders: headers\n\t})\n\t\t.then(function (res) {\n\t\t\tvar data = res.body;\n\n\t\t\tif (version === 'latest') {\n\t\t\t\tdata = data.versions[data['dist-tags'].latest];\n\t\t\t} else if (version) {\n\t\t\t\tif (!data.versions[version]) {\n\t\t\t\t\tvar versions = Object.keys(data.versions);\n\t\t\t\t\tversion = semver.maxSatisfying(versions, version);\n\n\t\t\t\t\tif (!version) {\n\t\t\t\t\t\tthrow new Error('Version doesn\\'t exist');\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tdata = data.versions[version];\n\n\t\t\t\tif (!data) {\n\t\t\t\t\tthrow new Error('Version doesn\\'t exist');\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn data;\n\t\t})\n\t\t.catch(function (err) {\n\t\t\tif (err.statusCode === 404) {\n\t\t\t\tthrow new Error('Package `' + name + '` doesn\\'t exist');\n\t\t\t}\n\n\t\t\tthrow err;\n\t\t});\n};\n","/home/travis/build/npmtest/node-npmtest-auto-install/auto-install/node_modules/got/index.js":"'use strict';\n\nvar EventEmitter = require('events').EventEmitter;\nvar http = require('http');\nvar https = require('https');\nvar urlLib = require('url');\nvar querystring = require('querystring');\nvar objectAssign = require('object-assign');\nvar PassThrough = require('readable-stream').PassThrough;\nvar duplexer2 = require('duplexer2');\nvar isStream = require('is-stream');\nvar readAllStream = require('read-all-stream');\nvar timedOut = require('timed-out');\nvar urlParseLax = require('url-parse-lax');\nvar lowercaseKeys = require('lowercase-keys');\nvar isRedirect = require('is-redirect');\nvar PinkiePromise = require('pinkie-promise');\nvar unzipResponse = require('unzip-response');\nvar createErrorClass = require('create-error-class');\nvar nodeStatusCodes = require('node-status-codes');\nvar parseJson = require('parse-json');\nvar isRetryAllowed = require('is-retry-allowed');\nvar pkg = require('./package.json');\n\nfunction requestAsEventEmitter(opts) {\n\topts = opts || {};\n\n\tvar ee = new EventEmitter();\n\tvar requestUrl = opts.href || urlLib.resolve(urlLib.format(opts), opts.path);\n\tvar redirectCount = 0;\n\tvar retryCount = 0;\n\tvar redirectUrl;\n\n\tvar get = function (opts) {\n\t\tvar fn = opts.protocol === 'https:' ? https : http;\n\n\t\tvar req = fn.request(opts, function (res) {\n\t\t\tvar statusCode = res.statusCode;\n\n\t\t\tif (isRedirect(statusCode) && opts.followRedirect && 'location' in res.headers && (opts.method === 'GET' || opts.method === 'HEAD')) {\n\t\t\t\tres.resume();\n\n\t\t\t\tif (++redirectCount > 10) {\n\t\t\t\t\tee.emit('error', new got.MaxRedirectsError(statusCode, opts), null, res);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tredirectUrl = urlLib.resolve(urlLib.format(opts), res.headers.location);\n\t\t\t\tvar redirectOpts = objectAssign({}, opts, urlLib.parse(redirectUrl));\n\n\t\t\t\tee.emit('redirect', res, redirectOpts);\n\n\t\t\t\tget(redirectOpts);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// do not write ee.bind(...) instead of function - it will break gzip in Node.js 0.10\n\t\t\tsetImmediate(function () {\n\t\t\t\tvar response = typeof unzipResponse === 'function' && req.method !== 'HEAD' ? unzipResponse(res) : res;\n\t\t\t\tresponse.url = redirectUrl || requestUrl;\n\t\t\t\tresponse.requestUrl = requestUrl;\n\n\t\t\t\tee.emit('response', response);\n\t\t\t});\n\t\t});\n\n\t\treq.once('error', function (err) {\n\t\t\tvar backoff = opts.retries(++retryCount, err);\n\t\t\tif (backoff) {\n\t\t\t\tsetTimeout(get, backoff, opts);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tee.emit('error', new got.RequestError(err, opts));\n\t\t});\n\n\t\tif (opts.timeout) {\n\t\t\ttimedOut(req, opts.timeout);\n\t\t}\n\n\t\tsetImmediate(ee.emit.bind(ee), 'request', req);\n\t};\n\n\tget(opts);\n\treturn ee;\n}\n\nfunction asCallback(opts, cb) {\n\tvar ee = requestAsEventEmitter(opts);\n\n\tee.on('request', function (req) {\n\t\tif (isStream(opts.body)) {\n\t\t\topts.body.pipe(req);\n\t\t\topts.body = undefined;\n\t\t\treturn;\n\t\t}\n\n\t\treq.end(opts.body);\n\t});\n\n\tee.on('response', function (res) {\n\t\treadAllStream(res, opts.encoding, function (error, data) {\n\t\t\tvar statusCode = res.statusCode;\n\t\t\tvar limitStatusCode = opts.followRedirect ? 299 : 399;\n\n\t\t\tif (error) {\n\t\t\t\tcb(new got.ReadError(error, opts), null, res);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (statusCode < 200 || statusCode > limitStatusCode) {\n\t\t\t\terror = new got.HTTPError(statusCode, opts);\n\t\t\t}\n\n\t\t\tif (opts.json && data) {\n\t\t\t\ttry {\n\t\t\t\t\tdata = parseJson(data);\n\t\t\t\t} catch (err) {\n\t\t\t\t\terr.fileName = urlLib.format(opts);\n\t\t\t\t\terror = new got.ParseError(err, statusCode, opts);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tcb(error, data, res);\n\t\t});\n\t});\n\n\tee.on('error', cb);\n}\n\nfunction asPromise(opts) {\n\treturn new PinkiePromise(function (resolve, reject) {\n\t\tasCallback(opts, function (err, data, response) {\n\t\t\tif (response) {\n\t\t\t\tresponse.body = data;\n\t\t\t}\n\n\t\t\tif (err) {\n\t\t\t\tObject.defineProperty(err, 'response', {\n\t\t\t\t\tvalue: response,\n\t\t\t\t\tenumerable: false\n\t\t\t\t});\n\t\t\t\treject(err);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tresolve(response);\n\t\t});\n\t});\n}\n\nfunction asStream(opts) {\n\tvar input = new PassThrough();\n\tvar output = new PassThrough();\n\tvar proxy = duplexer2(input, output);\n\n\tif (opts.json) {\n\t\tthrow new Error('got can not be used as stream when options.json is used');\n\t}\n\n\tif (opts.body) {\n\t\tproxy.write = function () {\n\t\t\tthrow new Error('got\\'s stream is not writable when options.body is used');\n\t\t};\n\t}\n\n\tvar ee = requestAsEventEmitter(opts);\n\n\tee.on('request', function (req) {\n\t\tproxy.emit('request', req);\n\n\t\tif (isStream(opts.body)) {\n\t\t\topts.body.pipe(req);\n\t\t\treturn;\n\t\t}\n\n\t\tif (opts.body) {\n\t\t\treq.end(opts.body);\n\t\t\treturn;\n\t\t}\n\n\t\tif (opts.method === 'POST' || opts.method === 'PUT' || opts.method === 'PATCH') {\n\t\t\tinput.pipe(req);\n\t\t\treturn;\n\t\t}\n\n\t\treq.end();\n\t});\n\n\tee.on('response', function (res) {\n\t\tvar statusCode = res.statusCode;\n\t\tvar limitStatusCode = opts.followRedirect ? 299 : 399;\n\n\t\tres.pipe(output);\n\n\t\tif (statusCode < 200 || statusCode > limitStatusCode) {\n\t\t\tproxy.emit('error', new got.HTTPError(statusCode, opts), null, res);\n\t\t\treturn;\n\t\t}\n\n\t\tproxy.emit('response', res);\n\t});\n\n\tee.on('redirect', proxy.emit.bind(proxy, 'redirect'));\n\n\tee.on('error', proxy.emit.bind(proxy, 'error'));\n\n\treturn proxy;\n}\n\nfunction normalizeArguments(url, opts) {\n\tif (typeof url !== 'string' && typeof url !== 'object') {\n\t\tthrow new Error('Parameter `url` must be a string or object, not ' + typeof url);\n\t}\n\n\tif (typeof url === 'string') {\n\t\turl = url.replace(/^unix:/, 'http://$&');\n\t\turl = urlParseLax(url);\n\n\t\tif (url.auth) {\n\t\t\tthrow new Error('Basic authentication must be done with auth option');\n\t\t}\n\t}\n\n\topts = objectAssign(\n\t\t{protocol: 'http:', path: '', retries: 5},\n\t\turl,\n\t\topts\n\t);\n\n\topts.headers = objectAssign({\n\t\t'user-agent': pkg.name + '/' + pkg.version + ' (https://github.com/sindresorhus/got)',\n\t\t'accept-encoding': 'gzip,deflate'\n\t}, lowercaseKeys(opts.headers));\n\n\tvar query = opts.query;\n\n\tif (query) {\n\t\tif (typeof query !== 'string') {\n\t\t\topts.query = querystring.stringify(query);\n\t\t}\n\n\t\topts.path = opts.path.split('?')[0] + '?' + opts.query;\n\t\tdelete opts.query;\n\t}\n\n\tif (opts.json && opts.headers.accept === undefined) {\n\t\topts.headers.accept = 'application/json';\n\t}\n\n\tvar body = opts.body;\n\n\tif (body) {\n\t\tif (typeof body !== 'string' && !(body !== null && typeof body === 'object')) {\n\t\t\tthrow new Error('options.body must be a ReadableStream, string, Buffer or plain Object');\n\t\t}\n\n\t\topts.method = opts.method || 'POST';\n\n\t\tif (isStream(body) && typeof body.getBoundary === 'function') {\n\t\t\t// Special case for https://github.com/form-data/form-data\n\t\t\topts.headers['content-type'] = opts.headers['content-type'] || 'multipart/form-data; boundary=' + body.getBoundary();\n\t\t} else if (body !== null && typeof body === 'object' && !Buffer.isBuffer(body) && !isStream(body)) {\n\t\t\topts.headers['content-type'] = opts.headers['content-type'] || 'application/x-www-form-urlencoded';\n\t\t\tbody = opts.body = querystring.stringify(body);\n\t\t}\n\n\t\tif (opts.headers['content-length'] === undefined && opts.headers['transfer-encoding'] === undefined && !isStream(body)) {\n\t\t\tvar length = typeof body === 'string' ? Buffer.byteLength(body) : body.length;\n\t\t\topts.headers['content-length'] = length;\n\t\t}\n\t}\n\n\topts.method = opts.method || 'GET';\n\n\topts.method = opts.method.toUpperCase();\n\n\tif (opts.hostname === 'unix') {\n\t\tvar matches = /(.+):(.+)/.exec(opts.path);\n\n\t\tif (matches) {\n\t\t\topts.socketPath = matches[1];\n\t\t\topts.path = matches[2];\n\t\t\topts.host = null;\n\t\t}\n\t}\n\n\tif (typeof opts.retries !== 'function') {\n\t\tvar retries = opts.retries;\n\t\topts.retries = function backoff(iter, err) {\n\t\t\tif (iter > retries || !isRetryAllowed(err)) {\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tvar noise = Math.random() * 100;\n\t\t\treturn ((1 << iter) * 1000) + noise;\n\t\t};\n\t}\n\n\tif (opts.followRedirect === undefined) {\n\t\topts.followRedirect = true;\n\t}\n\n\treturn opts;\n}\n\nfunction got(url, opts, cb) {\n\tif (typeof opts === 'function') {\n\t\tcb = opts;\n\t\topts = {};\n\t}\n\n\tif (cb) {\n\t\tasCallback(normalizeArguments(url, opts), cb);\n\t\treturn null;\n\t}\n\n\ttry {\n\t\treturn asPromise(normalizeArguments(url, opts));\n\t} catch (err) {\n\t\treturn PinkiePromise.reject(err);\n\t}\n}\n\nvar helpers = [\n\t'get',\n\t'post',\n\t'put',\n\t'patch',\n\t'head',\n\t'delete'\n];\n\nhelpers.forEach(function (el) {\n\tgot[el] = function (url, opts, cb) {\n\t\tif (typeof opts === 'function') {\n\t\t\tcb = opts;\n\t\t\topts = {};\n\t\t}\n\n\t\treturn got(url, objectAssign({}, opts, {method: el}), cb);\n\t};\n});\n\ngot.stream = function (url, opts, cb) {\n\tif (cb || typeof opts === 'function') {\n\t\tthrow new Error('callback can not be used with stream mode');\n\t}\n\n\treturn asStream(normalizeArguments(url, opts));\n};\n\nhelpers.forEach(function (el) {\n\tgot.stream[el] = function (url, opts, cb) {\n\t\tif (typeof opts === 'function') {\n\t\t\tcb = opts;\n\t\t\topts = {};\n\t\t}\n\n\t\treturn got.stream(url, objectAssign({}, opts, {method: el}), cb);\n\t};\n});\n\nfunction stdError(error, opts) {\n\tif (error.code !== undefined) {\n\t\tthis.code = error.code;\n\t}\n\n\tobjectAssign(this, {\n\t\tmessage: error.message,\n\t\thost: opts.host,\n\t\thostname: opts.hostname,\n\t\tmethod: opts.method,\n\t\tpath: opts.path\n\t});\n}\n\ngot.RequestError = createErrorClass('RequestError', stdError);\ngot.ReadError = createErrorClass('ReadError', stdError);\n\ngot.ParseError = createErrorClass('ParseError', function (e, statusCode, opts) {\n\tstdError.call(this, e, opts);\n\tthis.statusCode = statusCode;\n\tthis.statusMessage = nodeStatusCodes[this.statusCode];\n});\n\ngot.HTTPError = createErrorClass('HTTPError', function (statusCode, opts) {\n\tstdError.call(this, {}, opts);\n\tthis.statusCode = statusCode;\n\tthis.statusMessage = nodeStatusCodes[this.statusCode];\n\tthis.message = 'Response code ' + this.statusCode + ' (' + this.statusMessage + ')';\n});\n\ngot.MaxRedirectsError = createErrorClass('MaxRedirectsError', function (statusCode, opts) {\n\tstdError.call(this, {}, opts);\n\tthis.statusCode = statusCode;\n\tthis.statusMessage = nodeStatusCodes[this.statusCode];\n\tthis.message = 'Redirected 10 times. Aborting.';\n});\n\nmodule.exports = got;\n","/home/travis/build/npmtest/node-npmtest-auto-install/auto-install/node_modules/timed-out/index.js":"'use strict';\n\nmodule.exports = function (req, time) {\n\tif (req.timeoutTimer) {\n\t\treturn req;\n\t}\n\n\tvar delays = isNaN(time) ? time : {socket: time, connect: time};\n\tvar host = req._headers ? (' to ' + req._headers.host) : '';\n\n\tif (delays.connect !== undefined) {\n\t\treq.timeoutTimer = setTimeout(function timeoutHandler() {\n\t\t\treq.abort();\n\t\t\tvar e = new Error('Connection timed out on request' + host);\n\t\t\te.code = 'ETIMEDOUT';\n\t\t\treq.emit('error', e);\n\t\t}, delays.connect);\n\t}\n\n\t// Clear the connection timeout timer once a socket is assigned to the\n\t// request and is connected.\n\treq.on('socket', function assign(socket) {\n\t\t// Socket may come from Agent pool and may be already connected.\n\t\tif (!(socket.connecting || socket._connecting)) {\n\t\t\tconnect.call(socket);\n\t\t\treturn;\n\t\t}\n\n\t\tsocket.once('connect', connect);\n\t});\n\n\tfunction clear() {\n\t\tif (req.timeoutTimer) {\n\t\t\tclearTimeout(req.timeoutTimer);\n\t\t\treq.timeoutTimer = null;\n\t\t}\n\t}\n\n\tfunction connect() {\n\t\tclear();\n\n\t\tif (delays.socket !== undefined) {\n\t\t\t// Abort the request if there is no activity on the socket for more\n\t\t\t// than `delays.socket` milliseconds.\n\t\t\tthis.setTimeout(delays.socket, function socketTimeoutHandler() {\n\t\t\t\treq.abort();\n\t\t\t\tvar e = new Error('Socket timed out on request' + host);\n\t\t\t\te.code = 'ESOCKETTIMEDOUT';\n\t\t\t\treq.emit('error', e);\n\t\t\t});\n\t\t}\n\t}\n\n\treturn req.on('error', clear);\n};\n","/home/travis/build/npmtest/node-npmtest-auto-install/auto-install/node_modules/unzip-response/index.js":"'use strict';\nvar PassThrough = require('stream').PassThrough;\nvar zlib = require('zlib');\n\nmodule.exports = function (res) {\n\t// TODO: use Array#includes when targeting Node.js 6\n\tif (['gzip', 'deflate'].indexOf(res.headers['content-encoding']) === -1) {\n\t\treturn res;\n\t}\n\n\tvar unzip = zlib.createUnzip();\n\tvar stream = new PassThrough();\n\n\tstream.httpVersion = res.httpVersion;\n\tstream.headers = res.headers;\n\tstream.rawHeaders = res.rawHeaders;\n\tstream.trailers = res.trailers;\n\tstream.rawTrailers = res.rawTrailers;\n\tstream.setTimeout = res.setTimeout.bind(res);\n\tstream.statusCode = res.statusCode;\n\tstream.statusMessage = res.statusMessage;\n\tstream.socket = res.socket;\n\n\tunzip.on('error', function (err) {\n\t\tif (err.code === 'Z_BUF_ERROR') {\n\t\t\tstream.end();\n\t\t\treturn;\n\t\t}\n\n\t\tstream.emit('error', err);\n\t});\n\n\tres.pipe(unzip).pipe(stream);\n\n\treturn stream;\n};\n","/home/travis/build/npmtest/node-npmtest-auto-install/auto-install/src/includes-polyfill.js":"Array.prototype.includes = function includes(searchElement) {\n    if (this == null) {\n        throw new TypeError('Array.prototype.includes called on null or undefined');\n    }\n\n    let O = Object(this);\n    let len = parseInt(O.length, 10) || 0;\n    if (len === 0) {\n        return false;\n    }\n    let n = parseInt(arguments[1], 10) || 0;\n    let k;\n    if (n >= 0) {\n        k = n;\n    } else {\n        k = len + n;\n        if (k < 0) { k = 0; }\n    }\n    let currentElement;\n    while (k < len) {\n        currentElement = O[k];\n        if (searchElement === currentElement ||\n     (searchElement !== searchElement && currentElement !== currentElement)) { // NaN !== NaN\n            return true;\n        }\n        k++;\n    }\n    return false;\n};\n"}